<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SPECRAUM</title>
  <style>
    :root {
      --bg-top: #16181d;
      --bg-mid: #1a1d24;
      --bg-bot: #11141a;
      --grid-strong: rgba(130, 158, 208, 0.24);
      --grid-soft: rgba(130, 158, 208, 0.10);
      --grid-top: rgba(170, 196, 238, 0.52);
      --line-main: #a9c6d8;
      --line-light: rgba(230, 236, 246, 0.82);
      --icon-fg: rgba(178, 190, 208, 0.96);
      --panel-bg: rgba(24, 28, 35, 0.76);
      --panel-bg-strong: rgba(24, 28, 35, 0.88);
      --panel-outline: rgba(169, 198, 216, 0.28);
      --panel-outline-soft: rgba(169, 198, 216, 0.18);
      --option-hover-bg: rgba(169, 198, 216, 0.16);
      --tooltip-bg: rgba(24, 28, 35, 0.90);
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    html, body {
      width: 100%;
      height: 100%;
      margin: 0;
      overflow: hidden;
      font-family: "Segoe UI", "SF Pro Display", Arial, sans-serif;
      background:
        radial-gradient(900px 460px at 15% 0%, #2a2f39 0%, transparent 58%),
        radial-gradient(1000px 520px at 100% 0%, #232730 0%, transparent 60%),
        linear-gradient(180deg, var(--bg-top), var(--bg-mid), var(--bg-bot));
    }

    .app {
      position: relative;
      width: 100%;
      height: 100%;
    }

    #spectrum {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls {
      display: flex;
      gap: 8px;
      z-index: 3;
      pointer-events: auto;
      align-items: center;
    }

    .preset-center {
      position: absolute;
      left: 50%;
      bottom: 10px;
      transform: translateX(-50%) translateY(8px) scale(0.96);
      z-index: 3;
      pointer-events: none;
      opacity: 0;
      transition:
        opacity 120ms ease,
        transform 180ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    .preset-center.is-visible {
      pointer-events: auto;
      opacity: 1;
      transform: translateX(-50%) translateY(0) scale(1);
      transition:
        opacity 130ms ease-out,
        transform 220ms cubic-bezier(0.2, 0.9, 0.25, 1.2);
    }

    .preset-center .select-trigger {
      min-width: 124px;
      text-align: center;
      justify-content: center;
      display: inline-flex;
      align-items: center;
    }

    .preset-center .select-menu {
      left: 50%;
      transform-origin: center bottom;
      transform: translate(-50%, 6px) scale(0.96);
    }

    .preset-center .control-select.open .select-menu {
      transform: translate(-50%, 0) scale(1);
    }

    .preset-inline-controls {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .overlay-knob {
      position: relative;
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 999px;
      padding: 0;
      cursor: ns-resize;
      outline: none;
      background: var(--panel-bg);
      box-shadow:
        inset 0 0 0 1px var(--panel-outline-soft);
      backdrop-filter: blur(3px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      vertical-align: middle;
    }

    .overlay-knob:hover,
    .overlay-knob:focus-visible {
      box-shadow:
        inset 0 0 0 1px var(--panel-outline);
    }

    .overlay-knob.is-dragging {
      box-shadow:
        inset 0 0 0 1px var(--panel-outline),
        0 0 0 1px rgba(0, 0, 0, 0.18);
    }

    .overlay-knob-indicator {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 1.6px;
      height: 7px;
      border-radius: 2px;
      background: var(--icon-fg);
      transform-origin: 50% 100%;
      transform: translate(-50%, -100%) rotate(var(--knob-angle, 0deg));
      opacity: 0.9;
      pointer-events: none;
    }

    .control-select {
      position: relative;
      min-width: 0;
    }

    .select-trigger {
      border: none;
      border-radius: 6px;
      background: var(--panel-bg);
      color: var(--icon-fg);
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.01em;
      height: 22px;
      padding: 0 9px;
      outline: none;
      cursor: pointer;
      backdrop-filter: blur(3px);
      line-height: 1;
      white-space: nowrap;
      text-align: left;
    }

    .control-select.open .select-trigger {
      box-shadow: inset 0 0 0 1px var(--panel-outline);
    }

    .select-menu {
      position: absolute;
      left: 0;
      bottom: calc(100% + 6px);
      min-width: 100%;
      display: flex;
      flex-direction: column;
      gap: 0;
      padding: 2px;
      border-radius: 6px;
      background: var(--panel-bg-strong);
      backdrop-filter: blur(3px);
      box-shadow: inset 0 0 0 1px var(--panel-outline-soft);
      z-index: 6;
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transform-origin: left bottom;
      transform: translateY(6px) scale(0.96);
      transition:
        opacity 120ms ease,
        transform 180ms cubic-bezier(0.4, 0, 0.2, 1),
        visibility 0s linear 180ms;
    }

    .control-select.open .select-menu {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      transform: translateY(0) scale(1);
      transition:
        opacity 130ms ease-out,
        transform 220ms cubic-bezier(0.2, 0.9, 0.25, 1.25),
        visibility 0s linear 0s;
    }

    .select-option {
      border: none;
      border-radius: 0;
      background: transparent;
      color: var(--icon-fg);
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.01em;
      line-height: 1;
      height: 22px;
      padding: 0 10px;
      cursor: pointer;
      white-space: nowrap;
      text-align: left;
      transition: background-color 70ms ease-out;
    }

    .select-option:first-child {
      border-top-left-radius: 4px;
      border-top-right-radius: 4px;
    }

    .select-option:last-child {
      border-bottom-left-radius: 4px;
      border-bottom-right-radius: 4px;
    }

    .select-option:hover,
    .select-option.is-active {
      background: var(--option-hover-bg);
    }

    .action-btn {
      min-width: 74px;
      text-align: center;
      justify-content: center;
      display: inline-flex;
      align-items: center;
      font-size: 8px;
      letter-spacing: 0.02em;
    }

    .action-btn.is-busy {
      opacity: 0.74;
      cursor: progress;
    }

    .preset-status {
      min-width: 126px;
      max-width: 200px;
      padding: 0 8px;
      height: 22px;
      border-radius: 6px;
      background: var(--panel-bg);
      color: var(--icon-fg);
      font-size: 8px;
      font-weight: 600;
      letter-spacing: 0.01em;
      line-height: 22px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.92;
    }

    .left-toolbar {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 3;
      display: flex;
      align-items: flex-end;
      gap: 8px;
      pointer-events: none;
      opacity: 0;
      transform: translateY(8px) scale(0.96);
      transform-origin: left bottom;
      transition:
        opacity 120ms ease,
        transform 180ms cubic-bezier(0.4, 0, 0.2, 1);
    }

    .left-toolbar.is-visible {
      pointer-events: auto;
      opacity: 1;
      transform: translateY(0) scale(1);
      transition:
        opacity 130ms ease-out,
        transform 220ms cubic-bezier(0.2, 0.9, 0.25, 1.2);
    }

    .button-stack {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .osc-stack {
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: center;
    }

    .theme-picker {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .theme-toggle-btn .theme-indicator {
      position: relative;
      width: 12px;
      height: 12px;
      display: block;
      transform: rotate(-22deg);
    }

    .theme-toggle-btn .theme-indicator::before {
      content: "";
      position: absolute;
      left: 2px;
      top: 2px;
      width: 8px;
      height: 7px;
      border-radius: 1px;
      border: 1px solid var(--icon-fg);
      background: linear-gradient(
        to bottom,
        transparent 0 46%,
        var(--swatch-color, #a9c6d8) 46% 100%
      );
      box-sizing: border-box;
    }

    .theme-toggle-btn .theme-indicator::after {
      content: "";
      position: absolute;
      left: 0;
      bottom: 1px;
      width: 5px;
      height: 2px;
      border-radius: 2px;
      background: var(--swatch-color, #a9c6d8);
    }

    .theme-choices {
      position: absolute;
      left: calc(100% + 6px);
      top: 50%;
      display: flex;
      gap: 4px;
      padding: 2px;
      border-radius: 6px;
      background: var(--panel-bg-strong);
      backdrop-filter: blur(3px);
      box-shadow: inset 0 0 0 1px var(--panel-outline-soft);
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
      transform: translateY(-50%) translateX(-4px) scale(0.96);
      transform-origin: left center;
      transition:
        opacity 120ms ease,
        transform 180ms cubic-bezier(0.4, 0, 0.2, 1),
        visibility 0s linear 180ms;
      z-index: 7;
    }

    .theme-picker.open .theme-choices {
      opacity: 1;
      visibility: visible;
      pointer-events: auto;
      transform: translateY(-50%) translateX(0) scale(1);
      transition:
        opacity 130ms ease-out,
        transform 220ms cubic-bezier(0.2, 0.9, 0.25, 1.25),
        visibility 0s linear 0s;
    }

    .theme-choice::before {
      content: "";
      width: 8px;
      height: 8px;
      border-radius: 1px;
      background: var(--swatch-color, #a9c6d8);
    }

    .theme-choice.is-active {
      box-shadow: inset 0 0 0 1px var(--panel-outline);
    }

    .theme-choice.is-disabled {
      opacity: 0.45;
      cursor: default;
    }

    .is-hidden {
      display: none !important;
    }

    .icon-btn {
      width: 22px;
      height: 22px;
      border: none;
      border-radius: 6px;
      background: var(--panel-bg);
      cursor: pointer;
      backdrop-filter: blur(3px);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
    }

    .icon-btn.is-off {
      opacity: 0.52;
    }

    .menu-toggle .triangle {
      width: 0;
      height: 0;
      border-top: 4px solid transparent;
      border-bottom: 4px solid transparent;
      border-left: 6px solid var(--icon-fg);
      transform-origin: 35% 50%;
      transition: transform 120ms ease;
    }

    .menu-toggle.open .triangle {
      transform: rotate(90deg);
    }

    .fullscreen-btn::before {
      content: "";
      width: 8px;
      height: 8px;
      background: var(--icon-fg);
      border-radius: 1px;
    }

    .osc-btn .osc-icon {
      width: 10px;
      height: 8px;
      background:
        linear-gradient(135deg,
          transparent 0 12%,
          var(--icon-fg) 12% 24%,
          transparent 24% 36%,
          var(--icon-fg) 36% 48%,
          transparent 48% 60%,
          var(--icon-fg) 60% 72%,
          transparent 72% 100%);
      border-radius: 1px;
      opacity: 0.96;
    }

    .len-btn {
      color: var(--icon-fg);
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.01em;
      line-height: 1;
      opacity: 1 !important;
      min-width: 22px;
    }

    .ui-tooltip {
      position: fixed;
      z-index: 10;
      pointer-events: none;
      border: none;
      border-radius: 6px;
      background: var(--tooltip-bg);
      color: var(--icon-fg);
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.01em;
      line-height: 1;
      padding: 6px 8px;
      backdrop-filter: blur(3px);
      white-space: nowrap;
    }
  </style>
</head>
<body>
  <div class="app">
    <canvas id="spectrum"></canvas>

    <div class="left-toolbar" id="leftToolbar">
      <div class="button-stack">
        <button class="icon-btn fullscreen-btn is-off" id="fullscreenBtn" aria-label="Fullscreen" data-tooltip="Fullscreen"></button>
        <div class="osc-stack">
          <button class="icon-btn osc-btn" id="oscToggleBtn" aria-label="Oscilloscope" data-tooltip="Oscilloscope">
            <span class="osc-icon"></span>
          </button>
          <button class="icon-btn len-btn" id="oscLengthBtn" type="button" aria-label="Oscilloscope Length" data-tooltip="Oscilloscope Length">1/4</button>
        </div>
        <div class="theme-picker" id="themePicker">
          <button class="icon-btn theme-toggle-btn is-off" id="themeToggleBtn" type="button" aria-label="Color Theme" data-tooltip="Color Theme">
            <span class="theme-indicator"></span>
          </button>
          <div class="theme-choices" id="themeChoices">
            <button class="icon-btn theme-choice" type="button" data-theme="mono" style="--swatch-color: #ffffff;" data-tooltip="Monochrome"></button>
            <button class="icon-btn theme-choice" type="button" data-theme="blue" style="--swatch-color: #5e88bf;" data-tooltip="Blue"></button>
            <button class="icon-btn theme-choice" type="button" data-theme="green" style="--swatch-color: #4f9a63;" data-tooltip="Green"></button>
            <button class="icon-btn theme-choice" type="button" data-theme="orange" style="--swatch-color: #c27a37;" data-tooltip="Orange"></button>
            <button class="icon-btn theme-choice" type="button" data-theme="purple" style="--swatch-color: #8a64c7;" data-tooltip="Purple"></button>
          </div>
        </div>
        <button class="icon-btn menu-toggle is-off" id="menuToggle" aria-label="Analyzer options" data-tooltip="Analyzer options">
          <span class="triangle"></span>
        </button>
      </div>

      <div class="controls is-hidden" id="controlsPanel">
        <div class="control-select" id="resolutionSel">
          <button class="select-trigger" type="button" aria-label="Resolution" aria-haspopup="listbox" aria-expanded="false" data-tooltip="Resolution">High</button>
          <div class="select-menu" role="listbox" aria-label="Resolution">
            <button class="select-option is-active" type="button" data-value="high">High</button>
            <button class="select-option" type="button" data-value="medium">Medium</button>
            <button class="select-option" type="button" data-value="low">Low</button>
          </div>
        </div>
        <div class="control-select" id="speedSel">
          <button class="select-trigger" type="button" aria-label="Speed" aria-haspopup="listbox" aria-expanded="false" data-tooltip="Speed">Medium</button>
          <div class="select-menu" role="listbox" aria-label="Speed">
            <button class="select-option" type="button" data-value="fast">Fast</button>
            <button class="select-option is-active" type="button" data-value="medium">Medium</button>
            <button class="select-option" type="button" data-value="slow">Slow</button>
          </div>
        </div>
        <div class="control-select" id="tiltSel">
          <button class="select-trigger" type="button" aria-label="Tilt" aria-haspopup="listbox" aria-expanded="false" data-tooltip="Tilt">5 dB</button>
          <div class="select-menu" role="listbox" aria-label="Tilt">
            <button class="select-option" type="button" data-value="0">0 dB</button>
            <button class="select-option" type="button" data-value="0.5">0.5 dB</button>
            <button class="select-option" type="button" data-value="1">1 dB</button>
            <button class="select-option" type="button" data-value="1.5">1.5 dB</button>
            <button class="select-option" type="button" data-value="2">2 dB</button>
            <button class="select-option" type="button" data-value="2.5">2.5 dB</button>
            <button class="select-option" type="button" data-value="3">3 dB</button>
            <button class="select-option" type="button" data-value="3.5">3.5 dB</button>
            <button class="select-option" type="button" data-value="4">4 dB</button>
            <button class="select-option" type="button" data-value="4.5">4.5 dB</button>
            <button class="select-option is-active" type="button" data-value="5">5 dB</button>
            <button class="select-option" type="button" data-value="5.5">5.5 dB</button>
            <button class="select-option" type="button" data-value="6">6 dB</button>
          </div>
        </div>
      </div>
    </div>

    <div class="preset-center" id="presetCenter">
      <div class="preset-inline-controls">
        <button
          class="overlay-knob"
          id="overlayWidthKnob"
          type="button"
          role="slider"
          aria-label="Overlay width"
          aria-orientation="vertical"
          aria-valuemin="3"
          aria-valuemax="18"
          aria-valuenow="12"
          data-tooltip="Overlay width: 12.0 dB">
          <span class="overlay-knob-indicator"></span>
        </button>
        <div class="control-select" id="smoothSourceSel">
          <button class="select-trigger" type="button" aria-label="Target Preset" aria-haspopup="listbox" aria-expanded="false" data-tooltip="Target preset">PSYTRANCE</button>
          <div class="select-menu" role="listbox" aria-label="Target Preset">
            <button class="select-option is-active" type="button" data-value="psytrance">PSYTRANCE</button>
            <button class="select-option" type="button" data-value="dubtechno">DUBTECHNO</button>
            <button class="select-option" type="button" data-value="orchestral">ORCHESTRAL</button>
          </div>
        </div>
        <button
          class="overlay-knob"
          id="overlayLevelKnob"
          type="button"
          role="slider"
          aria-label="Overlay level"
          aria-orientation="vertical"
          aria-valuemin="-23"
          aria-valuemax="0"
          aria-valuenow="0"
          data-tooltip="Overlay level: 0.0 dB">
          <span class="overlay-knob-indicator"></span>
        </button>
      </div>
    </div>
  </div>
  <div class="ui-tooltip is-hidden" id="uiTooltip"></div>

  <script>
    const BINS = 256;
    const rawTarget = new Float32Array(BINS);
    const shapedTarget = new Float32Array(BINS);
    const display = new Float32Array(BINS);
    const oscTarget = new Float32Array(BINS);
    const oscWork = new Float32Array(BINS);
    const oscDisplay = new Float32Array(BINS);
    let sampleRate = 44100;
    let oscAutoGain = 1.0;
    let oscDc = 0.0;

    const state = {
      resolution: "high",
      speed: "medium",
      tiltDb: 5.0,
      oscilloscopeOn: true,
      fullscreenOn: false,
      oscLengthMode: 0,
      theme: "blue",
      smoothSource: "psytrance",
      overlayLevelDb: 0.0,
      overlayWidthDb: 12.0
    };
    const builtInSmoothTargets = {
    "psytrance":  {
                       "label":  "PSYTRANCE",
                       "path":  "C:\\Users\\psilo\\Documents\\iZotope\\Tonal Balance Control 2\\Target Curves\\PSYTRANCE.json",
                       "filesAnalysed":  1,
                       "limited":  false,
                       "bins":  [
                                    0.56519705, 0.56694270, 0.56873628, 0.57052775, 0.57223002, 0.57397903, 0.57577607, 0.57762246, 0.57951954, 0.58146872, 0.58347142, 0.58552912, 0.58764332, 0.58981557, 0.59204747, 0.59434066, 0.59669682, 0.59911768, 0.60140486, 0.60329374, 0.60523449, 0.60722852, 0.60927732, 0.61138237, 0.61354523, 0.61576748, 0.61805075, 0.62039672, 0.62280710, 0.62426404, 0.62528739, 0.62633883, 0.62741916, 0.62852914, 0.62966961, 0.63084139, 0.63204535, 0.63266547, 0.63253342, 0.63239774, 0.63225834, 0.63211511, 0.63196794, 0.63181674, 0.63134989, 0.63074622, 0.63012598, 0.62948871, 0.62883393, 0.62815248, 0.62714085, 0.62610145, 0.62503350, 0.62393623, 0.62276958, 0.62120568, 0.61959883, 0.61794786, 0.61625156, 0.61423233, 0.61206443, 0.60983699, 0.60754839, 0.60503952, 0.60243596, 0.59976092, 0.59704261, 0.59430841, 0.59149912, 0.58864322, 0.58591509, 0.58311205, 0.58025889, 0.57745510, 0.57457431, 0.57160528, 0.56854293, 0.56539649, 0.56225456, 0.55903738, 0.55584763, 0.55268275, 0.54949751, 0.54640467, 0.54325384, 0.54015707, 0.53699608, 0.53385368, 0.53067759, 0.52755603, 0.52448586, 0.52148670, 0.51865937, 0.51586868, 0.51324266, 0.51063777, 0.50805411, 0.50575837, 0.50364891, 0.50168316, 0.49976672, 0.49774886, 0.49572668, 0.49382299, 0.49218045, 0.49071701, 0.48917695, 0.48762910, 0.48626181, 0.48508611, 0.48378887, 0.48227338, 0.48075235, 0.47933300, 0.47791732, 0.47641896, 0.47501689, 0.47353878, 0.47207739, 0.47076977, 0.46965742, 0.46836279, 0.46695023, 0.46570296, 0.46467454, 0.46362219, 0.46243922, 0.46121995, 0.45980529, 0.45842935, 0.45699487, 0.45558298, 0.45388275, 0.45218890, 0.45047764, 0.44903339, 0.44726964, 0.44553058, 0.44378430, 0.44211970, 0.44040996, 0.43856487, 0.43682190, 0.43488047, 0.43301112, 0.43116540, 0.42944586, 0.42744091, 0.42549179, 0.42356735, 0.42179634, 0.41986233, 0.41792817, 0.41578438, 0.41354792, 0.41128228, 0.40903698, 0.40676646, 0.40427458, 0.40180150, 0.39926311, 0.39677140, 0.39400170, 0.39131327, 0.38849813, 0.38581235, 0.38298914, 0.38028537, 0.37749650, 0.37476213, 0.37207772, 0.36949858, 0.36684280, 0.36402463, 0.36124476, 0.35848689, 0.35576028, 0.35293010, 0.35017633, 0.34737680, 0.34469267, 0.34201812, 0.33945107, 0.33689297, 0.33444069, 0.33202429, 0.32974178, 0.32747604, 0.32522312, 0.32302214, 0.32091925, 0.31896698, 0.31706435, 0.31528226, 0.31343245, 0.31142664, 0.30927248, 0.30703101, 0.30491550, 0.30300519, 0.30123269, 0.29963708, 0.29815797, 0.29680578, 0.29557308, 0.29443220, 0.29346701, 0.29256359, 0.29171093, 0.29094263, 0.28998496, 0.28877637, 0.28769721, 0.28671582, 0.28585172, 0.28512143, 0.28440353, 0.28347408, 0.28210839, 0.28053923, 0.27881146, 0.27695130, 0.27499005, 0.27285613, 0.27076823, 0.26870040, 0.26658658, 0.26432023, 0.26203053, 0.25969309, 0.25730897, 0.25471478, 0.25187373, 0.24875255, 0.24536844, 0.24176310, 0.23778099, 0.23335302, 0.22862688, 0.22347493, 0.21786697, 0.21179647, 0.20514909, 0.19771156, 0.18968977, 0.18122909, 0.17222144, 0.16266208, 0.15254926, 0.14192264, 0.13090300, 0.11954468, 0.10795907, 0.09638430, 0.08516726, 0.07480357
                                ]
                   },
    "dubtechno":  {
                        "label":  "DUBTECHNO",
                        "path":  "C:\\Users\\psilo\\Documents\\iZotope\\Tonal Balance Control 2\\Target Curves\\DUBTECHNO.json",
                        "filesAnalysed":  1,
                        "limited":  false,
                        "bins":  [
                                     0.64187133, 0.64337601, 0.64492201, 0.64643175, 0.64777083, 0.64914669, 0.65056032, 0.65201277, 0.65350510, 0.65503841, 0.65661382, 0.65823250, 0.65989562, 0.66160441, 0.66336013, 0.66516405, 0.66701751, 0.66892187, 0.67065717, 0.67193019, 0.67323817, 0.67458206, 0.67596286, 0.67738157, 0.67883924, 0.68033694, 0.68187576, 0.68345684, 0.68508133, 0.68591236, 0.68637694, 0.68685428, 0.68734473, 0.68784865, 0.68836640, 0.68889838, 0.68944496, 0.68943542, 0.68871353, 0.68797181, 0.68720972, 0.68642671, 0.68562219, 0.68479558, 0.68357575, 0.68217492, 0.68073562, 0.67925679, 0.67773736, 0.67616892, 0.67429620, 0.67237206, 0.67039508, 0.66836382, 0.66625639, 0.66390129, 0.66148152, 0.65899530, 0.65644081, 0.65389933, 0.65131613, 0.64866199, 0.64593497, 0.64320703, 0.64041630, 0.63754893, 0.63464980, 0.63176247, 0.62879586, 0.62577107, 0.62282059, 0.61978909, 0.61674867, 0.61397825, 0.61113176, 0.60840825, 0.60586945, 0.60326094, 0.60043274, 0.59750892, 0.59453678, 0.59151407, 0.58854901, 0.58588274, 0.58313348, 0.58025773, 0.57732300, 0.57440888, 0.57150329, 0.56875659, 0.56608218, 0.56350167, 0.56095112, 0.55832974, 0.55536881, 0.55231667, 0.54918609, 0.54634502, 0.54376897, 0.54137166, 0.53893348, 0.53662313, 0.53459414, 0.53260504, 0.53013674, 0.52694477, 0.52395266, 0.52124141, 0.51879451, 0.51651605, 0.51389488, 0.51075878, 0.50758319, 0.50464989, 0.50194673, 0.49913164, 0.49652899, 0.49402724, 0.49157378, 0.48851947, 0.48507533, 0.48160998, 0.47830671, 0.47535787, 0.47280333, 0.47018611, 0.46691712, 0.46395546, 0.46131917, 0.45887297, 0.45542168, 0.45207663, 0.44901188, 0.44658478, 0.44415321, 0.44187386, 0.43900411, 0.43602355, 0.43313088, 0.43066359, 0.42826808, 0.42536829, 0.42270643, 0.42029328, 0.41804818, 0.41478459, 0.41177442, 0.40859089, 0.40560176, 0.40257972, 0.39991133, 0.39653892, 0.39311555, 0.38998826, 0.38728786, 0.38438017, 0.38106474, 0.37799301, 0.37503831, 0.37227429, 0.36925747, 0.36651292, 0.36336924, 0.36043314, 0.35735962, 0.35459533, 0.35158186, 0.34857345, 0.34564438, 0.34301553, 0.34018625, 0.33722229, 0.33434987, 0.33143011, 0.32859651, 0.32583914, 0.32315331, 0.32015894, 0.31720656, 0.31426092, 0.31153853, 0.30863679, 0.30597772, 0.30345027, 0.30115410, 0.29894847, 0.29677931, 0.29467253, 0.29264351, 0.29062848, 0.28864478, 0.28682581, 0.28510899, 0.28347083, 0.28177870, 0.28010457, 0.27840603, 0.27677493, 0.27512098, 0.27344407, 0.27177050, 0.27020232, 0.26877471, 0.26741833, 0.26605416, 0.26474050, 0.26346741, 0.26231629, 0.26123821, 0.25996251, 0.25858728, 0.25713851, 0.25565542, 0.25404655, 0.25231668, 0.25050665, 0.24856944, 0.24640817, 0.24404270, 0.24144232, 0.23864887, 0.23576292, 0.23290422, 0.22994024, 0.22678312, 0.22341927, 0.21987549, 0.21620720, 0.21242617, 0.20859259, 0.20481945, 0.20111564, 0.19743690, 0.19366098, 0.18983830, 0.18580667, 0.18144449, 0.17663473, 0.17132024, 0.16534782, 0.15854997, 0.15085689, 0.14195786, 0.13145378, 0.11917668, 0.10483892, 0.09030703, 0.07479550, 0.05932614, 0.04509770, 0.03224554, 0.02084997, 0.01095703, 0.00257756, 0.00000000, 0.00000000
                                 ]
                    },
    "orchestral":  {
                        "label":  "ORCHESTRAL",
                        "path":  "C:\\Users\\psilo\\Documents\\iZotope\\Tonal Balance Control 2\\Target Curves\\ORCHESTRAL.json",
                        "filesAnalysed":  1,
                        "limited":  false,
                        "bins":  [
                                     0.56044705, 0.56164832, 0.56288257, 0.56409837, 0.56520647, 0.56634500, 0.56751479, 0.56871671, 0.56995163, 0.57122045, 0.57252413, 0.57386359, 0.57523984, 0.57665389, 0.57810676, 0.57959952,
                                     0.58113328, 0.58270915, 0.58418134, 0.58535542, 0.58656174, 0.58780119, 0.58907467, 0.59038312, 0.59172750, 0.59310879, 0.59452802, 0.59598621, 0.59748445, 0.59858957, 0.59952332, 0.60048272,
                                     0.60146847, 0.60248128, 0.60352190, 0.60459110, 0.60568966, 0.60654015, 0.60706710, 0.60760852, 0.60816480, 0.60873636, 0.60932361, 0.60992699, 0.61015361, 0.61022988, 0.61030824, 0.61038875,
                                     0.61047147, 0.61055011, 0.61040319, 0.61025224, 0.61009714, 0.60993778, 0.60975109, 0.60934561, 0.60892899, 0.60850094, 0.60806113, 0.60727443, 0.60635316, 0.60540659, 0.60443402, 0.60329855,
                                     0.60210957, 0.60088796, 0.59969126, 0.59857548, 0.59742907, 0.59626727, 0.59518234, 0.59406761, 0.59296745, 0.59205194, 0.59111129, 0.59022359, 0.58941316, 0.58858048, 0.58788061, 0.58718042,
                                     0.58639920, 0.58553650, 0.58467931, 0.58387751, 0.58302714, 0.58201495, 0.58100664, 0.58013099, 0.57921254, 0.57821833, 0.57711740, 0.57589626, 0.57495260, 0.57411127, 0.57345104, 0.57248542,
                                     0.57124593, 0.56991191, 0.56893799, 0.56815701, 0.56709537, 0.56591285, 0.56499836, 0.56427901, 0.56342195, 0.56217990, 0.56075560, 0.55923237, 0.55777856, 0.55648970, 0.55484575, 0.55246774,
                                     0.55000414, 0.54796252, 0.54618259, 0.54373134, 0.54124546, 0.53900874, 0.53722946, 0.53541426, 0.53348444, 0.53078163, 0.52721395, 0.52401098, 0.52141115, 0.51901548, 0.51556938, 0.51244539,
                                     0.50941574, 0.50691343, 0.50344902, 0.50031197, 0.49710128, 0.49435857, 0.49174746, 0.48967842, 0.48651285, 0.48221773, 0.47872673, 0.47607404, 0.47367354, 0.46991920, 0.46680279, 0.46375842,
                                     0.46158583, 0.45847153, 0.45586612, 0.45169433, 0.44779777, 0.44421373, 0.44171813, 0.43858628, 0.43494780, 0.43162671, 0.42877829, 0.42601993, 0.42218744, 0.41906038, 0.41551628, 0.41272826,
                                     0.40955492, 0.40736921, 0.40342748, 0.39987342, 0.39642583, 0.39417270, 0.39098905, 0.38775304, 0.38453681, 0.38196808, 0.37943703, 0.37656793, 0.37381354, 0.37005639, 0.36692810, 0.36370589,
                                     0.36129319, 0.35759992, 0.35447615, 0.35116506, 0.34867460, 0.34501704, 0.34124205, 0.33726412, 0.33357416, 0.32985459, 0.32635833, 0.32265601, 0.31778214, 0.31329131, 0.30899459, 0.30522359,
                                     0.30038575, 0.29568632, 0.29063829, 0.28608937, 0.28073089, 0.27553471, 0.26976054, 0.26393701, 0.25803087, 0.25257149, 0.24722934, 0.24174242, 0.23665319, 0.23199554, 0.22795659, 0.22358489,
                                     0.21965530, 0.21558003, 0.21186090, 0.20792484, 0.20439179, 0.20041171, 0.19644984, 0.19249410, 0.18884471, 0.18506961, 0.18114360, 0.17718962, 0.17329798, 0.16962793, 0.16585723, 0.16244017,
                                     0.15898273, 0.15573769, 0.15249083, 0.14948152, 0.14619580, 0.14280133, 0.13926110, 0.13583950, 0.13243147, 0.12904698, 0.12565483, 0.12231515, 0.11912420, 0.11606801, 0.11328535, 0.11065651,
                                     0.10827697, 0.10606200, 0.10411148, 0.10235433, 0.10085639, 0.09960240, 0.09867173, 0.09768751, 0.09695957, 0.09649599, 0.09621068, 0.09606941, 0.09599866, 0.09591437, 0.09570368, 0.09523428
                                 ]
                     }
};
    const themes = {
      blue: {
        swatch: "#5e88bf",
        css: {
          "--bg-top": "#121724",
          "--bg-mid": "#141a28",
          "--bg-bot": "#0d121b",
          "--icon-fg": "rgba(186, 206, 234, 0.96)",
          "--panel-bg": "rgba(16, 24, 36, 0.80)",
          "--panel-bg-strong": "rgba(16, 24, 36, 0.92)",
          "--panel-outline": "rgba(121, 165, 221, 0.30)",
          "--panel-outline-soft": "rgba(121, 165, 221, 0.20)",
          "--option-hover-bg": "rgba(121, 165, 221, 0.18)",
          "--tooltip-bg": "rgba(14, 21, 33, 0.92)"
        },
        canvas: {
          gridDbZero: "rgba(158, 194, 244, 0.54)",
          gridDbMajor: "rgba(102, 139, 198, 0.18)",
          gridDbMinor: "rgba(90, 124, 177, 0.08)",
          gridLabelPrimary: "rgba(218, 233, 255, 0.78)",
          gridLabelSecondary: "rgba(190, 214, 244, 0.46)",
          gridFreqStrong: "rgba(111, 149, 208, 0.17)",
          gridFreqSoft: "rgba(95, 131, 186, 0.08)",
          gridFreqLabel: "rgba(187, 214, 244, 0.36)",
          oscGridStrong: "rgba(121, 163, 224, 0.22)",
          oscGridSoft: "rgba(110, 149, 205, 0.12)",
          spectrumFillTop: "rgba(108, 171, 255, 0.30)",
          spectrumFillMid: "rgba(52, 95, 165, 0.16)",
          spectrumFillBottom: "rgba(18, 33, 74, 0.05)",
          spectrumGlow: "rgba(118, 190, 255, 0.34)",
          spectrumStrokeMain: "rgba(176, 214, 250, 0.98)",
          spectrumStrokeLight: "rgba(228, 241, 255, 0.84)",
          referenceStroke: "rgba(214, 229, 250, 0.88)",
          referenceGlow: "rgba(105, 153, 224, 0.24)",
          referenceBand: "rgba(98, 145, 218, 0.17)",
          oscCenterLine: "rgba(150, 183, 224, 0.18)",
          oscStroke: "rgba(174, 213, 248, 0.98)",
          crosshair: "rgba(222, 237, 255, 0.30)",
          readoutBg: "rgba(16, 22, 32, 0.70)",
          readoutText: "rgba(238, 245, 255, 0.92)",
          bgTop: "rgba(17, 24, 36, 0.96)",
          bgBottom: "rgba(10, 15, 24, 0.99)"
        }
      },
      mono: {
        swatch: "#ffffff",
        css: {
          "--bg-top": "#171717",
          "--bg-mid": "#151515",
          "--bg-bot": "#101010",
          "--icon-fg": "rgba(236, 236, 236, 0.96)",
          "--panel-bg": "rgba(30, 30, 30, 0.82)",
          "--panel-bg-strong": "rgba(30, 30, 30, 0.92)",
          "--panel-outline": "rgba(218, 218, 218, 0.24)",
          "--panel-outline-soft": "rgba(218, 218, 218, 0.14)",
          "--option-hover-bg": "rgba(230, 230, 230, 0.16)",
          "--tooltip-bg": "rgba(24, 24, 24, 0.92)"
        },
        canvas: {
          gridDbZero: "rgba(210, 210, 210, 0.52)",
          gridDbMajor: "rgba(175, 175, 175, 0.18)",
          gridDbMinor: "rgba(145, 145, 145, 0.08)",
          gridLabelPrimary: "rgba(236, 236, 236, 0.75)",
          gridLabelSecondary: "rgba(210, 210, 210, 0.44)",
          gridFreqStrong: "rgba(176, 176, 176, 0.16)",
          gridFreqSoft: "rgba(146, 146, 146, 0.08)",
          gridFreqLabel: "rgba(214, 214, 214, 0.34)",
          oscGridStrong: "rgba(192, 192, 192, 0.22)",
          oscGridSoft: "rgba(166, 166, 166, 0.12)",
          spectrumFillTop: "rgba(236, 236, 236, 0.24)",
          spectrumFillMid: "rgba(168, 168, 168, 0.12)",
          spectrumFillBottom: "rgba(98, 98, 98, 0.04)",
          spectrumGlow: "rgba(236, 236, 236, 0.30)",
          spectrumStrokeMain: "rgba(238, 238, 238, 0.98)",
          spectrumStrokeLight: "rgba(244, 244, 244, 0.82)",
          referenceStroke: "rgba(244, 244, 244, 0.94)",
          referenceGlow: "rgba(220, 220, 220, 0.24)",
          referenceBand: "rgba(220, 220, 220, 0.18)",
          oscCenterLine: "rgba(190, 190, 190, 0.20)",
          oscStroke: "rgba(236, 236, 236, 0.96)",
          crosshair: "rgba(236, 236, 236, 0.28)",
          readoutBg: "rgba(20, 20, 20, 0.68)",
          readoutText: "rgba(244, 244, 244, 0.92)",
          bgTop: "rgba(24, 24, 24, 0.96)",
          bgBottom: "rgba(14, 14, 14, 0.99)"
        }
      },
      green: {
        swatch: "#4f9a63",
        css: {
          "--bg-top": "#111b14",
          "--bg-mid": "#132016",
          "--bg-bot": "#0d1510",
          "--icon-fg": "rgba(190, 225, 199, 0.96)",
          "--panel-bg": "rgba(18, 33, 23, 0.80)",
          "--panel-bg-strong": "rgba(18, 33, 23, 0.92)",
          "--panel-outline": "rgba(106, 187, 127, 0.30)",
          "--panel-outline-soft": "rgba(106, 187, 127, 0.20)",
          "--option-hover-bg": "rgba(106, 187, 127, 0.18)",
          "--tooltip-bg": "rgba(14, 27, 18, 0.92)"
        },
        canvas: {
          gridDbZero: "rgba(167, 229, 182, 0.54)",
          gridDbMajor: "rgba(95, 161, 113, 0.18)",
          gridDbMinor: "rgba(74, 128, 90, 0.08)",
          gridLabelPrimary: "rgba(223, 250, 229, 0.78)",
          gridLabelSecondary: "rgba(189, 226, 198, 0.46)",
          gridFreqStrong: "rgba(103, 174, 123, 0.17)",
          gridFreqSoft: "rgba(82, 142, 101, 0.08)",
          gridFreqLabel: "rgba(184, 229, 195, 0.36)",
          oscGridStrong: "rgba(110, 188, 133, 0.22)",
          oscGridSoft: "rgba(95, 160, 116, 0.12)",
          spectrumFillTop: "rgba(111, 224, 146, 0.28)",
          spectrumFillMid: "rgba(52, 139, 84, 0.16)",
          spectrumFillBottom: "rgba(19, 75, 43, 0.05)",
          spectrumGlow: "rgba(131, 241, 165, 0.32)",
          spectrumStrokeMain: "rgba(184, 241, 201, 0.98)",
          spectrumStrokeLight: "rgba(230, 255, 239, 0.84)",
          referenceStroke: "rgba(227, 255, 236, 0.95)",
          referenceGlow: "rgba(74, 214, 132, 0.30)",
          referenceBand: "rgba(74, 214, 132, 0.22)",
          oscCenterLine: "rgba(145, 203, 160, 0.18)",
          oscStroke: "rgba(181, 238, 197, 0.98)",
          crosshair: "rgba(220, 250, 229, 0.30)",
          readoutBg: "rgba(15, 28, 19, 0.70)",
          readoutText: "rgba(236, 255, 242, 0.92)",
          bgTop: "rgba(16, 29, 20, 0.96)",
          bgBottom: "rgba(10, 18, 12, 0.99)"
        }
      },
      orange: {
        swatch: "#c27a37",
        css: {
          "--bg-top": "#21160d",
          "--bg-mid": "#271b10",
          "--bg-bot": "#181007",
          "--icon-fg": "rgba(240, 205, 166, 0.96)",
          "--panel-bg": "rgba(43, 28, 15, 0.80)",
          "--panel-bg-strong": "rgba(43, 28, 15, 0.92)",
          "--panel-outline": "rgba(213, 145, 83, 0.30)",
          "--panel-outline-soft": "rgba(213, 145, 83, 0.20)",
          "--option-hover-bg": "rgba(213, 145, 83, 0.18)",
          "--tooltip-bg": "rgba(36, 23, 13, 0.92)"
        },
        canvas: {
          gridDbZero: "rgba(248, 197, 141, 0.56)",
          gridDbMajor: "rgba(183, 123, 64, 0.20)",
          gridDbMinor: "rgba(145, 96, 46, 0.09)",
          gridLabelPrimary: "rgba(255, 233, 205, 0.78)",
          gridLabelSecondary: "rgba(244, 202, 158, 0.48)",
          gridFreqStrong: "rgba(197, 132, 70, 0.19)",
          gridFreqSoft: "rgba(157, 105, 52, 0.10)",
          gridFreqLabel: "rgba(244, 205, 166, 0.36)",
          oscGridStrong: "rgba(211, 146, 80, 0.23)",
          oscGridSoft: "rgba(170, 118, 64, 0.13)",
          spectrumFillTop: "rgba(255, 188, 111, 0.30)",
          spectrumFillMid: "rgba(176, 109, 50, 0.17)",
          spectrumFillBottom: "rgba(88, 51, 21, 0.06)",
          spectrumGlow: "rgba(255, 193, 125, 0.33)",
          spectrumStrokeMain: "rgba(255, 220, 180, 0.98)",
          spectrumStrokeLight: "rgba(255, 240, 221, 0.84)",
          referenceStroke: "rgba(255, 237, 215, 0.95)",
          referenceGlow: "rgba(236, 156, 66, 0.30)",
          referenceBand: "rgba(236, 156, 66, 0.22)",
          oscCenterLine: "rgba(219, 160, 99, 0.20)",
          oscStroke: "rgba(255, 216, 174, 0.98)",
          crosshair: "rgba(255, 228, 196, 0.31)",
          readoutBg: "rgba(34, 22, 13, 0.72)",
          readoutText: "rgba(255, 243, 228, 0.92)",
          bgTop: "rgba(35, 23, 13, 0.96)",
          bgBottom: "rgba(20, 13, 7, 0.99)"
        }
      },
      purple: {
        swatch: "#8a64c7",
        css: {
          "--bg-top": "#191327",
          "--bg-mid": "#1e1730",
          "--bg-bot": "#130f20",
          "--icon-fg": "rgba(213, 196, 242, 0.96)",
          "--panel-bg": "rgba(29, 23, 46, 0.80)",
          "--panel-bg-strong": "rgba(29, 23, 46, 0.92)",
          "--panel-outline": "rgba(154, 124, 209, 0.30)",
          "--panel-outline-soft": "rgba(154, 124, 209, 0.20)",
          "--option-hover-bg": "rgba(154, 124, 209, 0.18)",
          "--tooltip-bg": "rgba(23, 18, 38, 0.92)"
        },
        canvas: {
          gridDbZero: "rgba(201, 176, 248, 0.56)",
          gridDbMajor: "rgba(136, 108, 194, 0.20)",
          gridDbMinor: "rgba(108, 85, 157, 0.09)",
          gridLabelPrimary: "rgba(241, 230, 255, 0.78)",
          gridLabelSecondary: "rgba(215, 197, 246, 0.48)",
          gridFreqStrong: "rgba(148, 117, 210, 0.19)",
          gridFreqSoft: "rgba(118, 94, 174, 0.10)",
          gridFreqLabel: "rgba(217, 199, 248, 0.36)",
          oscGridStrong: "rgba(159, 127, 223, 0.23)",
          oscGridSoft: "rgba(128, 102, 186, 0.13)",
          spectrumFillTop: "rgba(197, 156, 255, 0.30)",
          spectrumFillMid: "rgba(126, 92, 197, 0.17)",
          spectrumFillBottom: "rgba(58, 40, 101, 0.06)",
          spectrumGlow: "rgba(206, 171, 255, 0.33)",
          spectrumStrokeMain: "rgba(228, 207, 255, 0.98)",
          spectrumStrokeLight: "rgba(244, 236, 255, 0.84)",
          referenceStroke: "rgba(239, 224, 255, 0.95)",
          referenceGlow: "rgba(170, 116, 242, 0.30)",
          referenceBand: "rgba(170, 116, 242, 0.22)",
          oscCenterLine: "rgba(170, 141, 224, 0.20)",
          oscStroke: "rgba(226, 203, 255, 0.98)",
          crosshair: "rgba(238, 226, 255, 0.31)",
          readoutBg: "rgba(22, 18, 36, 0.72)",
          readoutText: "rgba(246, 239, 255, 0.92)",
          bgTop: "rgba(25, 20, 40, 0.96)",
          bgBottom: "rgba(14, 11, 24, 0.99)"
        }
      }
    };

    let activeCanvasTheme = themes.blue.canvas;

    const resolutionMap = {
      high: { radius: 1, step: 1 },
      medium: { radius: 2, step: 1 },
      low: { radius: 4, step: 2 }
    };

    const speedMap = {
      fast: { attack: 0.58, release: 0.20 },
      medium: { attack: 0.32, release: 0.09 },
      slow: { attack: 0.16, release: 0.045 }
    };

    const freqTicks = [20, 30, 40, 50, 60, 80, 100, 200, 300, 500, 1000, 2000, 3000, 5000, 10000, 20000];
    const dbTicks = [-96, -78, -60, -42, -24, -12, -6, 0];
    const dbDisplayOffset = 24;

    const canvas = document.getElementById("spectrum");
    const ctx = canvas.getContext("2d");
    const resolutionSel = document.getElementById("resolutionSel");
    const speedSel = document.getElementById("speedSel");
    const tiltSel = document.getElementById("tiltSel");
    const smoothSourceSel = document.getElementById("smoothSourceSel");
    const leftToolbar = document.getElementById("leftToolbar");
    const menuToggle = document.getElementById("menuToggle");
    const controlsPanel = document.getElementById("controlsPanel");
    const fullscreenBtn = document.getElementById("fullscreenBtn");
    const oscToggleBtn = document.getElementById("oscToggleBtn");
    const oscLengthBtn = document.getElementById("oscLengthBtn");
    const themePicker = document.getElementById("themePicker");
    const themeToggleBtn = document.getElementById("themeToggleBtn");
    const themeChoiceButtons = Array.from(document.querySelectorAll(".theme-choice"));
    const smoothPresetBtn = document.getElementById("smoothPresetBtn");
    const presetStatus = document.getElementById("presetStatus");
    const uiTooltip = document.getElementById("uiTooltip");
    const presetCenter = document.getElementById("presetCenter");
    const overlayWidthKnob = document.getElementById("overlayWidthKnob");
    const overlayLevelKnob = document.getElementById("overlayLevelKnob");
    const toolbarSelectRoots = [resolutionSel, speedSel, tiltSel];
    const customSelectRoots = [resolutionSel, speedSel, tiltSel, smoothSourceSel];
    const overlayWidthBounds = {
      min: 3.0,
      max: 18.0,
      wheelStep: 0.5,
      dragScale: 0.08
    };
    const overlayLevelBounds = {
      min: -23.0,
      max: 0.0,
      wheelStep: 0.5,
      dragScale: 0.08
    };

    let mouseInside = false;
    let mouseX = 0;
    let mouseY = 0;
    let cornerHoverActive = false;
    let presetHoverActive = false;
    const cornerRevealSizePx = 176;
    const presetRevealWidthPx = 300;
    const presetRevealHeightPx = 148;
    const smoothPreset = new Float32Array(BINS);
    let hasSmoothPreset = false;
    let smoothPresetScanInProgress = false;
    let lastReferenceRevisionSeen = -1;
    let lastReferenceBinsReceived = 0;
    let lastReferenceHasFlag = false;
    let smoothScanWatchdogId = null;
    let builtInPresetLocked = false;
    let activeBuiltInPresetKey = "";
    let lastUiError = "";

    function initializeJuceBackendBridge() {
      if (typeof window.__JUCE__ !== "undefined"
          && typeof window.__JUCE__.getAndroidUserScripts === "function"
          && typeof window.inAndroidUserScriptEval === "undefined") {
        window.inAndroidUserScriptEval = true;
        try {
          eval(window.__JUCE__.getAndroidUserScripts());
        } catch (error) {
          console.warn("SPECRAUM: failed to evaluate Android JUCE bridge scripts.", error);
        }
      }

      if (typeof window.__JUCE__ === "undefined")
        window.__JUCE__ = {};

      if (typeof window.__JUCE__.backend === "undefined") {
        const eventListeners = new Map();

        window.__JUCE__.backend = {
          addEventListener(eventId, listener) {
            if (!eventListeners.has(eventId))
              eventListeners.set(eventId, new Set());
            eventListeners.get(eventId).add(listener);
          },

          removeEventListener(eventId, listener) {
            if (!eventListeners.has(eventId))
              return;
            eventListeners.get(eventId).delete(listener);
          },

          emitEvent(eventId, payload) {
            if (typeof window.__JUCE__.postMessage !== "function")
              return false;

            window.__JUCE__.postMessage(JSON.stringify({ eventId, payload }));
            return true;
          },

          emitByBackend(eventId, payload) {
            if (!eventListeners.has(eventId))
              return;

            let parsed = payload;
            if (typeof payload === "string") {
              try { parsed = JSON.parse(payload); } catch (_) {}
            }

            for (const listener of eventListeners.get(eventId))
              listener(parsed);
          }
        };
      }
    }

    function hasNativeBridge() {
      if (typeof window.__JUCE__ === "undefined")
        return false;

      const backend = window.__JUCE__.backend;
      if (backend && typeof backend.emitEvent === "function")
        return true;

      return typeof window.__JUCE__.postMessage === "function";
    }

    function nativeBridgeStatus() {
      if (typeof window.__JUCE__ === "undefined")
        return "missing __JUCE__";
      if (window.__JUCE__.backend && typeof window.__JUCE__.backend.emitEvent === "function")
        return "backend.emitEvent";
      if (typeof window.__JUCE__.postMessage === "function")
        return "postMessage";
      return "no transport";
    }

    function formatFreqLabel(freq) {
      if (freq >= 1000) {
        const k = freq / 1000;
        return (Number.isInteger(k) ? k.toFixed(0) : k.toFixed(1)) + "k";
      }
      return String(freq);
    }

    function formatFreqValue(freq) {
      if (freq >= 1000) return `${(freq / 1000).toFixed(2)} kHz`;
      return `${Math.round(freq)} Hz`;
    }

    function quantizeNote(freq) {
      if (!Number.isFinite(freq) || freq <= 0)
        return { name: "--", frequency: 0 };

      const midi = Math.max(0, Math.min(127, Math.round(69 + 12 * Math.log2(freq / 440))));
      const noteNames = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      const name = `${noteNames[midi % 12]}${Math.floor(midi / 12) - 1}`;
      const noteFreq = 440 * Math.pow(2, (midi - 69) / 12);
      return { name, frequency: noteFreq };
    }

    function ensureCanvasSize() {
      const rect = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const targetW = Math.max(1, Math.floor(rect.width * dpr));
      const targetH = Math.max(1, Math.floor(rect.height * dpr));

      if (canvas.width !== targetW || canvas.height !== targetH) {
        canvas.width = targetW;
        canvas.height = targetH;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      }

      return rect;
    }

    function resizeCanvas() {
      ensureCanvasSize();
    }

    function normToDb(norm) {
      return -96 + (Math.max(0, Math.min(1, norm)) * 96);
    }

    function dbToNorm(db) {
      return Math.max(0, Math.min(1, (db + 96) / 96));
    }

    function applyAnalyzerTiltToNorm(norm, binIndex) {
      const clamped = Math.max(0, Math.min(1, Number(norm)));
      const db = normToDb(clamped);
      const freq = binToFreq(Math.max(0, Math.min(BINS - 1, binIndex)));
      const octFrom1k = Math.log2(freq / 1000);
      return dbToNorm(db + (state.tiltDb * octFrom1k));
    }

    function offsetNormByDb(norm, dbOffset) {
      return dbToNorm(normToDb(norm) + dbOffset);
    }

    function rgbaWithAlpha(color, alpha) {
      const safeAlpha = Math.max(0, Math.min(1, Number(alpha)));
      if (typeof color === "string") {
        const match = color.match(/rgba?\s*\(\s*([^)]+)\)/i);
        if (match && match[1]) {
          const parts = match[1].split(",").map((x) => Number(x.trim()));
          if (parts.length >= 3) {
            const r = Math.max(0, Math.min(255, Math.round(parts[0])));
            const g = Math.max(0, Math.min(255, Math.round(parts[1])));
            const b = Math.max(0, Math.min(255, Math.round(parts[2])));
            return `rgba(${r}, ${g}, ${b}, ${safeAlpha})`;
          }
        }
      }
      return `rgba(56, 214, 255, ${safeAlpha})`;
    }

    function binToFreq(bin) {
      const minF = 20;
      const maxF = Math.min(20000, sampleRate * 0.5);
      return minF * Math.pow(maxF / minF, bin / (BINS - 1));
    }

    function freqToX(freq, width) {
      const minF = 20;
      const maxF = Math.min(20000, sampleRate * 0.5);
      const n = Math.log(freq / minF) / Math.log(maxF / minF);
      return Math.max(0, Math.min(width, n * width));
    }

    function xToFreq(x, width) {
      const minF = 20;
      const maxF = Math.min(20000, sampleRate * 0.5);
      const t = Math.max(0, Math.min(1, x / Math.max(1, width)));
      return minF * Math.pow(maxF / minF, t);
    }

    function yToDb(y, height) {
      const t = Math.max(0, Math.min(1, y / Math.max(1, height)));
      return (0 - (t * 96)) + dbDisplayOffset;
    }

    function formatTickDbLabel(db) {
      if (db === -24) return "0 dB";
      return "";
    }

    function clampValue(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function formatDb(value, includePlus = false) {
      const numeric = Number(value);
      if (!Number.isFinite(numeric))
        return "0.0 dB";
      const rounded = Math.round(numeric * 10) / 10;
      const sign = includePlus && rounded > 0 ? "+" : "";
      return `${sign}${rounded.toFixed(1)} dB`;
    }

    function applyKnobVisual(knob, value, bounds, tooltipPrefix, includePlus = false) {
      if (!knob)
        return;
      const span = bounds.max - bounds.min;
      const normalized = span > 0
        ? (value - bounds.min) / span
        : 0.5;
      const angle = -135 + normalized * 270;
      knob.style.setProperty("--knob-angle", `${angle.toFixed(1)}deg`);
      const label = formatDb(value, includePlus);
      knob.dataset.tooltip = `${tooltipPrefix}: ${label}`;
      knob.setAttribute("aria-valuenow", value.toFixed(1));
      knob.setAttribute("aria-valuetext", label);
    }

    function updateOverlayLevelKnobVisual() {
      applyKnobVisual(overlayLevelKnob, state.overlayLevelDb, overlayLevelBounds, "Overlay level");
    }

    function updateOverlayWidthKnobVisual() {
      applyKnobVisual(overlayWidthKnob, state.overlayWidthDb, overlayWidthBounds, "Overlay width");
    }

    function setOverlayLevelDb(value) {
      const numeric = Number(value);
      const bounded = clampValue(Number.isFinite(numeric) ? numeric : 0, overlayLevelBounds.min, overlayLevelBounds.max);
      const quantized = Math.round(bounded * 10) / 10;
      state.overlayLevelDb = quantized;
      updateOverlayLevelKnobVisual();
    }

    function setOverlayWidthDb(value) {
      const numeric = Number(value);
      const bounded = clampValue(Number.isFinite(numeric) ? numeric : 12, overlayWidthBounds.min, overlayWidthBounds.max);
      const quantized = Math.round(bounded * 10) / 10;
      state.overlayWidthDb = quantized;
      updateOverlayWidthKnobVisual();
    }

    function initializeDbKnob(knob, bounds, readValue, applyValue, resetValue) {
      if (!knob)
        return;

      let dragPointerId = null;
      let dragStartY = 0;
      let dragStartValue = 0;

      knob.addEventListener("pointerdown", (event) => {
        event.preventDefault();
        event.stopPropagation();
        dragPointerId = event.pointerId;
        dragStartY = event.clientY;
        dragStartValue = readValue();
        knob.classList.add("is-dragging");
        knob.setPointerCapture(event.pointerId);
      });

      knob.addEventListener("pointermove", (event) => {
        if (dragPointerId !== event.pointerId)
          return;
        const deltaY = dragStartY - event.clientY;
        const nextValue = dragStartValue + deltaY * bounds.dragScale;
        applyValue(nextValue);
      });

      const endDrag = (event) => {
        if (dragPointerId !== null && event.pointerId === dragPointerId) {
          dragPointerId = null;
          knob.classList.remove("is-dragging");
          if (knob.hasPointerCapture(event.pointerId))
            knob.releasePointerCapture(event.pointerId);
        }
      };

      knob.addEventListener("pointerup", endDrag);
      knob.addEventListener("pointercancel", endDrag);
      knob.addEventListener("lostpointercapture", () => {
        dragPointerId = null;
        knob.classList.remove("is-dragging");
      });

      knob.addEventListener("wheel", (event) => {
        event.preventDefault();
        event.stopPropagation();
        const step = event.shiftKey ? 0.1 : bounds.wheelStep;
        const delta = event.deltaY < 0 ? step : -step;
        applyValue(readValue() + delta);
      }, { passive: false });

      knob.addEventListener("keydown", (event) => {
        const fine = event.shiftKey ? 0.1 : bounds.wheelStep;
        if (event.key === "ArrowUp" || event.key === "ArrowRight") {
          event.preventDefault();
          applyValue(readValue() + fine);
        } else if (event.key === "ArrowDown" || event.key === "ArrowLeft") {
          event.preventDefault();
          applyValue(readValue() - fine);
        } else if (event.key === "Home") {
          event.preventDefault();
          applyValue(bounds.min);
        } else if (event.key === "End") {
          event.preventDefault();
          applyValue(bounds.max);
        } else if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          applyValue(resetValue);
        }
      });

      knob.addEventListener("dblclick", (event) => {
        event.preventDefault();
        event.stopPropagation();
        applyValue(resetValue);
      });
    }

    function initializeOverlayKnobs() {
      initializeDbKnob(overlayWidthKnob, overlayWidthBounds, () => state.overlayWidthDb, setOverlayWidthDb, 12.0);
      initializeDbKnob(overlayLevelKnob, overlayLevelBounds, () => state.overlayLevelDb, setOverlayLevelDb, 0.0);
      setOverlayWidthDb(state.overlayWidthDb);
      setOverlayLevelDb(state.overlayLevelDb);
    }

    function drawGrid(width, height) {
      ctx.save();
      ctx.lineWidth = 1;
      const zeroDbY = ((0 - (-24)) / 96) * height;
      const hidePresetOverlappingLabels = (
        presetHoverActive
        || (presetCenter && presetCenter.matches(":hover"))
        || (smoothSourceSel && smoothSourceSel.classList.contains("open"))
      );

      for (const db of dbTicks) {
        const y = ((0 - db) / 96) * height;
        if (db === 0) ctx.strokeStyle = activeCanvasTheme.gridDbZero;
        else ctx.strokeStyle = db % 24 === 0 ? activeCanvasTheme.gridDbMajor : activeCanvasTheme.gridDbMinor;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();

        const label = formatTickDbLabel(db);
        if (label !== "") {
          ctx.fillStyle = db === -24 ? activeCanvasTheme.gridLabelPrimary : activeCanvasTheme.gridLabelSecondary;
          ctx.font = "11px Segoe UI";
          ctx.textAlign = "right";
          ctx.fillText(label, width - 8, y - 4);
        }
      }

      for (const freq of freqTicks) {
        const x = freqToX(freq, width);
        const strong = (freq === 20 || freq === 100 || freq === 1000 || freq === 10000 || freq === 20000);
        ctx.strokeStyle = strong ? activeCanvasTheme.gridFreqStrong : activeCanvasTheme.gridFreqSoft;
        ctx.beginPath();
        ctx.moveTo(x, state.oscilloscopeOn ? zeroDbY : 0);
        ctx.lineTo(x, height);
        ctx.stroke();

        const overlapsPresetControls = freq === 500 || freq === 1000;
        if ((strong || freq === 200 || freq === 500 || freq === 2000 || freq === 5000)
            && freq !== 20 && freq !== 20000) {
          if (hidePresetOverlappingLabels && overlapsPresetControls)
            continue;
          ctx.fillStyle = activeCanvasTheme.gridFreqLabel;
          ctx.font = "11px Segoe UI";
          ctx.textAlign = "center";
          ctx.fillText(formatFreqLabel(freq), x, height - 10);
        }
      }

      if (state.oscilloscopeOn) {
        const sixteenthCount = state.oscLengthMode === 0 ? 4 : 16;
        for (let i = 0; i <= sixteenthCount; i++) {
          const x = (i / sixteenthCount) * width;
          const strong = (i % 4) === 0;
          ctx.strokeStyle = strong ? activeCanvasTheme.oscGridStrong : activeCanvasTheme.oscGridSoft;
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, zeroDbY);
          ctx.stroke();
        }
      }

      ctx.restore();
    }

    function setPresetStatus(message) {
      if (!presetStatus)
        return;
      presetStatus.textContent = message;
      presetStatus.dataset.tooltip = message;
    }

    function getOverlayProfileForSource(sourceKey) {
      const key = String(sourceKey || "");
      if (key === "psytrance" || key === "dubtechno") {
        return {
          liftDb: -6.0,
          bandWidthDb: 12.0
        };
      }

      return {
        liftDb: -6.0,
        bandWidthDb: 12.0
      };
    }

    function reportUiError(context, error) {
      const message = (error && typeof error.message === "string" && error.message.length > 0)
        ? error.message
        : String(error);
      const key = `${context}:${message}`;
      if (lastUiError === key)
        return;

      lastUiError = key;
      console.error(`SPECRAUM ${context} error`, error);
      setPresetStatus(`UI error (${context}): ${message}`);
    }

    function getSelectedSmoothSource() {
      let selected = state.smoothSource;

      if (smoothSourceSel && smoothSourceSel.dataset && typeof smoothSourceSel.dataset.value === "string"
          && smoothSourceSel.dataset.value.length > 0) {
        selected = smoothSourceSel.dataset.value;
      }

      if (state.smoothSource !== selected)
        state.smoothSource = selected;

      return selected;
    }

    function setSmoothScanBusy(isBusy) {
      smoothPresetScanInProgress = isBusy;
      if (smoothPresetBtn) {
        smoothPresetBtn.classList.toggle("is-busy", isBusy);
        smoothPresetBtn.textContent = isBusy ? "Scanning..." : "Build Smooth";
      }

      if (smoothScanWatchdogId !== null) {
        window.clearTimeout(smoothScanWatchdogId);
        smoothScanWatchdogId = null;
      }

      if (isBusy) {
        smoothScanWatchdogId = window.setTimeout(() => {
          smoothScanWatchdogId = null;
          smoothPresetScanInProgress = false;
          if (smoothPresetBtn) {
            smoothPresetBtn.classList.remove("is-busy");
            smoothPresetBtn.textContent = "Build Smooth";
          }
          setPresetStatus("Scan timed out. Try a smaller folder.");
        }, 180000);
      }
    }

    function applySmoothPreset(bins, hasPreset) {
      let values = null;
      if (Array.isArray(bins)) {
        values = bins;
      } else if (bins && typeof bins.length === "number") {
        values = Array.from(bins);
      }

      const hasValues = Array.isArray(values) && values.length > 0;
      lastReferenceBinsReceived = hasValues ? values.length : 0;
      lastReferenceHasFlag = !!hasPreset;
      hasSmoothPreset = hasValues;

      if (hasSmoothPreset) {
        const n = Math.min(BINS, values.length);
        for (let i = 0; i < n; i++) {
          const v = Number(values[i]);
          smoothPreset[i] = Number.isFinite(v) ? Math.max(0, Math.min(1, v)) : 0;
        }
        for (let i = n; i < BINS; i++) {
          const edgeValue = n > 0 ? smoothPreset[n - 1] : 0;
          smoothPreset[i] = edgeValue;
        }

        setPresetStatus("Smooth preset ready");
      }
      else {
        for (let i = 0; i < BINS; i++) {
          smoothPreset[i] = 0;
        }
        setPresetStatus("No smooth preset");
      }
    }

    function loadBuiltInSmoothTarget(key) {
      const preset = builtInSmoothTargets[key];
      if (!preset || !Array.isArray(preset.bins) || preset.bins.length === 0) {
        setPresetStatus(`Preset '${key}' unavailable.`);
        return false;
      }

      builtInPresetLocked = true;
      activeBuiltInPresetKey = key;
      applySmoothPreset(preset.bins, true);
      lastReferenceRevisionSeen = Math.max(lastReferenceRevisionSeen, 1);

      const label = typeof preset.label === "string" && preset.label.length > 0
        ? preset.label
        : key;
      const filesAnalysed = Number.isFinite(Number(preset.filesAnalysed))
        ? Math.max(0, Math.floor(Number(preset.filesAnalysed)))
        : 0;
      const limited = !!preset.limited;
      const suffix = limited ? ", limited scan" : "";
      setPresetStatus(`Loaded ${label} (${filesAnalysed} file(s)${suffix})`);
      return true;
    }

    function ensureBuiltInPresetActive() {
      const selectedSource = getSelectedSmoothSource();
      if (selectedSource === "folder")
        return;

      const preset = builtInSmoothTargets[selectedSource];
      if (!preset || !Array.isArray(preset.bins) || preset.bins.length === 0)
        return;

      if (!hasSmoothPreset || !builtInPresetLocked || activeBuiltInPresetKey !== selectedSource) {
        builtInPresetLocked = true;
        activeBuiltInPresetKey = selectedSource;
        applySmoothPreset(preset.bins, true);
      }
    }

    function drawSmoothPreset(width, height) {
      if (!hasSmoothPreset) return;

      const overlayTop = state.oscilloscopeOn
        ? ((0 - (-24)) / 96) * height
        : 0;
      const overlayProfile = getOverlayProfileForSource(getSelectedSmoothSource());
      const overlayLiftDb = overlayProfile.liftDb;
      const manualOverlayLevelDb = Number.isFinite(state.overlayLevelDb) ? state.overlayLevelDb : 0.0;
      const manualOverlayWidthDb = Number.isFinite(state.overlayWidthDb)
        ? state.overlayWidthDb
        : overlayProfile.bandWidthDb;
      const overlayWidthDb = clampValue(manualOverlayWidthDb, overlayWidthBounds.min, overlayWidthBounds.max);
      const halfWidthDb = 0.5 * overlayWidthDb;

      const centerPoints = [];
      const upperPoints = [];
      const lowerPoints = [];
      const upperRaw = new Float32Array(BINS);
      const lowerRaw = new Float32Array(BINS);
      const centerRaw = new Float32Array(BINS);
      let maxUpperDb = -Infinity;

      for (let i = 0; i < BINS; i++) {
        const center = offsetNormByDb(applyAnalyzerTiltToNorm(smoothPreset[i], i), overlayLiftDb);
        const centerDb = normToDb(center);
        const upper = dbToNorm(centerDb + halfWidthDb);
        const lower = dbToNorm(centerDb - halfWidthDb);
        upperRaw[i] = upper;
        lowerRaw[i] = lower;
        centerRaw[i] = center;
        const upperDb = normToDb(upper);
        if (upperDb > maxUpperDb)
          maxUpperDb = upperDb;
      }

      // Keep the top edge anchored to the displayed 0 dB grid line.
      // In this UI mapping, displayed 0 dB corresponds to internal -24 dB.
      const targetTopDb = -dbDisplayOffset;
      const alignToZeroDb = Number.isFinite(maxUpperDb) ? (targetTopDb - maxUpperDb) : 0.0;

      const finalOffsetDb = alignToZeroDb + manualOverlayLevelDb;
      for (let i = 0; i < BINS; i++) {
        const x = (i / (BINS - 1)) * width;
        const upper = offsetNormByDb(upperRaw[i], finalOffsetDb);
        const lower = offsetNormByDb(lowerRaw[i], finalOffsetDb);
        const center = offsetNormByDb(centerRaw[i], finalOffsetDb);
        upperPoints.push({
          x,
          y: (1 - upper) * height
        });
        lowerPoints.push({
          x,
          y: (1 - lower) * height
        });
        centerPoints.push({
          x,
          y: (1 - center) * height
        });
      }

      if (upperPoints.length === 0) return;

      ctx.save();
      if (overlayTop > 0) {
        ctx.beginPath();
        ctx.rect(0, overlayTop, width, Math.max(1, height - overlayTop));
        ctx.clip();
      }
      const reversedLower = lowerPoints.slice().reverse();
      let minUpperY = Infinity;
      let maxLowerY = -Infinity;
      for (let i = 0; i < upperPoints.length; i++) {
        minUpperY = Math.min(minUpperY, upperPoints[i].y);
        maxLowerY = Math.max(maxLowerY, lowerPoints[i].y);
      }
      const gradientTop = Number.isFinite(minUpperY) ? minUpperY : 0;
      const gradientBottom = Number.isFinite(maxLowerY) ? maxLowerY : height;

      // Draw tonal-balance target range band first.
      ctx.beginPath();
      ctx.moveTo(upperPoints[0].x, upperPoints[0].y);
      traceSpectrumCurve(upperPoints, false);
      ctx.lineTo(reversedLower[0].x, reversedLower[0].y);
      traceSpectrumCurve(reversedLower, false);
      ctx.closePath();
      const bandColor = activeCanvasTheme.referenceBand || "rgba(56, 214, 255, 0.24)";
      const fillGradient = ctx.createLinearGradient(0, gradientTop, 0, gradientBottom);
      fillGradient.addColorStop(0.00, rgbaWithAlpha(bandColor, 0.00));
      fillGradient.addColorStop(0.20, rgbaWithAlpha(bandColor, 0.07));
      fillGradient.addColorStop(0.50, rgbaWithAlpha(bandColor, 0.12));
      fillGradient.addColorStop(0.80, rgbaWithAlpha(bandColor, 0.07));
      fillGradient.addColorStop(1.00, rgbaWithAlpha(bandColor, 0.00));
      ctx.fillStyle = fillGradient;
      ctx.fill();

      const strokeColor = activeCanvasTheme.referenceStroke || "rgba(211, 249, 255, 0.96)";

      ctx.beginPath();
      traceSpectrumCurve(centerPoints, true);
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = 6.0;
      ctx.strokeStyle = rgbaWithAlpha(activeCanvasTheme.referenceGlow || "rgba(48, 205, 220, 0.30)", 0.17);
      ctx.stroke();

      ctx.beginPath();
      traceSpectrumCurve(centerPoints, true);
      ctx.lineWidth = 1.6;
      ctx.strokeStyle = rgbaWithAlpha(strokeColor, 0.32);
      ctx.shadowColor = rgbaWithAlpha(activeCanvasTheme.referenceGlow || "rgba(48, 205, 220, 0.30)", 0.30);
      ctx.shadowBlur = 3;
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function rebuildShapedTarget() {
      const cfg = resolutionMap[state.resolution];
      const radius = cfg.radius;
      for (let i = 0; i < BINS; i++) {
        let sum = 0;
        let count = 0;
        for (let j = i - radius; j <= i + radius; j++) {
          if (j >= 0 && j < BINS) {
            sum += rawTarget[j];
            count++;
          }
        }
        const norm = count > 0 ? sum / count : rawTarget[i];
        let db = normToDb(norm);
        const freq = binToFreq(i);
        const octFrom1k = Math.log2(freq / 1000);
        db += state.tiltDb * octFrom1k;
        shapedTarget[i] = dbToNorm(db);
      }
    }

    function updateDisplayResponse() {
      const speed = speedMap[state.speed];
      for (let i = 0; i < BINS; i++) {
        const target = shapedTarget[i];
        const coeff = target >= display[i] ? speed.attack : speed.release;
        display[i] += (target - display[i]) * coeff;
      }
    }

    function traceSpectrumCurve(points, moveToStart = true) {
      if (points.length === 0) return;
      if (moveToStart) ctx.moveTo(points[0].x, points[0].y);
      if (points.length === 1) return;
      if (points.length === 2) {
        ctx.lineTo(points[1].x, points[1].y);
        return;
      }

      for (let i = 1; i < points.length - 1; i++) {
        const mx = (points[i].x + points[i + 1].x) * 0.5;
        const my = (points[i].y + points[i + 1].y) * 0.5;
        ctx.quadraticCurveTo(points[i].x, points[i].y, mx, my);
      }

      const n = points.length - 1;
      ctx.quadraticCurveTo(points[n - 1].x, points[n - 1].y, points[n].x, points[n].y);
    }

    function drawSpectrum(width, height) {
      updateDisplayResponse();
      const step = resolutionMap[state.resolution].step;
      const points = [];

      for (let i = 0; i < BINS; i += step) {
        points.push({
          x: (i / (BINS - 1)) * width,
          y: (1 - display[i]) * height
        });
      }

      if (points.length === 0) return;
      const lastY = (1 - display[BINS - 1]) * height;
      if (points[points.length - 1].x < width) points.push({ x: width, y: lastY });

      ctx.beginPath();
      ctx.moveTo(points[0].x, height);
      ctx.lineTo(points[0].x, points[0].y);
      traceSpectrumCurve(points, false);
      ctx.lineTo(points[points.length - 1].x, height);
      ctx.closePath();

      const fill = ctx.createLinearGradient(0, 0, 0, height);
      fill.addColorStop(0, activeCanvasTheme.spectrumFillTop);
      fill.addColorStop(0.55, activeCanvasTheme.spectrumFillMid);
      fill.addColorStop(1, activeCanvasTheme.spectrumFillBottom);
      ctx.fillStyle = fill;
      ctx.fill();

      ctx.beginPath();
      traceSpectrumCurve(points, true);

      ctx.shadowColor = activeCanvasTheme.spectrumGlow;
      ctx.shadowBlur = 16;
      ctx.lineWidth = 2;
      ctx.strokeStyle = activeCanvasTheme.spectrumStrokeMain;
      ctx.stroke();

      ctx.shadowBlur = 0;
      ctx.lineWidth = 1;
      ctx.strokeStyle = activeCanvasTheme.spectrumStrokeLight;
      ctx.stroke();
    }

    function drawOscilloscope(width, height) {
      if (!state.oscilloscopeOn) return;

      const zeroDbY = ((0 - (-24)) / 96) * height;
      const top = 6;
      const bottom = Math.max(top + 22, zeroDbY - 6);
      const centerY = (top + bottom) * 0.5;
      const amplitude = (bottom - top) * 0.48;
      const points = [];
      let peak = 0;

      for (let i = 0; i < BINS; i++) {
        const sample = oscTarget[i];
        oscDc += (sample - oscDc) * 0.004;
        const centered = sample - oscDc;
        oscWork[i] = centered;
        const abs = Math.abs(centered);
        if (abs > peak) peak = abs;
      }

      const targetGain = Math.max(1.0, Math.min(24.0, 0.72 / Math.max(0.02, peak)));
      oscAutoGain += (targetGain - oscAutoGain) * 0.1;

      for (let i = 0; i < BINS; i++) {
        const boosted = Math.max(-1, Math.min(1, oscWork[i] * oscAutoGain));
        oscDisplay[i] += (boosted - oscDisplay[i]) * 0.55;
        points.push({
          x: (i / (BINS - 1)) * width,
          y: centerY - oscDisplay[i] * amplitude
        });
      }

      ctx.save();
      ctx.beginPath();
      ctx.moveTo(0, centerY);
      ctx.lineTo(width, centerY);
      ctx.strokeStyle = activeCanvasTheme.oscCenterLine;
      ctx.lineWidth = 1;
      ctx.stroke();

      ctx.beginPath();
      traceSpectrumCurve(points, true);
      ctx.strokeStyle = activeCanvasTheme.oscStroke;
      ctx.lineWidth = 2;
      ctx.stroke();
      ctx.restore();
    }

    function drawCrosshair(width, height) {
      if (!mouseInside) return;

      const x = Math.max(0, Math.min(width, mouseX));
      const y = Math.max(0, Math.min(height, mouseY));
      const freq = xToFreq(x, width);
      const loudnessDb = yToDb(y, height);

      ctx.save();
      ctx.setLineDash([5, 5]);
      ctx.lineWidth = 1;
      ctx.strokeStyle = activeCanvasTheme.crosshair;

      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
      ctx.setLineDash([]);

      const note = quantizeNote(freq);
      const label = `${note.name}   ${formatFreqValue(freq)}   ${loudnessDb.toFixed(1)} dB`;
      ctx.font = "12px Segoe UI";
      const textW = ctx.measureText(label).width;
      const padX = 10;
      const boxW = textW + padX * 2;
      const boxH = 24;
      let boxX = x + 12;
      let boxY = y - 32;

      if (boxX + boxW > width - 6) boxX = x - boxW - 12;
      if (boxX < 6) boxX = 6;
      if (boxY < 6) boxY = y + 10;
      if (boxY + boxH > height - 6) boxY = height - boxH - 6;

      const radius = 6;
      ctx.beginPath();
      ctx.moveTo(boxX + radius, boxY);
      ctx.lineTo(boxX + boxW - radius, boxY);
      ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + radius);
      ctx.lineTo(boxX + boxW, boxY + boxH - radius);
      ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - radius, boxY + boxH);
      ctx.lineTo(boxX + radius, boxY + boxH);
      ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - radius);
      ctx.lineTo(boxX, boxY + radius);
      ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
      ctx.closePath();
      ctx.fillStyle = activeCanvasTheme.readoutBg;
      ctx.fill();

      ctx.fillStyle = activeCanvasTheme.readoutText;
      ctx.textAlign = "left";
      ctx.textBaseline = "middle";
      ctx.fillText(label, boxX + padX, boxY + boxH * 0.5);
      ctx.restore();
    }

    function callNative(name, ...params) {
      if (!hasNativeBridge())
        return false;
      const resultId = Math.floor(Math.random() * 2147483647);
      const payload = { name, params, resultId };

      if (window.__JUCE__.backend && typeof window.__JUCE__.backend.emitEvent === "function") {
        const emitted = window.__JUCE__.backend.emitEvent("__juce__invoke", payload);
        if (emitted !== false)
          return true;
      }

      if (typeof window.__JUCE__.postMessage === "function") {
        window.__JUCE__.postMessage(JSON.stringify({ eventId: "__juce__invoke", payload }));
        return true;
      }

      return false;
    }

    function hasOpenSelectMenu(roots = customSelectRoots) {
      return roots.some((root) => root.classList.contains("open"));
    }

    function refreshToolbarVisibility() {
      const keepVisible = cornerHoverActive
          || !controlsPanel.classList.contains("is-hidden")
          || themePicker.classList.contains("open")
          || hasOpenSelectMenu(toolbarSelectRoots);
      leftToolbar.classList.toggle("is-visible", keepVisible);
    }

    function refreshPresetCenterVisibility() {
      if (!presetCenter)
        return;
      const keepVisible = presetHoverActive || (smoothSourceSel && smoothSourceSel.classList.contains("open"));
      presetCenter.classList.toggle("is-visible", !!keepVisible);
    }

    function updateCornerHover(clientX, clientY) {
      cornerHoverActive = clientX <= cornerRevealSizePx
          && clientY >= (window.innerHeight - cornerRevealSizePx);
      refreshToolbarVisibility();
    }

    function updatePresetHover(clientX, clientY) {
      const centerX = window.innerWidth * 0.5;
      const dx = Math.abs(clientX - centerX);
      const withinX = dx <= (presetRevealWidthPx * 0.5);
      const withinY = clientY >= (window.innerHeight - presetRevealHeightPx);
      presetHoverActive = withinX && withinY;
      refreshPresetCenterVisibility();
    }

    function updateThemeChoiceState() {
      for (const button of themeChoiceButtons) {
        const key = button.dataset.theme;
        button.classList.toggle("is-active", key === state.theme);
      }
    }

    function applyTheme(key) {
      const theme = themes[key];
      if (!theme) return;

      state.theme = key;
      activeCanvasTheme = theme.canvas;

      const rootStyle = document.documentElement.style;
      for (const [name, value] of Object.entries(theme.css))
        rootStyle.setProperty(name, value);

      themeToggleBtn.style.setProperty("--swatch-color", theme.swatch);
      updateThemeChoiceState();
    }

    function closeThemePicker() {
      themePicker.classList.remove("open");
      themeToggleBtn.classList.add("is-off");
      refreshToolbarVisibility();
    }

    function closeAllSelectMenus() {
      for (const root of customSelectRoots) {
        root.classList.remove("open");
        const trigger = root.querySelector(".select-trigger");
        if (trigger) trigger.setAttribute("aria-expanded", "false");
      }
      refreshToolbarVisibility();
      refreshPresetCenterVisibility();
    }

    function initializeCustomSelect(root, initialValue, onChange) {
      const trigger = root.querySelector(".select-trigger");
      const options = Array.from(root.querySelectorAll(".select-option"));
      if (!trigger || options.length === 0) return;

      const applySelection = (value, notify) => {
        let active = options.find((option) => option.dataset.value === value);
        if (!active) active = options[0];

        for (const option of options)
          option.classList.toggle("is-active", option === active);

        trigger.textContent = active.textContent.trim();
        root.dataset.value = active.dataset.value;
        if (notify) onChange(active.dataset.value);
      };

      applySelection(initialValue, false);

      trigger.addEventListener("click", (event) => {
        event.stopPropagation();
        const alreadyOpen = root.classList.contains("open");
        closeAllSelectMenus();
        if (!alreadyOpen) {
          root.classList.add("open");
          trigger.setAttribute("aria-expanded", "true");
        }
      });

      for (const option of options) {
        option.addEventListener("click", (event) => {
          event.stopPropagation();
          applySelection(option.dataset.value, true);
          closeAllSelectMenus();
        });
      }
    }

    function hideTooltip() {
      uiTooltip.classList.add("is-hidden");
    }

    function positionTooltip(clientX, clientY) {
      const margin = 8;
      const rect = uiTooltip.getBoundingClientRect();
      let left = clientX + 12;
      let top = clientY - rect.height - 10;

      if (left + rect.width > window.innerWidth - margin)
        left = window.innerWidth - rect.width - margin;
      if (left < margin)
        left = margin;

      if (top < margin)
        top = clientY + 14;

      uiTooltip.style.left = `${left}px`;
      uiTooltip.style.top = `${top}px`;
    }

    function bindTooltips() {
      const tooltipTargets = Array.from(document.querySelectorAll("[data-tooltip]"));
      for (const target of tooltipTargets) {
        target.addEventListener("mouseenter", (event) => {
          const text = target.dataset.tooltip;
          if (!text) return;
          uiTooltip.textContent = text;
          uiTooltip.classList.remove("is-hidden");
          positionTooltip(event.clientX, event.clientY);
        });

        target.addEventListener("mousemove", (event) => {
          if (!uiTooltip.classList.contains("is-hidden"))
            positionTooltip(event.clientX, event.clientY);
        });

        target.addEventListener("mouseleave", () => {
          hideTooltip();
        });
      }
    }

    function refreshOscLengthButton() {
      oscLengthBtn.textContent = state.oscLengthMode === 0 ? "1/4" : "1B";
      oscLengthBtn.classList.toggle("is-hidden", !state.oscilloscopeOn);
    }

    function drawFrame() {
      try {
        ensureBuiltInPresetActive();

        const rect = ensureCanvasSize();
        const w = rect.width;
        const h = rect.height;

        const bg = ctx.createLinearGradient(0, 0, 0, h);
        bg.addColorStop(0, activeCanvasTheme.bgTop);
        bg.addColorStop(1, activeCanvasTheme.bgBottom);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, w, h);

        drawGrid(w, h);
        drawSpectrum(w, h);
        drawSmoothPreset(w, h);
        drawOscilloscope(w, h);
        drawCrosshair(w, h);
      } catch (error) {
        reportUiError("draw", error);
      } finally {
        requestAnimationFrame(drawFrame);
      }
    }

    initializeCustomSelect(resolutionSel, state.resolution, (value) => {
      state.resolution = value;
      rebuildShapedTarget();
    });

    initializeCustomSelect(speedSel, state.speed, (value) => {
      state.speed = value;
    });

    initializeCustomSelect(tiltSel, String(state.tiltDb), (value) => {
      const tiltValue = Number(value);
      state.tiltDb = Number.isFinite(tiltValue) ? tiltValue : 5.0;
      rebuildShapedTarget();
    });

    initializeCustomSelect(smoothSourceSel, state.smoothSource, (value) => {
      state.smoothSource = value;
      if (value === "folder") {
        builtInPresetLocked = false;
        activeBuiltInPresetKey = "";
        setPresetStatus("Folder scan mode");
      } else {
        loadBuiltInSmoothTarget(value);
      }
    });

    initializeOverlayKnobs();

    themeToggleBtn.addEventListener("click", (event) => {
      event.stopPropagation();
      const willOpen = !themePicker.classList.contains("open");
      closeAllSelectMenus();
      if (willOpen) {
        themePicker.classList.add("open");
        themeToggleBtn.classList.remove("is-off");
        refreshToolbarVisibility();
      }
      else {
        closeThemePicker();
      }
    });

    for (const button of themeChoiceButtons) {
      button.addEventListener("click", (event) => {
        event.stopPropagation();
        if (button.classList.contains("is-disabled"))
          return;

        const key = button.dataset.theme;
        if (key) applyTheme(key);
        closeThemePicker();
      });
    }

    if (smoothPresetBtn) {
      smoothPresetBtn.addEventListener("click", () => {
        if (smoothPresetScanInProgress)
          return;

        if (getSelectedSmoothSource() !== "folder") {
          setPresetStatus("Built-in preset is already active. Switch source to Folder Scan to build a new one.");
          return;
        }

        setSmoothScanBusy(true);
        setPresetStatus("Scanning folder...");
        const started = callNative("buildSmoothPresetFromFolder");
        if (!started) {
          setSmoothScanBusy(false);
          setPresetStatus(`Native scan is unavailable (${nativeBridgeStatus()}).`);
        }
      });
    }

    menuToggle.addEventListener("click", () => {
      const show = controlsPanel.classList.contains("is-hidden");
      controlsPanel.classList.toggle("is-hidden", !show);
      menuToggle.classList.toggle("open", show);
      menuToggle.classList.toggle("is-off", !show);
      if (!show) closeAllSelectMenus();
      refreshToolbarVisibility();
    });

    document.addEventListener("pointerdown", (event) => {
      if (!event.target.closest(".control-select"))
        closeAllSelectMenus();
      if (!event.target.closest(".theme-picker"))
        closeThemePicker();
    });

    document.addEventListener("keydown", (event) => {
      if (event.key === "Escape") {
        closeAllSelectMenus();
        closeThemePicker();
        hideTooltip();
      }
    });

    window.addEventListener("mousemove", (event) => {
      updateCornerHover(event.clientX, event.clientY);
      updatePresetHover(event.clientX, event.clientY);
    });

    fullscreenBtn.addEventListener("click", () => {
      state.fullscreenOn = !state.fullscreenOn;
      fullscreenBtn.classList.toggle("is-off", !state.fullscreenOn);
      callNative("toggleFullscreen");
    });

    oscToggleBtn.addEventListener("click", () => {
      state.oscilloscopeOn = !state.oscilloscopeOn;
      oscToggleBtn.classList.toggle("is-off", !state.oscilloscopeOn);
      refreshOscLengthButton();
    });

    oscLengthBtn.addEventListener("click", () => {
      state.oscLengthMode = state.oscLengthMode === 0 ? 1 : 0;
      refreshOscLengthButton();
      callNative("setOscilloscopeLengthMode", state.oscLengthMode);
    });

    canvas.addEventListener("mouseenter", () => { mouseInside = true; });
    canvas.addEventListener("mouseleave", () => { mouseInside = false; });
    canvas.addEventListener("mousemove", (event) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = event.clientX - rect.left;
      mouseY = event.clientY - rect.top;
    });

    window.updateSpectrum = function (bins, sr, osc, rms, lufs, referenceBins, hasReference, referenceRevision) {
      try {
        if (Array.isArray(bins)) {
          const n = Math.min(BINS, bins.length);
          for (let i = 0; i < n; i++) {
            const v = Number(bins[i]);
            rawTarget[i] = Number.isFinite(v) ? Math.max(0, Math.min(1, v)) : 0;
          }
          rebuildShapedTarget();
        }

        if (Array.isArray(osc)) {
          const n = Math.min(BINS, osc.length);
          for (let i = 0; i < n; i++) {
            const v = Number(osc[i]);
            oscTarget[i] = Number.isFinite(v) ? Math.max(-1, Math.min(1, v)) : 0;
          }
          for (let i = n; i < BINS; i++) {
            oscTarget[i] = 0;
          }
        }

        if (typeof sr === "number" && Number.isFinite(sr) && sr > 1000) {
          sampleRate = sr;
        }

        if (typeof referenceRevision === "number" && Number.isFinite(referenceRevision)) {
          const selectedSource = getSelectedSmoothSource();
          if (selectedSource !== "folder")
            return;

          const revision = Math.max(0, Math.floor(referenceRevision));
          if (revision !== lastReferenceRevisionSeen) {
            lastReferenceRevisionSeen = revision;

            let values = [];
            if (Array.isArray(referenceBins)) {
              values = referenceBins;
            } else if (referenceBins && typeof referenceBins.length === "number") {
              values = Array.from(referenceBins);
            }

            const hasUsableReference = values.length > 0 && (revision > 0 || !!hasReference);
            if (hasUsableReference) {
              builtInPresetLocked = false;
              activeBuiltInPresetKey = "";
              applySmoothPreset(values, !!hasReference || revision > 0);
            } else if (revision === 0 && selectedSource === "folder") {
              applySmoothPreset([], false);
            }
          }
        }
      } catch (error) {
        reportUiError("updateSpectrum", error);
      }
    };

    window.setSmoothPreset = function (bins, hasPreset) {
      applySmoothPreset(bins, hasPreset);
    };

    window.onSmoothPresetScanFinished = function (success, message, bins, hasPreset, referenceRevision) {
      if (getSelectedSmoothSource() === "folder" && success)
      {
        builtInPresetLocked = false;
        activeBuiltInPresetKey = "";
      }

      const gotBinsArray = Array.isArray(bins) || (bins && typeof bins.length === "number");
      if (gotBinsArray) {
        applySmoothPreset(bins, !!hasPreset);
      }

      if (typeof referenceRevision === "number" && Number.isFinite(referenceRevision)) {
        const revision = Math.max(0, Math.floor(referenceRevision));
        if (revision > lastReferenceRevisionSeen)
          lastReferenceRevisionSeen = revision;
      }

      setSmoothScanBusy(false);
      if (!success) {
        const text = (typeof message === "string" && message.length > 0)
          ? message
          : "Scan failed.";
        setPresetStatus(text);
      }
      else if (typeof message === "string" && message.length > 0) {
        window.setTimeout(() => {
          setPresetStatus(
            `${message}${hasSmoothPreset ? " - overlay on" : " - no overlay data"}`
            + ` (rev:${lastReferenceRevisionSeen}, bins:${lastReferenceBinsReceived}, flag:${lastReferenceHasFlag ? "1" : "0"})`
          );
        }, 140);
      }
    };

    window.addEventListener("resize", resizeCanvas);
    window.addEventListener("blur", () => {
      cornerHoverActive = false;
      presetHoverActive = false;
      closeAllSelectMenus();
      closeThemePicker();
      hideTooltip();
      refreshPresetCenterVisibility();
    });
    initializeJuceBackendBridge();
    ensureCanvasSize();
    applyTheme(state.theme);
    closeThemePicker();
    bindTooltips();
    setSmoothScanBusy(false);
    setPresetStatus("No smooth preset");
    refreshOscLengthButton();
    callNative("setOscilloscopeLengthMode", state.oscLengthMode);
    rebuildShapedTarget();
    refreshPresetCenterVisibility();
    requestAnimationFrame(drawFrame);
  </script>
</body>
</html>
