<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Sample Player - Simple Knob UI</title>
  <style>
    :root {
      --bg-a: #2b2d32;
      --bg-b: #1e2024;
      --chrome-surface: linear-gradient(145deg, rgba(30, 32, 37, 0.96), rgba(24, 26, 30, 0.94));
      --panel: rgba(34, 36, 41, 0.9);
      --line: rgba(151, 156, 165, 0.3);
      --text: #e5e7ea;
      --text-dim: #a7adb8;
      --mint: #79a9a1;
      --blue: #a9b4c0;
      --warn: #d0a87a;
      --danger: #c7838b;
      --radius: 14px;
      --player-swatch-rgb: 38, 40, 46;
      --player-topbar-rgb: 38, 40, 46;
      --player-line-rgb: 140, 146, 156;
      --player-bright-rgb: 218, 222, 229;
      --player-press-glow-rgb: 218, 222, 229;
      --player-wheel-rgb: 236, 239, 244;
      --player-wheel-rgb-dark: 214, 218, 224;
      --player-key-tint-alpha-top: 0;
      --player-key-tint-alpha-bottom: 0;
      --player-key-press-tint-alpha-top: 0;
      --player-key-press-tint-alpha-bottom: 0;
      --player-key-press-black-alpha-top: 0;
      --player-key-press-black-alpha-bottom: 0;
    }

    * {
      box-sizing: border-box;
      user-select: none;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      min-height: 100%;
      font-family: "Avenir Next", "Segoe UI", sans-serif;
      color: var(--text);
      background:
        radial-gradient(900px 560px at 8% 6%, rgba(255, 255, 255, 0.08), transparent 62%),
        radial-gradient(880px 660px at 90% 86%, rgba(191, 197, 207, 0.08), transparent 62%),
        linear-gradient(145deg, var(--bg-a), var(--bg-b));
      overflow: hidden;
    }

    body {
      padding: 0;
      display: block;
    }

    .instrument {
      width: 100%;
      height: 100%;
      min-height: 100%;
      display: flex;
      flex-direction: column;
      border: 1px solid rgba(140, 146, 156, 0.2);
      border-radius: 8px;
      background: var(--chrome-surface);
      box-shadow: 0 20px 52px rgba(0, 0, 0, 0.34);
      overflow: hidden;
      backdrop-filter: blur(6px);
    }

    .btn-row {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      overflow-x: auto;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    .btn-row::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }

    button,
    .file-btn {
      border: 1px solid var(--line);
      border-radius: 10px;
      background: rgba(38, 40, 46, 0.96);
      color: var(--text);
      font: inherit;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      padding: 8px 11px;
      cursor: pointer;
    }

    button:not(.player-key):hover,
    .file-btn:hover {
      border-color: rgba(140, 146, 156, 0.5);
      background: rgba(55, 58, 66, 0.94);
    }

    .primary {
      border-color: rgba(170, 176, 186, 0.56);
      background: linear-gradient(180deg, rgba(168, 174, 184, 0.24), rgba(42, 45, 52, 0.95));
    }

    .tabs {
      display: flex;
      align-items: center;
      gap: 3px;
      padding: 7px 10px;
      border-bottom: 1px solid rgba(140, 146, 156, 0.28);
      background: rgba(8, 11, 17, 0.08);
    }

    .tabs.player-topbar-swatch {
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-topbar-rgb), 0.92),
          rgba(var(--player-topbar-rgb), 0.76)
        );
    }

    .tabs.player-topbar-swatch .tab-btn[data-tab="player"] {
      color: rgba(var(--player-line-rgb), 0.96);
    }

    .tabs.player-topbar-swatch .tab-btn:not(.active) {
      border-color: rgba(var(--player-line-rgb), 0.34);
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-topbar-rgb), 0.94),
          rgba(var(--player-topbar-rgb), 0.8)
        );
      color: rgba(var(--player-line-rgb), 0.82);
    }

    .tab-btn {
      border: 1px solid rgba(140, 146, 156, 0.28);
      border-radius: 10px;
      background: rgba(38, 40, 46, 0.96);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      padding: 7px 12px;
    }

    .tab-btn.icon-tab {
      min-width: 40px;
      padding: 6px 8px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
    }

    .tab-btn.icon-tab svg {
      width: 18px;
      height: 18px;
      display: block;
      fill: currentColor;
      opacity: 0.5;
      transition: opacity 120ms ease;
    }

    .tab-btn.icon-tab.active svg {
      opacity: 0.95;
    }

    .tab-btn.active {
      border-color: rgba(140, 146, 156, 0.44);
      background: linear-gradient(180deg, rgba(168, 174, 184, 0.24), rgba(42, 45, 52, 0.95));
    }

    .tab-btn[data-tab="player"].active {
      border-color: rgba(140, 146, 156, 0.58);
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-swatch-rgb), 0.98),
          rgba(var(--player-swatch-rgb), 0.68)
        );
    }

    .tabs.player-topbar-swatch .tab-btn[data-tab="player"].active {
      color: rgba(var(--player-line-rgb), 0.96);
      border-color: rgba(var(--player-line-rgb), 0.96);
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-topbar-rgb), 0.94),
          rgba(var(--player-topbar-rgb), 0.8)
        );
    }

    .top-right-controls {
      margin-left: auto;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .top-right-controls .player-author-display {
      display: none;
      flex: 1 1 auto;
      min-width: 0;
      max-width: 280px;
      justify-content: flex-end;
      align-items: center;
      font-size: 12px;
      letter-spacing: 0.03em;
      line-height: 1;
      color: rgba(140, 146, 156, 0.58);
      text-align: right;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      pointer-events: none;
    }

    .top-right-controls .player-author-display.visible {
      display: inline-flex;
    }

    .tabs.player-topbar-swatch .top-right-controls .player-author-display {
      color: rgba(var(--player-line-rgb), 0.96);
    }

    .top-right-controls .knob {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      min-height: 22px;
    }

    .top-right-controls .knob .knob-face {
      margin: 0;
    }

    .panel {
      display: none;
      flex: 1 1 auto;
      min-height: 0;
      padding: 10px 12px 12px;
      background: transparent;
    }

    .panel.active {
      display: block;
      overflow: auto;
    }

    #panel-player {
      padding: 0;
      min-height: 0;
      overflow: hidden;
    }

    #panel-player.active {
      display: flex;
    }

    #panel-setup {
      padding-bottom: 0;
    }

    .player-stage {
      --player-kb-height: 87px;
      --player-white-key-width: 23px;
      --player-black-key-height: 66%;
      min-height: 560px;
      flex: 1 1 auto;
      height: 100%;
      border: 0;
      border-radius: 0;
      position: relative;
      overflow: hidden;
      background: var(--player-wallpaper, var(--chrome-surface));
      background-size: cover;
      background-position: var(--player-wallpaper-position, center);
    }

    .player-logo-zone {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      height: 473px;
      z-index: 5;
      pointer-events: none;
      overflow: hidden;
    }

    .player-particles {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: var(--player-kb-height);
      z-index: 4;
      pointer-events: none;
      opacity: 0.96;
    }

    .player-god-rays {
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      bottom: var(--player-kb-height);
      z-index: 3;
      pointer-events: none;
      overflow: hidden;
      opacity: 0;
      transition: opacity 300ms ease;
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-bright-rgb), 0.07) 0%,
          rgba(var(--player-bright-rgb), 0.04) 20%,
          rgba(var(--player-bright-rgb), 0) 76%
        );
      will-change: opacity;
    }

    .player-stage.has-wallpaper .player-god-rays {
      opacity: 0.82;
    }

    .player-stage.god-rays-disabled .player-god-rays {
      opacity: 0 !important;
    }

    .player-god-rays::before,
    .player-god-rays::after {
      content: "";
      position: absolute;
      left: -22%;
      right: -22%;
      top: -26%;
      bottom: 14%;
      pointer-events: none;
      transform-origin: 50% -8%;
    }

    .player-god-rays::before {
      background:
        linear-gradient(
          106deg,
          rgba(var(--player-bright-rgb), 0) 0%,
          rgba(var(--player-bright-rgb), 0) 13.2%,
          rgba(var(--player-bright-rgb), 0.74) 14%,
          rgba(var(--player-bright-rgb), 0.22) 14.8%,
          rgba(var(--player-bright-rgb), 0) 17.2%,
          rgba(var(--player-bright-rgb), 0) 34.6%,
          rgba(var(--player-bright-rgb), 0.56) 35.9%,
          rgba(var(--player-bright-rgb), 0.18) 36.8%,
          rgba(var(--player-bright-rgb), 0) 39.4%,
          rgba(var(--player-bright-rgb), 0) 62.2%,
          rgba(var(--player-bright-rgb), 0.7) 63.7%,
          rgba(var(--player-bright-rgb), 0.2) 64.7%,
          rgba(var(--player-bright-rgb), 0) 67.8%,
          rgba(var(--player-bright-rgb), 0) 100%
        );
      filter: blur(9px);
      opacity: 0.72;
      transform: translateX(-6%) translateY(-4%) rotate(-4deg) scale(1.04);
      animation: godRaysDriftA 18s ease-in-out infinite alternate;
      animation-delay: -9s;
    }

    .player-god-rays::after {
      background:
        linear-gradient(
          78deg,
          rgba(var(--player-bright-rgb), 0) 0%,
          rgba(var(--player-bright-rgb), 0) 21.8%,
          rgba(var(--player-bright-rgb), 0.62) 22.7%,
          rgba(var(--player-bright-rgb), 0.24) 23.5%,
          rgba(var(--player-bright-rgb), 0) 25.4%,
          rgba(var(--player-bright-rgb), 0) 48.5%,
          rgba(var(--player-bright-rgb), 0.52) 49.4%,
          rgba(var(--player-bright-rgb), 0.2) 50.1%,
          rgba(var(--player-bright-rgb), 0) 52.5%,
          rgba(var(--player-bright-rgb), 0) 76.6%,
          rgba(var(--player-bright-rgb), 0.68) 77.9%,
          rgba(var(--player-bright-rgb), 0.22) 78.8%,
          rgba(var(--player-bright-rgb), 0) 81.4%,
          rgba(var(--player-bright-rgb), 0) 100%
        );
      filter: blur(11px);
      opacity: 0.58;
      transform: translateX(8%) translateY(-2%) rotate(5deg) scale(1.03);
      animation: godRaysDriftB 21s ease-in-out infinite alternate;
      animation-delay: -12s;
    }

    @keyframes godRaysDriftA {
      0% {
        transform: translateX(-10%) translateY(-4%) rotate(-4deg) scale(1.18);
      }
      100% {
        transform: translateX(10%) translateY(1%) rotate(-1deg) scale(1.24);
      }
    }

    @keyframes godRaysDriftB {
      0% {
        transform: translateX(12%) translateY(-2%) rotate(5deg) scale(1.1);
      }
      100% {
        transform: translateX(-8%) translateY(2%) rotate(2deg) scale(1.2);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      .player-god-rays::before,
      .player-god-rays::after {
        animation: none;
      }
    }

    .player-logo {
      position: absolute;
      left: var(--player-logo-left, 12px);
      right: var(--player-logo-right, auto);
      top: var(--player-logo-top, 12px);
      bottom: var(--player-logo-bottom, auto);
      transform: var(--player-logo-transform, none);
      z-index: 1;
      max-width: min(36%, 320px);
      max-height: min(86px, calc(100% - 24px));
      pointer-events: none;
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
    }

    .player-logo.hidden {
      display: none;
    }

    .player-logo-img {
      display: block;
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      filter: drop-shadow(0 3px 8px rgba(0, 0, 0, 0.42));
    }

    .player-stage::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: var(--player-kb-height);
      height: 100px;
      z-index: 2;
      pointer-events: none;
      background: linear-gradient(0deg, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0));
    }

    .player-controls {
      position: absolute;
      right: 8px;
      bottom: calc(var(--player-kb-height) + 8px);
      display: flex;
      flex-wrap: nowrap;
      gap: 4px;
      padding: 7px 6px;
      border: 1px solid rgba(var(--player-bright-rgb), 0.22);
      border-radius: 6px;
      background: rgba(10, 14, 22, 0.2);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.08),
        0 8px 16px rgba(0, 0, 0, 0.22);
      backdrop-filter: blur(8px) saturate(120%);
      -webkit-backdrop-filter: blur(8px) saturate(120%);
      z-index: 6;
      align-items: center;
      opacity: 0.2;
      transition: opacity 180ms ease;
    }

    .player-controls:hover {
      opacity: 1;
    }

    .player-controls.force-visible {
      opacity: 1;
    }

    .player-keyboard-strip {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: stretch;
      height: var(--player-kb-height);
      z-index: 4;
      border-top: 1px solid rgba(var(--player-line-rgb), 0.72);
      background:
        linear-gradient(
          180deg,
          rgba(6, 11, 18, 0.86),
          rgba(4, 8, 14, 0.98)
        );
      box-shadow:
        0 -12px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.04),
        inset 0 12px 22px rgba(0, 0, 0, 0.32);
    }

    .player-keyboard-strip::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 0;
      height: 20px;
      pointer-events: none;
      z-index: 3;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0.46), rgba(0, 0, 0, 0));
    }

    .player-wheel-bank {
      position: relative;
      z-index: 4;
      flex: 0 0 58px;
      width: 58px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 0 4px;
      border-right: 1px solid rgba(var(--player-line-rgb), 0.44);
      background:
        linear-gradient(
          180deg,
          rgba(12, 16, 24, 0.95),
          rgba(7, 11, 18, 0.98)
        );
      box-shadow:
        inset -1px 0 0 rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.04);
    }

    .player-wheel-block {
      flex: 1 1 0;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 0;
    }

    .player-wheel-slot {
      position: relative;
      width: 18px;
      height: 66px;
      border-radius: 4px;
      border: 1px solid rgba(137, 143, 153, 0.34);
      background:
        linear-gradient(180deg, rgba(255, 255, 255, 0.05), rgba(0, 0, 0, 0.26)),
        linear-gradient(180deg, rgba(8, 11, 16, 0.96), rgba(6, 8, 12, 0.98));
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.04),
        inset 0 -10px 14px rgba(0, 0, 0, 0.46);
      overflow: hidden;
      cursor: ns-resize;
      touch-action: none;
    }

    .player-wheel-slot.dragging {
      border-color: rgba(var(--player-bright-rgb), 0.52);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.06),
        inset 0 -10px 14px rgba(0, 0, 0, 0.46),
        0 0 0 1px rgba(var(--player-bright-rgb), 0.18);
    }

    .player-wheel-core {
      position: absolute;
      inset: 2px;
      border-radius: 3px;
      border: 1px solid rgba(0, 0, 0, 0.34);
      background:
        linear-gradient(
          90deg,
          rgba(0, 0, 0, 0.3),
          rgba(255, 255, 255, 0.13) 30%,
          rgba(255, 255, 255, 0.07) 54%,
          rgba(0, 0, 0, 0.22)
        ),
        linear-gradient(
          180deg,
          rgba(var(--player-wheel-rgb), 0.98),
          rgba(var(--player-wheel-rgb-dark), 0.98)
        );
      box-shadow:
        inset 0 8px 9px rgba(0, 0, 0, 0.2),
        inset 0 -10px 12px rgba(0, 0, 0, 0.28);
      overflow: hidden;
    }

    .player-wheel-tape {
      position: absolute;
      left: -1px;
      right: -1px;
      top: -58px;
      height: 178px;
      opacity: 0.28;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0.25) 0px,
          rgba(0, 0, 0, 0.25) 3px,
          rgba(255, 255, 255, 0.08) 3px,
          rgba(255, 255, 255, 0.08) 5px,
          rgba(0, 0, 0, 0) 12px,
          rgba(0, 0, 0, 0) 16px
        );
      transform: translateY(0);
      will-change: transform;
      pointer-events: none;
    }

    .player-wheel-ridges {
      position: absolute;
      inset: 0;
      opacity: 0.6;
      pointer-events: none;
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(0, 0, 0, 0.2) 0px,
          rgba(0, 0, 0, 0.2) 2px,
          rgba(255, 255, 255, 0.09) 2px,
          rgba(255, 255, 255, 0.09) 4px,
          rgba(0, 0, 0, 0) 8px,
          rgba(0, 0, 0, 0) 12px
        );
    }

    .player-wheel-marker {
      position: absolute;
      left: 2px;
      right: 2px;
      top: 50%;
      height: 1px;
      transform: translateY(-50%);
      border-radius: 1px;
      background: rgba(var(--player-line-rgb), 0.4);
      pointer-events: none;
    }

    .player-wheel-slot.pitch .player-wheel-marker {
      background: rgba(var(--player-bright-rgb), 0.62);
    }

    .player-keyboard-viewport {
      position: relative;
      z-index: 2;
      flex: 1 1 auto;
      min-width: 0;
      width: auto;
      height: 100%;
      overflow-x: hidden;
      overflow-y: hidden;
      scrollbar-width: none;
    }

    .player-keyboard-viewport::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }

    .player-keyboard-viewport::-webkit-scrollbar-track {
      background: rgba(8, 12, 18, 0.24);
    }

    .player-keyboard-viewport::-webkit-scrollbar-thumb {
      background: rgba(140, 146, 156, 0.3);
      border-radius: 4px;
    }

    .player-keyboard {
      position: relative;
      height: 100%;
      width: 100%;
      min-width: 0;
    }

    .player-keys-whites {
      position: relative;
      z-index: 1;
      display: flex;
      height: 100%;
      align-items: stretch;
    }

    .player-keys-blacks {
      position: absolute;
      inset: 0;
      z-index: 2;
      pointer-events: none;
    }

    .player-key {
      appearance: none;
      border: 0;
      margin: 0;
      padding: 0;
      cursor: pointer;
      font: inherit;
      line-height: 1;
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
      transition:
        transform 90ms ease-out,
        background 90ms ease,
        box-shadow 90ms ease,
        border-color 90ms ease,
        filter 90ms ease;
      will-change: transform;
    }

    .player-key::before {
      content: "";
      position: absolute;
      inset: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 90ms ease;
    }

    .player-key-white {
      position: relative;
      flex: 0 0 var(--player-white-key-width);
      width: var(--player-white-key-width);
      min-width: var(--player-white-key-width);
      height: 100%;
      border-radius: 0 0 3px 3px;
      border-right: 1px solid rgba(30, 39, 55, 0.6);
      border-top: 1px solid rgba(212, 218, 228, 0.86);
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-swatch-rgb), var(--player-key-tint-alpha-top)),
          rgba(var(--player-swatch-rgb), var(--player-key-tint-alpha-bottom))
        ),
        linear-gradient(180deg, #d7dbe1, #bcc2ca);
      box-shadow:
        inset 0 1px 0 rgba(238, 242, 248, 0.72),
        inset 0 -10px 18px rgba(0, 0, 0, 0.12);
      transform: translateY(0);
    }

    .player-key-white:first-child {
      border-left: 1px solid rgba(20, 28, 42, 0.55);
    }

    .player-key-white::after {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      height: 15px;
      background: linear-gradient(180deg, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.11));
      pointer-events: none;
    }

    .player-key-black {
      position: absolute;
      top: 0;
      height: var(--player-black-key-height);
      border-radius: 0 0 3px 3px;
      border: 1px solid rgba(176, 184, 196, 0.14);
      background: linear-gradient(180deg, #2e333a, #1a1f26);
      box-shadow:
        0 10px 18px rgba(0, 0, 0, 0.46),
        inset 0 1px 0 rgba(255, 255, 255, 0.06),
        inset 0 -8px 12px rgba(0, 0, 0, 0.58);
      transform: translate(-50%, 0);
      transform-origin: 50% 0;
      pointer-events: auto;
      opacity: 1;
    }

    .player-key-label {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 6px;
      text-align: center;
      font-size: 9px;
      letter-spacing: 0.03em;
      text-transform: uppercase;
      color: rgba(22, 28, 36, 0.86);
      pointer-events: none;
    }

    .player-key-white.c-note .player-key-label {
      color: rgba(var(--player-line-rgb), 0.9);
      text-shadow: 0 1px 0 rgba(0, 0, 0, 0.18);
    }

    .player-key-white.c-note.has-sample .player-key-label {
      color: rgba(var(--player-topbar-rgb), 0.96);
      text-shadow: none;
    }

    .player-key-white.c-note.has-sample {
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-swatch-rgb), calc(var(--player-key-tint-alpha-top) + 0.1)),
          rgba(var(--player-swatch-rgb), calc(var(--player-key-tint-alpha-bottom) + 0.14))
        ),
        linear-gradient(180deg, #cfd4dc, #aeb6c1);
    }

    .player-key-black .player-key-label {
      bottom: 7px;
      color: rgba(228, 238, 252, 0.7);
    }

    .player-key-white.no-sample {
      border-right-color: rgba(21, 26, 35, 0.75);
      border-top-color: rgba(54, 60, 70, 0.89);
      background: linear-gradient(180deg, #454b54, #2c3138);
      box-shadow:
        inset 0 -10px 18px rgba(0, 0, 0, 0.24);
    }

    .player-key-white.no-sample::after {
      background: linear-gradient(180deg, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.2));
    }

    .player-key-black.no-sample {
      border-color: rgba(74, 80, 90, 0.22);
      background: linear-gradient(180deg, #232830, #0e1217);
      box-shadow:
        0 8px 14px rgba(0, 0, 0, 0.44),
        inset 0 -8px 12px rgba(0, 0, 0, 0.52);
      opacity: 1;
    }

    .player-key-white.no-sample {
      opacity: 0.5;
    }

    .player-key.no-sample .player-key-label {
      color: rgba(230, 235, 244, 0.78);
    }

    .player-key-white.is-down {
      transform: translateY(2px);
      filter: brightness(0.985);
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-swatch-rgb), var(--player-key-press-tint-alpha-top)),
          rgba(var(--player-swatch-rgb), var(--player-key-press-tint-alpha-bottom))
        ),
        linear-gradient(180deg, #d6d8dd, #b8bdc6);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.74),
        inset 0 -6px 10px rgba(0, 0, 0, 0.1),
        0 0 0 1px rgba(205, 210, 220, 0.18) inset,
        0 0 8px rgba(var(--player-press-glow-rgb), 0.48),
        0 0 16px rgba(var(--player-press-glow-rgb), 0.3);
    }

    .player-key-white.is-down::before {
      opacity: 0.16;
      background:
        radial-gradient(circle at 50% 70%, rgba(236, 240, 245, 0.22), rgba(236, 240, 245, 0) 68%),
        linear-gradient(180deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0));
    }

    .player-key-black.is-down {
      transform: translate(-50%, 1px) scale(0.97, 0.98);
      filter: brightness(0.93) contrast(1.06);
      background:
        linear-gradient(
          180deg,
          rgba(var(--player-swatch-rgb), var(--player-key-press-black-alpha-top)),
          rgba(var(--player-swatch-rgb), var(--player-key-press-black-alpha-bottom))
        ),
        linear-gradient(180deg, #30353d, #0f141b);
      border-color: rgba(191, 198, 209, 0.3);
      box-shadow:
        0 3px 5px rgba(0, 0, 0, 0.48),
        inset 0 1px 0 rgba(255, 255, 255, 0.03),
        inset 0 -10px 14px rgba(0, 0, 0, 0.66),
        0 0 0 1px rgba(201, 207, 218, 0.16),
        0 0 8px rgba(var(--player-press-glow-rgb), 0.42),
        0 0 16px rgba(var(--player-press-glow-rgb), 0.28);
    }

    .player-key-black.is-down::before {
      opacity: 0.2;
      background:
        radial-gradient(circle at 50% 62%, rgba(220, 228, 240, 0.26), rgba(220, 228, 240, 0) 70%),
        linear-gradient(180deg, rgba(214, 220, 231, 0.1), rgba(214, 220, 231, 0));
    }

    .player-key-white.no-sample.is-down {
      box-shadow:
        inset 0 1px 0 rgba(210, 216, 224, 0.24),
        inset 0 -8px 12px rgba(0, 0, 0, 0.22);
    }

    .player-key-black.no-sample.is-down {
      box-shadow:
        0 3px 5px rgba(0, 0, 0, 0.5),
        inset 0 1px 0 rgba(255, 255, 255, 0.02),
        inset 0 -10px 14px rgba(0, 0, 0, 0.7),
        0 0 0 1px rgba(170, 176, 186, 0.08);
    }

    .player-key:focus-visible {
      outline: 1px solid rgba(198, 204, 214, 0.82);
      outline-offset: -1px;
    }

    .player-divider {
      width: 1px;
      height: 26px;
      align-self: center;
      background: rgba(140, 146, 156, 0.4);
      margin: 0 2px;
    }

    .player-controls .knob {
      padding: 0;
      width: 56px;
    }

    .player-controls .knob .knob-face {
      margin: 0 auto;
    }

    .player-controls .knob-label {
      display: none;
    }

    .player-controls .knob-value {
      display: none;
    }

    .section {
      border: 0;
      border-radius: 0;
      background: transparent;
      padding: 0;
    }

    .section + .section {
      margin-top: 14px;
    }

    .section h2 {
      margin: 0 0 8px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-dim);
    }

    .section.collapsible > h2 {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      user-select: none;
      min-height: 22px;
      padding: 0 6px;
      border-radius: 4px;
      font-size: 10px;
      letter-spacing: 0.04em;
      line-height: 1;
      transition: background 120ms ease, color 120ms ease;
    }

    .section.collapsible:not(.collapsed) > h2 {
      background: rgba(255, 216, 92, 0.96);
      color: #2b2d32;
    }

    .section.collapsible:not(.collapsed) > h2::after {
      color: #2b2d32;
    }

    .section.collapsible > h2::after {
      content: "âˆ’";
      font-size: 10px;
      line-height: 1;
      color: var(--text-dim);
    }

    .section.collapsible.collapsed > h2::after {
      content: "+";
    }

    .section.collapsible.collapsed > .section-body {
      display: none;
    }

    .setup-layout,
    .auto-layout {
      display: grid;
      gap: 14px;
      grid-template-columns: 1.25fr 1fr;
    }

    #autoSamplerBody.auto-layout {
      grid-template-columns: 1fr;
    }

    .setup-wide {
      grid-column: 1 / -1;
    }

    .setup-map-wide {
      margin-left: -12px;
      margin-right: -12px;
    }

    .setup-map-wide h2 {
      padding: 0;
    }

    .setup-map-wide .map-shell {
      border-left: 0;
      border-right: 0;
      border-bottom: 0;
      border-radius: 0;
    }

    .simple-grid {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(4, minmax(72px, 1fr));
    }

    .knob {
      border: 0;
      border-radius: 0;
      background: transparent;
      padding: 2px;
      text-align: center;
      cursor: ns-resize;
    }

    .knob[data-tooltip] {
      position: relative;
    }

    .knob[data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 50%;
      bottom: calc(100% + 4px);
      transform: translateX(-50%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(140, 146, 156, 0.36);
      border-radius: 6px;
      background: rgba(10, 14, 21, 0.95);
      color: var(--text);
      font-size: 10px;
      letter-spacing: 0.04em;
      padding: 4px 6px;
      z-index: 20;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .knob[data-tooltip]:hover::after {
      opacity: 1;
      visibility: visible;
    }

    .player-empty {
      position: absolute;
      inset: 0 0 var(--player-kb-height) 0;
      display: grid;
      place-items: center;
      z-index: 5;
    }

    .player-empty.hidden {
      display: none;
    }

    .player-load-btn {
      width: 86px;
      height: 86px;
      border-radius: 50%;
      border: 1px solid rgba(var(--player-swatch-rgb), 0.75);
      background: transparent;
      color: rgba(236, 244, 255, 0.95);
      font-size: 56px;
      line-height: 1;
      text-transform: none;
      letter-spacing: 0;
      padding: 0;
      display: grid;
      place-items: center;
      cursor: pointer;
      opacity: 0.2;
      transform: scale(1);
      transition: opacity 180ms ease;
      animation: playerLoadBounceIn 210ms cubic-bezier(0.38, 0.02, 0.4, 1.15) both;
      will-change: transform, opacity;
    }

    .player-load-btn:hover,
    .player-load-btn:focus-visible {
      opacity: 1;
      animation: playerLoadBounceOut 240ms cubic-bezier(0.2, 0.8, 0.22, 1.2) both;
      background: transparent;
    }

    @keyframes playerLoadBounceOut {
      0% { transform: scale(1); }
      62% { transform: scale(1.18); }
      100% { transform: scale(1.12); }
    }

    @keyframes playerLoadBounceIn {
      0% { transform: scale(1.12); }
      58% { transform: scale(0.95); }
      100% { transform: scale(1); }
    }

    .player-stage .player-controls .knob-face {
      border-color: rgba(var(--player-bright-rgb), 0.72);
      background: rgba(10, 14, 22, 0.6);
    }

    .player-stage .player-controls .knob-pointer {
      background: rgba(var(--player-bright-rgb), 0.96);
    }

    .player-stage .player-controls .knob-label {
      color: rgba(var(--player-bright-rgb), 0.92);
    }

    .player-stage .player-controls .knob[data-tooltip]::after {
      border-color: rgba(var(--player-bright-rgb), 0.5);
      background: rgba(10, 14, 21, 0.95);
      color: rgba(var(--player-bright-rgb), 0.96);
    }

    .player-stage .player-divider {
      background: rgba(var(--player-swatch-rgb), 0.88);
    }

    .tabs.player-topbar-swatch .top-right-controls .knob-face {
      border-color: rgba(var(--player-bright-rgb), 0.72);
      background: rgba(10, 14, 22, 0.65);
    }

    .tabs.player-topbar-swatch .top-right-controls .knob-pointer {
      background: rgba(var(--player-bright-rgb), 0.96);
    }

    .tabs.player-topbar-swatch .top-right-controls .knob-label {
      color: rgba(var(--player-bright-rgb), 0.92);
    }

    .tabs.player-topbar-swatch .top-right-controls .knob[data-tooltip]::after {
      border-color: rgba(var(--player-bright-rgb), 0.54);
      color: rgba(var(--player-bright-rgb), 0.96);
    }

    .knob.tooltip-right::after {
      left: auto;
      right: 0;
      transform: none;
    }

    .knob.tooltip-left::after {
      left: 0;
      transform: none;
    }

    .top-right-controls .knob[data-tooltip]::after {
      top: calc(100% + 4px);
      bottom: auto;
    }

    .knob-face {
      width: 26px;
      height: 26px;
      margin: 0 auto 5px;
      border-radius: 50%;
      border: 1px solid rgba(172, 178, 188, 0.62);
      background: rgba(14, 19, 29, 0.75);
      position: relative;
      box-shadow: none;
    }

    .knob-pointer {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 1px;
      height: 9px;
      background: rgba(218, 222, 229, 0.92);
      transform-origin: 50% 100%;
      transform: translate(-50%, -100%) rotate(-135deg);
      border-radius: 1px;
      box-shadow: none;
    }

    .knob-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--text-dim);
      margin-bottom: 2px;
    }

    .knob-value {
      font-size: 10px;
      color: var(--text);
      min-height: 12px;
      font-family: "SFMono-Regular", Menlo, monospace;
    }

    .knob-mini {
      padding: 0 2px 4px;
    }

    .knob-mini .knob-face {
      width: 22px;
      height: 22px;
      margin-bottom: 3px;
    }

    .knob-mini .knob-pointer {
      height: 7px;
    }

    .knob-mini .knob-label {
      font-size: 8px;
      margin-bottom: 1px;
    }

    .knob-mini .knob-value {
      font-size: 9px;
      min-height: 10px;
    }

    .knob[data-param="gain"] .knob-value {
      display: none;
    }

    .knob[data-param="gain"] .knob-label {
      display: none;
    }

    .checkbox {
      display: flex;
      align-items: center;
      gap: 8px;
      border: 0;
      border-radius: 0;
      padding: 4px 0;
      background: transparent;
      color: var(--text);
      font-size: 12px;
    }

    input[type="checkbox"] {
      accent-color: var(--mint);
    }

    input[type="text"],
    select {
      width: 100%;
      border: 1px solid rgba(140, 146, 156, 0.22);
      border-radius: 8px;
      padding: 7px 8px;
      background: rgba(11, 16, 24, 0.68);
      color: var(--text);
      font: inherit;
      font-size: 12px;
    }

    .field label {
      display: block;
      margin-bottom: 5px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--text-dim);
    }

    .field.note-inline {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
    }

    .field.note-inline label {
      margin-bottom: 0;
    }

    .field.note-inline .note-input {
      width: 56px;
      min-width: 56px;
      text-align: center;
      text-transform: uppercase;
      padding: 6px 6px;
    }

    #autoStartField,
    #autoEndField {
      justify-content: flex-start;
    }

    .interval-stepper {
      display: inline-flex;
      align-items: center;
      gap: 0;
      min-height: 28px;
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 8px;
      background: rgba(11, 16, 24, 0.68);
      overflow: hidden;
    }

    .interval-stepper:focus-within {
      border-color: rgba(255, 216, 92, 0.72);
    }

    .interval-step-btn {
      width: 18px;
      min-width: 18px;
      height: 100%;
      padding: 0;
      border: 0;
      border-radius: 0;
      background: transparent;
      color: var(--text-dim);
      font-size: 11px;
      line-height: 1;
      display: grid;
      place-items: center;
      cursor: pointer;
    }

    .interval-stepper .note-input,
    .interval-stepper .interval-input {
      border: 0;
      border-radius: 0;
      background: transparent;
      width: 56px;
      min-width: 56px;
      text-align: center;
      padding: 6px 2px;
    }

    .interval-stepper .interval-input {
      text-transform: none;
    }

    .interval-stepper .note-input {
      text-transform: uppercase;
    }

    .field-grid {
      display: grid;
      gap: 10px;
      grid-template-columns: repeat(2, minmax(0, 1fr));
    }

    .auto-meta-grid {
      grid-template-columns: repeat(3, minmax(0, 1fr));
    }

    .auto-range-grid {
      grid-template-columns: repeat(5, minmax(0, 1fr));
    }

    .auto-timing-grid {
      grid-template-columns: repeat(4, minmax(0, 1fr));
      margin-bottom: 8px;
    }

    .auto-stack-grid {
      --auto-label-width: 116px;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .auto-stack-split {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 10px;
      align-items: start;
    }

    .auto-stack-grid > .field.note-inline,
    .auto-stack-grid > .field.auto-ms-field,
    .auto-stack-grid > .field.auto-loop-row {
      display: grid;
      grid-template-columns: var(--auto-label-width) auto;
      align-items: center;
      justify-content: flex-start;
      column-gap: 8px;
    }

    .auto-stack-grid > .field.note-inline label,
    .auto-stack-grid > .field.auto-ms-field label,
    .auto-stack-grid > .field.auto-loop-row .auto-loop-row-label {
      margin: 0;
      white-space: nowrap;
    }

    .auto-stack-grid > .field.auto-loop-row label.sample-velocity-toggle {
      display: grid;
      place-items: center;
      margin-bottom: 0;
    }

    .auto-stack-grid .interval-stepper,
    .auto-stack-grid .auto-loop-inline {
      justify-self: start;
    }

    .auto-sampler-columns {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 12px;
      align-items: start;
    }

    .auto-sampler-left,
    .auto-sampler-right {
      min-width: 0;
    }

    .auto-sampler-right {
      display: grid;
      gap: 10px;
      align-content: start;
    }

    .auto-ms-field {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 6px;
    }

    .auto-ms-field label {
      margin-bottom: 0;
    }

    .auto-ms-field .ms-input {
      width: 56px;
      min-width: 56px;
      max-width: 56px;
      text-align: center;
      padding: 6px 6px;
    }

    .auto-loop-inline {
      margin-left: 0;
      white-space: nowrap;
      min-height: 22px;
    }

    .auto-loop-options {
      margin-top: -2px;
      padding-top: 2px;
      display: grid;
      gap: 8px;
    }

    .auto-loop-options > .field {
      display: grid;
      grid-template-columns: var(--auto-label-width) auto;
      align-items: center;
      justify-content: flex-start;
      column-gap: 8px;
    }

    .auto-loop-options > .field > label {
      margin: 0;
      white-space: nowrap;
    }

    .auto-loop-options .sample-velocity-toggle {
      display: grid;
      place-items: center;
      margin-bottom: 0;
      justify-self: start;
    }

    .auto-stack-grid > .field.auto-pack-row-inline {
      padding-top: 2px;
    }

    .auto-stack-grid > .field.auto-pack-row-inline .auto-pack-as-wrap.auto-pack-as-row {
      display: flex;
      align-items: center;
      justify-content: flex-start;
      gap: 8px;
      min-height: 22px;
    }

    .auto-pack-row-label {
      margin: 0;
      width: var(--auto-label-width);
      min-width: var(--auto-label-width);
      line-height: 22px;
      position: relative;
      top: 1px;
      white-space: nowrap;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--text-dim);
    }

    .auto-pack-trigger {
      width: 22px;
      min-width: 22px;
      height: 22px;
      padding: 0;
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 4px;
      background: rgba(12, 17, 26, 0.8);
      color: var(--text-dim);
      font-size: 10px;
      line-height: 1;
      display: grid;
      place-items: center;
      justify-self: start;
      flex: 0 0 22px;
    }

    .auto-pack-trigger[aria-expanded="true"] {
      border-color: rgba(255, 216, 92, 0.72);
      background: rgba(28, 24, 13, 0.86);
      color: #ffdf7e;
    }

    .auto-stack-grid > .field.auto-pack-row-inline .auto-pack-as-menu {
      left: calc(var(--auto-label-width) + 8px);
      right: auto;
    }

    .auto-loop-value-wrap {
      display: inline-flex;
      align-items: center;
      justify-self: start;
      gap: 6px;
    }

    .auto-loop-value-wrap .ms-input {
      width: 56px;
      min-width: 56px;
      max-width: 56px;
      text-align: center;
      padding: 6px 6px;
    }

    .auto-loop-unit {
      color: var(--text-dim);
      font-size: 11px;
      letter-spacing: 0.04em;
      text-transform: lowercase;
    }

    .auto-loop-pack-row {
      margin-top: 8px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      flex-wrap: wrap;
    }

    .auto-pack-row {
      margin-top: 0;
      justify-content: flex-start;
    }

    .auto-pack-as-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
    }

    .auto-pack-as-menu {
      position: absolute;
      top: calc(100% + 6px);
      right: 0;
      z-index: 2000;
      width: 132px;
      min-width: 132px;
      padding: 4px;
      border: 1px solid rgba(140, 146, 156, 0.32);
      border-radius: 8px;
      background: rgba(10, 14, 21, 0.96);
      display: grid;
      gap: 2px;
    }

    .auto-pack-as-menu .sample-loop-tool-btn {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: flex-start;
      text-align: left;
    }

    .auto-preset-menu {
      width: 176px;
      min-width: 176px;
    }

    .auto-preset-save-btn {
      text-transform: uppercase;
      border: 0;
      background: transparent;
      padding-left: 4px;
      padding-right: 4px;
    }

    .auto-preset-create {
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      align-items: center;
      gap: 4px;
    }

    .auto-preset-name-input {
      width: 100%;
      min-width: 0;
      height: 22px;
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 4px;
      background: rgba(12, 17, 26, 0.86);
      color: var(--text);
      font-size: 10px;
      letter-spacing: 0.03em;
      padding: 0 6px;
    }

    .auto-preset-name-input::placeholder {
      color: var(--text-dim);
    }

    .auto-preset-confirm-btn {
      min-width: 42px;
      justify-content: center;
      padding: 0 8px;
      text-transform: uppercase;
    }

    .auto-preset-list {
      display: grid;
      gap: 2px;
    }

    .auto-preset-row {
      display: grid;
      grid-template-columns: minmax(0, 1fr) 22px;
      align-items: center;
      gap: 4px;
    }

    .auto-preset-item {
      text-transform: none;
      letter-spacing: 0.03em;
    }

    .auto-preset-row .auto-preset-item {
      width: 100%;
      min-width: 0;
    }

    .auto-preset-row .auto-preset-delete-btn {
      width: 22px;
      min-width: 22px;
      height: 22px;
      padding: 0;
      justify-content: center;
      text-transform: none;
      letter-spacing: 0;
    }

    .auto-preset-empty {
      min-height: 20px;
      display: flex;
      align-items: center;
      padding: 0 4px;
      font-size: 10px;
      letter-spacing: 0.03em;
      color: var(--text-dim);
      text-transform: none;
    }

    .auto-pack-check {
      position: relative;
      display: block;
      align-items: center;
      min-height: 22px;
      padding: 0 24px 0 2px;
      border-radius: 6px;
      cursor: pointer;
      user-select: none;
      color: var(--text);
      font-size: 11px;
      letter-spacing: 0.04em;
      text-transform: none;
    }

    .auto-pack-check.disabled {
      opacity: 0.44;
      cursor: default;
    }

    .auto-pack-check-text {
      display: block;
      line-height: 22px;
      min-width: 0;
      white-space: nowrap;
    }

    .auto-pack-check-input {
      position: absolute;
      opacity: 0;
      pointer-events: none;
    }

    .auto-pack-check-mark {
      position: absolute;
      right: 2px;
      top: 50%;
      transform: translateY(-50%);
      width: 14px;
      height: 14px;
      border: 1px solid rgba(140, 146, 156, 0.4);
      border-radius: 3px;
      display: grid;
      place-items: center;
      font-size: 10px;
      line-height: 1;
      color: rgba(255, 223, 126, 0);
      background: rgba(8, 12, 18, 0.75);
      transition: border-color 120ms ease, color 120ms ease, background 120ms ease;
    }

    .auto-pack-check-input:checked ~ .auto-pack-check-mark {
      border-color: rgba(255, 216, 92, 0.72);
      color: #ffdf7e;
      background: rgba(28, 24, 13, 0.86);
    }

    .auto-pack-export-btn {
      margin-top: 2px;
    }

    .setup-map-wide > h2.setup-map-toggle {
      margin: 0 12px 8px;
      padding: 0 6px;
    }

    .sample-velocity-toggle {
      width: 22px;
      height: 22px;
      padding: 0;
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 4px;
      background: rgba(12, 17, 26, 0.8);
      color: var(--text);
      display: grid;
      place-items: center;
      line-height: 1;
      cursor: pointer;
      user-select: none;
      position: relative;
    }

    .sample-velocity-toggle input {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
      margin: 0;
    }

    .sample-velocity-toggle-mark {
      font-size: 11px;
      font-weight: 700;
      color: rgba(255, 223, 126, 0);
      transition: color 120ms ease;
      pointer-events: none;
    }

    .sample-velocity-toggle input:checked + .sample-velocity-toggle-mark {
      color: #ffdf7e;
    }

    .sample-velocity-toggle input:focus-visible + .sample-velocity-toggle-mark {
      text-shadow: 0 0 6px rgba(255, 223, 126, 0.44);
    }

    .drop {
      border: 1px dashed rgba(140, 146, 156, 0.5);
      border-radius: 8px;
      min-height: 84px;
      display: grid;
      place-items: center;
      text-align: center;
      color: var(--text-dim);
      font-size: 12px;
      padding: 8px;
      background: rgba(11, 16, 25, 0.28);
    }

    .drop.drag {
      border-color: rgba(66, 217, 184, 0.68);
      background: rgba(16, 34, 35, 0.82);
      color: #d9fdf3;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .stat {
      border: 0;
      border-radius: 0;
      text-align: center;
      padding: 4px;
      background: transparent;
    }

    .stat strong {
      display: block;
      font-size: 18px;
      color: var(--blue);
      line-height: 1;
    }

    .stat span {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--text-dim);
    }

    .status {
      margin-top: 8px;
      border: 0;
      border-radius: 0;
      padding: 4px 0;
      font-size: 12px;
      background: transparent;
      color: var(--text-dim);
    }

    .status:empty {
      display: none;
    }

    .status.ok {
      color: var(--mint);
    }

    .status.warn {
      color: var(--warn);
    }

    .status.bad {
      color: var(--danger);
    }

    .log {
      border: 1px dashed rgba(140, 146, 156, 0.2);
      border-radius: 8px;
      background: rgba(9, 12, 19, 0.42);
      max-height: 260px;
      overflow: auto;
      font-family: "SFMono-Regular", Menlo, monospace;
      font-size: 11px;
      line-height: 1.45;
      padding: 7px;
      color: var(--text-dim);
      white-space: pre-wrap;
    }

    #importLog {
      max-height: min(56vh, 460px);
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      z-index: 90;
      background: rgba(5, 8, 14, 0.78);
      display: grid;
      place-items: center;
      padding: 18px;
    }

    .modal-window {
      width: min(860px, 100%);
      border: 1px solid rgba(140, 146, 156, 0.34);
      border-radius: 10px;
      background: linear-gradient(145deg, rgba(12, 18, 29, 0.98), rgba(20, 27, 40, 0.96));
      box-shadow: 0 22px 56px rgba(0, 0, 0, 0.42);
      overflow: hidden;
    }

    .modal-head {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(140, 146, 156, 0.22);
      padding: 8px 10px;
      background: rgba(10, 15, 24, 0.7);
    }

    .modal-title {
      margin: 0;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-dim);
      font-weight: 600;
    }

    .modal-close {
      min-width: 30px;
      padding-left: 0;
      padding-right: 0;
      text-transform: none;
      font-size: 14px;
      line-height: 1;
    }

    .modal-body {
      padding: 10px;
    }

    .render {
      border: 0;
      border-radius: 0;
      background: transparent;
      padding: 3px 0;
      font-size: 13px;
    }

    .computed-preview {
      text-align: center;
    }

    .computed-preview > h2 {
      justify-content: center;
    }

    .computed-preview .render {
      text-align: center;
    }

    .render strong {
      color: var(--blue);
      font-size: 20px;
      margin-right: 8px;
    }

    .render-time {
      font-size: 12px;
      color: var(--text-dim);
      padding-top: 0;
    }

    .render-time-value {
      color: var(--text);
      font-weight: 600;
    }

    .render-size {
      font-size: 12px;
      color: var(--text-dim);
      padding-top: 0;
    }

    .render-size-value {
      color: var(--text);
      font-weight: 600;
    }

    .render-size-format {
      color: var(--text-dim);
      font-size: 11px;
    }

    .start-sampling-btn {
      margin: 12px auto 0;
      width: 232px;
      max-width: 100%;
      height: 42px;
      padding: 0 16px;
      border-color: rgba(150, 58, 58, 0.86);
      background: linear-gradient(180deg, rgba(102, 22, 22, 0.98), rgba(72, 12, 12, 0.99));
      color: #fff0f0;
      font-size: 15px;
      letter-spacing: 0.07em;
      font-weight: 700;
    }

    .start-sampling-btn:hover {
      border-color: rgba(176, 76, 76, 0.88);
      background: linear-gradient(180deg, rgba(118, 28, 28, 0.98), rgba(84, 16, 16, 0.99));
    }

    .start-sampling-btn.is-recording {
      border-color: rgba(255, 120, 120, 0.95);
      background: linear-gradient(180deg, rgba(236, 36, 36, 0.98), rgba(186, 18, 18, 0.99));
      color: #fff8f8;
      box-shadow: 0 0 14px rgba(208, 34, 34, 0.38);
    }

    .start-sampling-btn.is-recording:hover {
      border-color: rgba(255, 160, 160, 0.98);
      background: linear-gradient(180deg, rgba(246, 52, 52, 0.98), rgba(198, 26, 26, 0.99));
    }

    .notes {
      border: 1px dashed rgba(140, 146, 156, 0.2);
      border-radius: 8px;
      min-height: 120px;
      background: rgba(8, 11, 17, 0.34);
      padding: 7px;
      font-family: "SFMono-Regular", Menlo, monospace;
      font-size: 12px;
      color: #c9f8ef;
      white-space: pre-wrap;
      line-height: 1.45;
    }

    .map-shell {
      --map-col-gap: 2px;
      border: 1px solid rgba(140, 146, 156, 0.24);
      border-radius: 8px;
      background: rgba(8, 11, 17, 0.36);
      overflow: hidden;
    }

    .keyswitch-map-toolbar {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      margin: 0 0 6px;
    }

    .keyswitch-map-toolbar > label {
      margin: 0;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--text-dim);
      white-space: nowrap;
    }

    .keyswitch-map-select {
      width: auto;
      min-width: 180px;
      max-width: 320px;
      border-radius: 6px;
      padding: 4px 8px;
      font-size: 11px;
      background: rgba(11, 16, 24, 0.82);
    }

    .keyswitch-map-key-wrap {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .keyswitch-map-key-wrap > label {
      margin: 0;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.07em;
      color: var(--text-dim);
      white-space: nowrap;
    }

    .keyswitch-map-key {
      width: 52px;
      min-width: 52px;
      padding: 4px 6px;
      text-align: center;
      text-transform: uppercase;
      border-radius: 6px;
      font-size: 11px;
      background: rgba(11, 16, 24, 0.82);
    }

    .keyswitch-map-warning {
      margin-left: 6px;
      color: var(--warn);
      font-size: 10px;
      letter-spacing: 0.04em;
      white-space: nowrap;
    }

    .sample-editor {
      border-bottom: 1px solid rgba(140, 146, 156, 0.2);
      padding: 8px;
      background: rgba(10, 15, 23, 0.58);
    }

    .sample-waveform-box {
      position: relative;
      display: grid;
      grid-template-columns: minmax(0, 1fr) auto;
      grid-template-areas:
        "info controls"
        "wave wave";
      column-gap: 8px;
      row-gap: 6px;
      align-items: center;
    }

    .sample-editor-title {
      display: block;
      flex: 0 1 auto;
      min-width: 0;
      max-width: 62%;
      color: var(--text);
      font-family: "SFMono-Regular", Menlo, monospace;
      text-transform: none;
      letter-spacing: 0.02em;
      font-size: 11px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .sample-controls-bar {
      position: relative;
      grid-area: controls;
      z-index: 3;
      width: auto;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 8px;
      pointer-events: auto;
      white-space: nowrap;
    }

    .sample-controls-bar > * {
      pointer-events: auto;
      flex: 0 0 auto;
    }

    .sample-editor-close {
      position: relative;
      top: auto;
      left: auto;
      right: auto;
      transform: none;
      z-index: 1;
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 4px;
      background: rgba(12, 17, 26, 0.8);
      color: var(--text);
      height: 22px;
      width: 22px;
      padding: 0;
      text-transform: none;
      letter-spacing: 0;
      font-size: 12px;
      line-height: 1;
      display: grid;
      place-items: center;
    }

    .sample-editor-meta {
      display: block;
      flex: 0 1 auto;
      min-width: 0;
      max-width: 38%;
      font-size: 10px;
      color: var(--text-dim);
      letter-spacing: 0.05em;
      text-transform: uppercase;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sample-editor-meta:empty::before {
      content: "";
    }

    .sample-editor-meta:not(:empty)::before {
      content: "| ";
      color: rgba(140, 146, 156, 0.65);
    }

    .sample-waveform-info {
      position: relative;
      grid-area: info;
      min-width: 0;
      max-width: none;
      z-index: 2;
      display: flex;
      align-items: center;
      gap: 6px;
      white-space: nowrap;
      overflow: hidden;
      pointer-events: auto;
      opacity: 1;
      padding: 2px 6px;
    }

    .sample-finetune {
      position: relative;
      top: auto;
      left: auto;
      right: auto;
      transform: none;
      z-index: 1;
      width: 22px;
      height: 22px;
    }

    .sample-finetune-tune {
      left: auto;
      right: auto;
    }

    .sample-finetune-knob {
      width: 22px;
      height: 22px;
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 50%;
      background: rgba(12, 17, 26, 0.82);
      position: relative;
      cursor: ns-resize;
      touch-action: none;
    }

    .sample-finetune-knob[data-tooltip] {
      position: relative;
    }

    .sample-finetune-knob[data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 50%;
      top: calc(100% + 6px);
      transform: translateX(-50%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(140, 146, 156, 0.36);
      border-radius: 6px;
      background: rgba(10, 14, 21, 0.95);
      color: var(--text);
      font-size: 10px;
      letter-spacing: 0.04em;
      padding: 4px 6px;
      z-index: 20;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .sample-finetune-knob[data-tooltip]:hover::after {
      opacity: 1;
      visibility: visible;
    }

    .sample-finetune-knob.disabled {
      opacity: 0.35;
      cursor: default;
    }

    .sample-finetune-pointer {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 2px;
      height: 8px;
      border-radius: 1px;
      background: rgba(216, 220, 228, 0.95);
      transform-origin: 50% 100%;
      transform: translate(-50%, -100%) rotate(0deg);
    }

    .sample-loop-xfade {}

    .sample-loop-xfade-pointer {
      background: rgba(255, 216, 92, 0.95);
    }

    .sample-loop-tools {
      position: relative;
      top: auto;
      left: auto;
      right: auto;
      transform: none;
      z-index: 1;
      display: flex;
      gap: 6px;
    }

    .sample-loop-tool-btn {
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 4px;
      background: rgba(12, 17, 26, 0.8);
      color: var(--text);
      height: 22px;
      min-width: 22px;
      padding: 0 6px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      font-size: 10px;
      line-height: 1;
      display: grid;
      place-items: center;
    }

    .sample-loop-tool-btn[disabled] {
      opacity: 0.35;
      cursor: default;
    }

    .sample-loop-tool-btn.active {
      border-color: rgba(255, 216, 92, 0.72);
      color: #ffdf7e;
      background: rgba(28, 24, 13, 0.86);
    }

    .import-pack-controls .sample-loop-tool-btn {
      white-space: nowrap;
    }

    .import-pack-controls.logo-menu-open {
      overflow: visible;
    }

    .logo-menu-wrap {
      position: relative;
      display: inline-flex;
    }

    .logo-position-menu {
      position: absolute;
      left: 0;
      top: calc(100% + 6px);
      z-index: 2000;
      display: grid;
      grid-template-columns: repeat(3, 24px);
      gap: 4px;
      padding: 6px;
      border: 1px solid rgba(140, 146, 156, 0.3);
      border-radius: 6px;
      background: rgba(12, 17, 26, 0.94);
      box-shadow: 0 10px 18px rgba(0, 0, 0, 0.34);
    }

    .logo-pos-btn {
      width: 24px;
      height: 24px;
      padding: 0;
      border: 1px solid rgba(140, 146, 156, 0.26);
      border-radius: 4px;
      background: rgba(20, 25, 34, 0.88);
      color: var(--text-dim);
      font-size: 9px;
      letter-spacing: 0.02em;
      text-transform: uppercase;
      display: grid;
      place-items: center;
    }

    .logo-pos-btn:hover {
      border-color: rgba(140, 146, 156, 0.5);
      background: rgba(33, 39, 50, 0.94);
      color: var(--text);
    }

    .logo-pos-btn.active {
      border-color: rgba(255, 216, 92, 0.72);
      background: rgba(43, 35, 14, 0.92);
      color: #ffdf7e;
    }

    .wallpaper-pos-btn.active {
      border-color: rgba(255, 216, 92, 0.72);
      background: rgba(43, 35, 14, 0.92);
      color: #ffdf7e;
    }

    .logo-position-menu .logo-remove-btn {
      grid-column: 1 / -1;
      min-width: 0;
      width: 100%;
      height: 22px;
      padding: 0 6px;
      letter-spacing: 0.02em;
      font-size: 9px;
      justify-self: stretch;
    }

    .sample-waveform-viewport {
      grid-area: wave;
      width: 100%;
      height: 234px;
      padding: 0;
      overflow-x: auto;
      overflow-y: hidden;
      border: 1px solid rgba(140, 146, 156, 0.28);
      border-radius: 4px;
      background: rgba(4, 8, 14, 0.82);
      scrollbar-width: none;
      -ms-overflow-style: none;
      cursor: default;
    }

    .sample-waveform-viewport::-webkit-scrollbar {
      width: 0;
      height: 0;
      display: none;
    }

    .sample-waveform-viewport.pannable {
      cursor: grab;
    }

    .sample-waveform-viewport.panning {
      cursor: grabbing;
    }

    .sample-waveform-content {
      position: relative;
      min-width: 100%;
      height: 100%;
    }

    .sample-waveform {
      width: 100%;
      height: 100%;
      display: block;
      background: transparent;
    }

    .sample-gain-line {
      position: absolute;
      left: 0;
      right: 0;
      height: 12px;
      margin-top: -6px;
      cursor: ns-resize;
      touch-action: none;
      z-index: 4;
      opacity: 0.2;
      transition: opacity 120ms ease;
    }

    .sample-gain-line:hover,
    .sample-gain-line.dragging {
      opacity: 1;
    }

    .sample-gain-line::before {
      content: "";
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 2px;
      transform: translateY(-50%);
      background: rgba(255, 216, 92, 0.96);
      box-shadow: 0 0 8px rgba(255, 216, 92, 0.34);
    }

    .sample-gain-line::after {
      content: "";
      position: absolute;
      right: 7px;
      top: 50%;
      width: 7px;
      height: 7px;
      border: 1px solid rgba(255, 216, 92, 0.96);
      border-radius: 50%;
      background: rgba(6, 12, 20, 0.96);
      transform: translateY(-50%);
    }

    .sample-gain-readout {
      position: absolute;
      right: 20px;
      top: 50%;
      transform: translateY(-50%);
      color: rgba(255, 223, 126, 0.92);
      font-family: "SFMono-Regular", Menlo, monospace;
      font-size: 10px;
      letter-spacing: 0.03em;
      line-height: 1;
      pointer-events: none;
      text-shadow: 0 0 4px rgba(6, 12, 20, 0.88);
    }

    .sample-loop-region {
      position: absolute;
      top: 0;
      bottom: 0;
      background: rgba(255, 216, 92, 0.1);
      border-left: 1px solid rgba(255, 216, 92, 0.55);
      border-right: 1px solid rgba(255, 216, 92, 0.55);
      pointer-events: none;
      z-index: 3;
    }

    .sample-loop-fade-region {
      position: absolute;
      top: 0;
      bottom: 0;
      background: linear-gradient(90deg, rgba(255, 216, 92, 0.04), rgba(255, 216, 92, 0.18));
      border-left: 1px dashed rgba(255, 216, 92, 0.5);
      border-right: 1px dashed rgba(255, 216, 92, 0.72);
      pointer-events: none;
      z-index: 2;
    }

    .sample-playhead {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 2px;
      margin-left: -1px;
      background: rgba(208, 242, 255, 0.96);
      box-shadow: 0 0 8px rgba(164, 170, 180, 0.5);
      pointer-events: none;
      z-index: 6;
    }

    .sample-playhead::before {
      content: "";
      position: absolute;
      left: 50%;
      top: 0;
      width: 8px;
      height: 8px;
      transform: translate(-50%, -42%);
      border: 1px solid rgba(208, 242, 255, 0.88);
      border-radius: 50%;
      background: rgba(9, 13, 20, 0.92);
    }

    .sample-loop-handle {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 16px;
      margin-left: -8px;
      cursor: ew-resize;
      touch-action: none;
      z-index: 5;
    }

    .sample-loop-handle::before {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 2px;
      transform: translateX(-50%);
      background: rgba(255, 216, 92, 0.96);
    }

    .sample-loop-handle::after {
      content: "";
      position: absolute;
      left: 50%;
      top: 50%;
      width: 8px;
      height: 18px;
      border: 1px solid rgba(255, 216, 92, 0.96);
      border-radius: 999px;
      transform: translate(-50%, -50%);
      background: rgba(9, 13, 20, 0.85);
    }

    .sample-loop-fade-handle::before {
      width: 1px;
      border-left: 1px dashed rgba(255, 216, 92, 0.88);
      background: transparent;
      transform: translateX(-1px);
    }

    .sample-loop-fade-handle::after {
      width: 6px;
      height: 14px;
      border: 1px dashed rgba(255, 216, 92, 0.95);
      background: rgba(9, 13, 20, 0.78);
    }

    .map-viewport {
      position: relative;
      padding-top: 6px;
    }

    .octave-nav {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 34px;
      border: 0;
      border-radius: 0;
      background: transparent;
      color: rgba(228, 239, 255, 0.92);
      font-size: 24px;
      font-weight: 600;
      line-height: 1;
      text-transform: none;
      letter-spacing: 0;
      padding: 0;
      z-index: 8;
      opacity: 0;
      transition: opacity 130ms ease, background 130ms ease;
    }

    .octave-nav.left {
      left: 0;
    }

    .octave-nav.right {
      right: 0;
    }

    .map-viewport .octave-nav:hover,
    .map-viewport .octave-nav:focus-visible {
      opacity: 1;
      background: linear-gradient(90deg, rgba(9, 12, 18, 0.88), rgba(9, 12, 18, 0));
    }

    .map-viewport .octave-nav.right:hover,
    .map-viewport .octave-nav.right:focus-visible {
      background: linear-gradient(270deg, rgba(9, 12, 18, 0.88), rgba(9, 12, 18, 0));
    }

    .octave-nav:disabled {
      pointer-events: none;
      opacity: 0;
    }

    .map-empty {
      position: absolute;
      top: 60px;
      left: 44px;
      right: 44px;
      text-align: center;
      color: var(--text-dim);
      font-size: 11px;
      letter-spacing: 0.04em;
      pointer-events: none;
      z-index: 3;
    }

    .map-samples {
      display: grid;
      grid-template-columns: repeat(12, minmax(0, 1fr));
      gap: var(--map-col-gap);
      min-height: 132px;
      padding: 0 8px 8px;
      overflow: visible;
    }

    .map-col {
      height: 124px;
      display: flex;
      flex-direction: column;
      gap: 3px;
      padding: 2px 0;
      overflow: visible;
      position: relative;
      z-index: 1;
    }

    .map-velocity-row {
      flex: 1 1 0;
      min-height: 10px;
      position: relative;
      overflow: visible;
    }

    .map-col::before {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      width: 1px;
      background: rgba(140, 146, 156, 0.1);
      pointer-events: none;
      z-index: 0;
    }

    .map-col:last-child::after {
      content: "";
      position: absolute;
      top: 0;
      bottom: 0;
      right: 0;
      width: 1px;
      background: rgba(140, 146, 156, 0.1);
      pointer-events: none;
      z-index: 0;
    }

    .map-sample-box {
      --span-total: 1;
      --span-left: 0;
      --root-slot: 0;
      position: relative;
      height: 100%;
      min-height: 10px;
      width: calc((100% * var(--span-total)) + (var(--map-col-gap) * (var(--span-total) - 1)));
      margin-left: calc((-100% * var(--span-left)) - (var(--map-col-gap) * var(--span-left)));
      border: 1px solid rgba(164, 170, 180, 0.86);
      border-radius: 2px;
      background:
        linear-gradient(
          90deg,
          rgba(164, 170, 180, 0.22) 0%,
          rgba(164, 170, 180, 0.22) calc((100% / var(--span-total)) * var(--root-slot)),
          rgba(164, 170, 180, 0.68) calc((100% / var(--span-total)) * var(--root-slot)),
          rgba(164, 170, 180, 0.68) calc((100% / var(--span-total)) * (var(--root-slot) + 1)),
          rgba(164, 170, 180, 0.22) calc((100% / var(--span-total)) * (var(--root-slot) + 1)),
          rgba(164, 170, 180, 0.22) 100%
        );
      cursor: pointer;
      z-index: 2;
    }

    .map-rr-grid {
      position: absolute;
      top: 1px;
      bottom: 1px;
      left: calc(
        (var(--root-slot) * ((100% - (var(--map-col-gap) * (var(--span-total) - 1))) / var(--span-total)))
        + (var(--root-slot) * var(--map-col-gap))
      );
      width: calc((100% - (var(--map-col-gap) * (var(--span-total) - 1))) / var(--span-total));
      display: grid;
      grid-template-columns: repeat(var(--rr-count, 1), minmax(0, 1fr));
      gap: 2px;
      pointer-events: none;
      z-index: 3;
    }

    .map-rr-cell {
      appearance: none;
      border: 0;
      border-radius: 1px;
      background: rgba(164, 170, 180, 0.18);
      cursor: pointer;
      padding: 0;
      margin: 0;
      pointer-events: auto;
      position: relative;
      transition: background 120ms ease, box-shadow 120ms ease;
    }

    .map-rr-cell:hover {
      background: rgba(86, 146, 255, 0.26);
      box-shadow: inset 0 0 0 1px rgba(116, 168, 255, 0.82);
    }

    .map-rr-cell.selected {
      background: rgba(58, 126, 255, 0.34);
      box-shadow: inset 0 0 0 1px rgba(132, 184, 255, 0.96);
    }

    .map-sample-box.selected {
      border-color: rgba(255, 236, 148, 0.95);
      box-shadow: inset 0 0 0 1px rgba(255, 236, 148, 0.45);
    }

    .map-sample-box::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 50%;
      top: calc(100% + 4px);
      transform: translateX(-50%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(140, 146, 156, 0.36);
      border-radius: 6px;
      background: rgba(10, 14, 21, 0.95);
      color: var(--text);
      font-size: 10px;
      letter-spacing: 0.04em;
      padding: 4px 6px;
      z-index: 20;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .map-sample-box:hover::after {
      opacity: 1;
      visibility: visible;
    }

    .map-sample-box.tooltip-right::after {
      left: auto;
      right: 0;
      transform: none;
    }

    .map-sample-box.tooltip-left::after {
      left: 0;
      transform: none;
    }

    .map-rr-cell::after {
      content: attr(data-tooltip);
      position: absolute;
      left: 50%;
      top: calc(100% + 4px);
      transform: translateX(-50%);
      white-space: nowrap;
      pointer-events: none;
      border: 1px solid rgba(140, 146, 156, 0.36);
      border-radius: 6px;
      background: rgba(10, 14, 21, 0.95);
      color: var(--text);
      font-size: 10px;
      letter-spacing: 0.04em;
      padding: 4px 6px;
      z-index: 24;
      opacity: 0;
      visibility: hidden;
      transition: opacity 120ms ease;
    }

    .map-rr-cell:hover::after {
      opacity: 1;
      visibility: visible;
    }

    .map-rr-cell.tooltip-right::after {
      left: auto;
      right: 0;
      transform: none;
    }

    .map-rr-cell.tooltip-left::after {
      left: 0;
      transform: none;
    }

    .map-range-handle {
      position: absolute;
      top: -1px;
      bottom: -1px;
      width: 8px;
      z-index: 5;
      opacity: 0;
      transition: opacity 100ms ease;
    }

    .map-sample-box:hover .map-range-handle,
    .map-sample-box.selected .map-range-handle {
      opacity: 1;
    }

    .map-range-handle.left {
      left: -4px;
      cursor: w-resize;
    }

    .map-range-handle.right {
      right: -4px;
      cursor: e-resize;
    }

    .map-range-handle::before {
      content: "";
      position: absolute;
      top: 3px;
      bottom: 3px;
      left: 2px;
      right: 2px;
      border-radius: 2px;
      border: 1px solid rgba(255, 236, 148, 0.75);
      background: rgba(255, 236, 148, 0.32);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.14);
    }

    .map-keys {
      display: grid;
      grid-template-columns: repeat(12, minmax(0, 1fr));
      gap: var(--map-col-gap);
      align-items: end;
      padding: 0 8px 0;
    }

    .map-key {
      border: 1px solid rgba(14, 20, 30, 0.9);
      border-bottom: 0;
      border-radius: 0;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 3px;
      font-family: "SFMono-Regular", Menlo, monospace;
      font-size: 10px;
      letter-spacing: 0.02em;
      line-height: 1;
    }

    .map-key.white {
      height: 54px;
      background: linear-gradient(180deg, #f8fbff, #e6edf8);
      color: #2f3a4f;
    }

    .map-key.black {
      height: 54px;
      background: linear-gradient(180deg, #272f3f, #131927);
      color: #c8d8f4;
    }

    .map-key.disabled {
      opacity: 0.35;
    }

    .map-key.pressed {
      box-shadow: inset 0 0 0 1px rgba(198, 204, 214, 0.72);
      filter: brightness(1.04);
    }

    .hidden {
      display: none;
    }

    @media (max-width: 1100px) {
      .setup-layout,
      .auto-layout {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 900px) {
      .auto-stack-split {
        grid-template-columns: 1fr;
      }

      .auto-sampler-columns {
        grid-template-columns: 1fr;
      }

      .tabs {
        flex-wrap: wrap;
      }

      .top-right-controls {
        width: 100%;
        margin-left: 0;
        justify-content: flex-end;
      }

      .top-right-controls .player-author-display {
        max-width: none;
      }

      .simple-grid {
        grid-template-columns: repeat(3, minmax(70px, 1fr));
      }

      .field-grid,
      .stats {
        grid-template-columns: 1fr;
      }

      .player-controls {
        right: 6px;
        bottom: calc(var(--player-kb-height) + 6px);
        gap: 4px;
      }

      .player-stage {
        --player-kb-height: 76px;
        --player-white-key-width: 19px;
      }

      .player-controls .knob {
        width: 44px;
      }

      .player-divider {
        height: 22px;
        margin: 0 1px;
      }

      .player-load-btn {
        width: 74px;
        height: 74px;
        font-size: 48px;
      }

      .map-key.white {
        height: 46px;
      }

      .map-key.black {
        height: 46px;
      }

      .octave-nav {
        width: 28px;
        font-size: 20px;
      }

      .map-empty {
        left: 34px;
        right: 34px;
      }
    }
  </style>
</head>
<body>
  <main class="instrument">
    <nav class="tabs">
      <button class="tab-btn icon-tab active" type="button" data-tab="player" aria-label="Player" title="Player">
        <svg viewBox="0 -960 960 960" aria-hidden="true" focusable="false">
          <path d="M186.67-120q-27 0-46.84-19.83Q120-159.67 120-186.67v-586.66q0-26.34 19.83-46.5Q159.67-840 186.67-840h586.66q26.34 0 46.5 20.17Q840-799.67 840-773.33v586.66q0 27-20.17 46.84Q799.67-120 773.33-120H186.67Zm0-66.67h148v-200H318q-14.17 0-23.75-9.58T284.67-420v-353.33h-98v586.66Zm438.66 0h148v-586.66h-98V-420q0 14.17-9.58 23.75T642-386.67h-16.67v200Zm-244 0h197.34v-200H562q-14.17 0-23.75-9.58T528.67-420v-353.33h-97.34V-420q0 14.17-9.58 23.75T398-386.67h-16.67v200Z"/>
        </svg>
      </button>
      <button class="tab-btn icon-tab" type="button" data-tab="setup" aria-label="Setup / Mapping" title="Setup / Mapping">
        <svg viewBox="0 -960 960 960" aria-hidden="true" focusable="false">
          <path d="M748.33-82.5q-5.66-2.17-11-7.5L508-319.33q-5.33-5.34-7.5-11-2.17-5.67-2.17-12.34 0-6.66 2.17-12.33t7.5-11l85-85q5.33-5.33 11-7.5t12.33-2.17q6.67 0 12.34 2.17 5.66 2.17 11 7.5L869-221.67q5.33 5.34 7.5 11 2.17 5.67 2.17 12.34 0 6.66-2.17 12.33t-7.5 11l-85 85q-5.33 5.33-11 7.5t-12.33 2.17q-6.67 0-12.34-2.17Zm12.34-77.5L799-198.33 616.67-380.67l-38.34 38.34L760.67-160ZM185.5-82.33Q179.33-84.67 174-90l-84-84q-5.33-5.33-7.67-11.5Q80-191.67 80-198.33q0-6.67 2.33-12.34 2.34-5.66 7.67-11l220.67-220.66h85L432.33-479 260.67-650.67h-57L80-774.33 183.67-878l123.66 123.67v57L479-525.67 604.33-651l-59-59 56-56h-113L467-787.33 599.67-920 621-898.67v113l56-56 160 160q15.67 15.67 24.33 35.84Q870-625.67 870-603q0 21.33-7.33 41-7.34 19.67-21 35.33l-85-85-56 56L652-604.33 442.33-394.67v84L221.67-90q-5.34 5.33-11 7.67Q205-80 198.33-80q-6.66 0-12.83-2.33ZM198.33-160l190-190v-38.33H350l-190 190L198.33-160Zm0 0L160-198.33l19.67 18.66L198.33-160Zm562.34 0L799-198.33 760.67-160Z"/>
        </svg>
      </button>
      <div class="top-right-controls">
        <div id="playerAuthorDisplay" class="player-author-display" aria-live="polite"></div>
        <div class="knob knob-mini tooltip-right" data-param="gain" data-min="-24" data-max="12" data-step="0.1" data-value="0" data-unit="dB" data-decimals="1">
          <div class="knob-face"><div class="knob-pointer"></div></div>
          <div class="knob-label">Output</div>
          <div class="knob-value"></div>
        </div>
      </div>
    </nav>

    <input id="wallpaperInput" class="hidden" type="file" accept="image/*">
    <input id="logoInput" class="hidden" type="file" accept="image/*">
    <input id="filesInput" class="hidden" type="file" multiple accept=".wav,.aif,.aiff,.flac,.ogg,.mp3,.WAV,.AIF,.AIFF,.FLAC,.OGG,.MP3">
    <input id="folderInput" class="hidden" type="file" webkitdirectory directory multiple>
    <input id="packInput" class="hidden" type="file" accept=".smpinst,.json">
    <input id="keyswitchInput" class="hidden" type="file" accept=".keysw,.json" multiple>

    <section id="panel-player" class="panel active">
      <div id="playerStage" class="player-stage">
        <div class="player-logo-zone" aria-hidden="true">
          <div id="playerLogoWrap" class="player-logo hidden" aria-hidden="true">
            <img id="playerLogo" class="player-logo-img" alt="">
          </div>
        </div>
        <div id="playerGodRays" class="player-god-rays" aria-hidden="true"></div>
        <canvas id="playerParticles" class="player-particles hidden" aria-hidden="true"></canvas>
        <div id="playerEmptyState" class="player-empty">
          <button id="playerLoadInstrumentBtn" class="player-load-btn" type="button" aria-label="Load sample instrument" title="Load sample instrument">+</button>
        </div>
        <div class="player-controls">
          <div class="knob knob-mini" data-param="ampAttack" data-min="0" data-max="5000" data-step="1" data-value="10" data-unit="ms" data-tooltip-value="true">
            <div class="knob-face"><div class="knob-pointer"></div></div>
            <div class="knob-label">Attack</div>
            <div class="knob-value"></div>
          </div>
          <div class="knob knob-mini" data-param="ampDecay" data-min="0" data-max="5000" data-step="1" data-value="120" data-unit="ms" data-tooltip-value="true">
            <div class="knob-face"><div class="knob-pointer"></div></div>
            <div class="knob-label">Decay</div>
            <div class="knob-value"></div>
          </div>
          <div class="knob knob-mini" data-param="ampSustain" data-min="0" data-max="100" data-step="1" data-value="100" data-unit="%" data-tooltip-value="true">
            <div class="knob-face"><div class="knob-pointer"></div></div>
            <div class="knob-label">Sustain</div>
            <div class="knob-value"></div>
          </div>
          <div class="knob knob-mini" data-param="ampRelease" data-min="0" data-max="5000" data-step="1" data-value="320" data-unit="ms" data-tooltip-value="true">
            <div class="knob-face"><div class="knob-pointer"></div></div>
            <div class="knob-label">Release</div>
            <div class="knob-value"></div>
          </div>
          <div class="player-divider" aria-hidden="true"></div>
          <div class="knob knob-mini" data-param="filterCutoff" data-min="20" data-max="20000" data-step="10" data-value="12000" data-unit="Hz" data-tooltip-value="true">
            <div class="knob-face"><div class="knob-pointer"></div></div>
            <div class="knob-label">Filter</div>
            <div class="knob-value"></div>
          </div>
          <div class="knob knob-mini tooltip-right" data-param="filterResonance" data-min="0.1" data-max="12" data-step="0.1" data-value="0.7" data-unit="Q" data-decimals="1" data-tooltip-value="true">
            <div class="knob-face"><div class="knob-pointer"></div></div>
            <div class="knob-label">Resonance</div>
            <div class="knob-value"></div>
          </div>
        </div>
        <div class="player-keyboard-strip" aria-label="Player keyboard">
          <div class="player-wheel-bank" aria-label="Performance wheels">
            <div class="player-wheel-block" data-wheel="pitch">
              <div id="playerPitchWheelSlot" class="player-wheel-slot pitch" role="slider" aria-label="Pitch bend wheel" aria-valuemin="-1" aria-valuemax="1" aria-valuenow="0">
                <div class="player-wheel-core">
                  <div id="playerPitchWheelTape" class="player-wheel-tape"></div>
                  <div class="player-wheel-ridges"></div>
                </div>
                <div class="player-wheel-marker"></div>
              </div>
            </div>
            <div class="player-wheel-block" data-wheel="mod">
              <div id="playerModWheelSlot" class="player-wheel-slot mod" role="slider" aria-label="Mod wheel" aria-valuemin="0" aria-valuemax="1" aria-valuenow="0">
                <div class="player-wheel-core">
                  <div id="playerModWheelTape" class="player-wheel-tape"></div>
                  <div class="player-wheel-ridges"></div>
                </div>
                <div class="player-wheel-marker"></div>
              </div>
            </div>
          </div>
          <div id="playerKeyboardViewport" class="player-keyboard-viewport">
            <div id="playerKeyboard" class="player-keyboard">
              <div id="playerKeyboardWhites" class="player-keys-whites"></div>
              <div id="playerKeyboardBlacks" class="player-keys-blacks"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section id="panel-setup" class="panel">
      <div class="setup-layout">
        <div class="setup-wide">
          <div id="importPackSection" class="section collapsible collapsed">
            <h2 id="importPackToggle" role="button" tabindex="0" aria-expanded="false" aria-controls="importPackBody">Import / Pack</h2>
            <div id="importPackBody" class="section-body">
              <div class="btn-row import-pack-controls">
                <button id="addFilesBtn" class="sample-loop-tool-btn" type="button">Add Files</button>
                <button id="addFolderBtn" class="sample-loop-tool-btn" type="button">Add Folder</button>
                <button id="importKeyswitchesBtn" class="sample-loop-tool-btn" type="button">Import Keyswitches</button>
                <button id="clearInstrumentBtn" class="sample-loop-tool-btn" type="button">Clear</button>
                <button id="saveSmpinstBtn" class="sample-loop-tool-btn" type="button">Save (.smpinst)</button>
              </div>
              <div id="dropZone" class="drop" style="margin-top: 8px;">
                Drop audio files here. Filename tokens: NOTE(required), V1..V5, RRn, L
              </div>
              <div id="setupStatus" class="status"></div>
            </div>
          </div>

          <div id="graphicsSection" class="section collapsible collapsed">
            <h2 id="graphicsToggle" role="button" tabindex="0" aria-expanded="false" aria-controls="graphicsBody">Graphics</h2>
            <div id="graphicsBody" class="section-body">
              <div id="graphicsControls" class="btn-row import-pack-controls">
                <div id="wallpaperMenuWrap" class="logo-menu-wrap">
                  <button id="wallpaperToggle" class="sample-loop-tool-btn" type="button" aria-label="Add wallpaper" title="Add wallpaper">Add Wallpaper</button>
                  <div id="wallpaperPositionMenu" class="logo-position-menu hidden" role="menu" aria-label="Wallpaper position">
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="top-left" title="Top left">TL</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="top-center" title="Top center">TC</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="top-right" title="Top right">TR</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="middle-left" title="Middle left">ML</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="middle-center" title="Middle center">MC</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="middle-right" title="Middle right">MR</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="bottom-left" title="Bottom left">BL</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="bottom-center" title="Bottom center">BC</button>
                    <button class="logo-pos-btn wallpaper-pos-btn" type="button" data-wallpaper-pos="bottom-right" title="Bottom right">BR</button>
                    <button id="wallpaperRemoveBtn" class="sample-loop-tool-btn logo-remove-btn" type="button" title="Remove wallpaper">Remove</button>
                  </div>
                </div>
                <div id="logoMenuWrap" class="logo-menu-wrap">
                  <button id="logoToggle" class="sample-loop-tool-btn" type="button" aria-label="Add logo" title="Add logo">Add Logo</button>
                  <div id="logoPositionMenu" class="logo-position-menu hidden" role="menu" aria-label="Logo position">
                    <button class="logo-pos-btn" type="button" data-logo-pos="top-left" title="Top left">TL</button>
                    <button class="logo-pos-btn" type="button" data-logo-pos="top-center" title="Top center">TC</button>
                    <button class="logo-pos-btn" type="button" data-logo-pos="top-right" title="Top right">TR</button>
                    <button id="logoRemoveBtn" class="sample-loop-tool-btn logo-remove-btn" type="button" title="Remove logo">Remove</button>
                  </div>
                </div>
                <button id="particlesToggle" class="sample-loop-tool-btn" type="button" aria-pressed="true" title="Disable particles">Particles On</button>
                <button id="godRaysToggle" class="sample-loop-tool-btn" type="button" aria-pressed="true" title="Disable god rays">God Rays On</button>
              </div>
            </div>
          </div>

          <div id="autoSamplerSection" class="section collapsible collapsed">
            <h2 id="autoSamplerToggle" role="button" tabindex="0" aria-expanded="false" aria-controls="autoSamplerBody">Auto Sampler</h2>
            <div id="autoSamplerBody" class="section-body auto-layout">
              <div class="section">
                <div class="field-grid auto-meta-grid">
                  <div class="field">
                    <label for="autoDestination">Destination Folder</label>
                    <input id="autoDestination" type="text" value="/Users/you/Samples/Rendered" title="Click to choose destination folder">
                    <input id="autoDestinationPicker" class="hidden" type="file" webkitdirectory directory multiple tabindex="-1" aria-hidden="true">
                  </div>
                  <div class="field">
                    <label id="autoInstrumentLabel" for="autoInstrument">Instrument Name</label>
                    <input id="autoInstrument" type="text" value="MyInstrument">
                  </div>
                  <div class="field">
                    <label id="autoAuthorLabel" for="autoAuthor">Author</label>
                    <input id="autoAuthor" type="text" value="">
                  </div>
                </div>
              </div>

              <div class="auto-sampler-columns">
                <div class="auto-sampler-left">
                  <div class="section">
                    <div class="auto-stack-split">
                      <div class="field-grid auto-stack-grid">
                        <div id="autoStartField" class="field note-inline">
                          <label for="autoStart">Start Note</label>
                          <div class="interval-stepper" role="group" aria-label="Start note">
                            <button id="autoStartDown" class="interval-step-btn" type="button" aria-label="Previous start note">&lt;</button>
                            <input id="autoStart" class="note-input" type="text" value="C2" maxlength="3">
                            <button id="autoStartUp" class="interval-step-btn" type="button" aria-label="Next start note">&gt;</button>
                          </div>
                        </div>
                        <div id="autoEndField" class="field note-inline">
                          <label for="autoEnd">End Note</label>
                          <div class="interval-stepper" role="group" aria-label="End note">
                            <button id="autoEndDown" class="interval-step-btn" type="button" aria-label="Previous end note">&lt;</button>
                            <input id="autoEnd" class="note-input" type="text" value="C5" maxlength="3">
                            <button id="autoEndUp" class="interval-step-btn" type="button" aria-label="Next end note">&gt;</button>
                          </div>
                        </div>
                        <div class="field note-inline" id="intervalWrap">
                          <label for="autoIntervalValue">Sample Interval</label>
                          <div class="interval-stepper" role="group" aria-label="Interval">
                            <button id="autoIntervalDown" class="interval-step-btn" type="button" aria-label="Decrease interval">&lt;</button>
                            <input id="autoIntervalValue" class="interval-input" type="text" value="3" maxlength="2" inputmode="numeric" aria-label="Interval value">
                            <button id="autoIntervalUp" class="interval-step-btn" type="button" aria-label="Increase interval">&gt;</button>
                          </div>
                        </div>
                        <div id="autoVelField" class="field note-inline">
                          <label for="autoVelValue">Velocity Layers</label>
                          <div class="interval-stepper" role="group" aria-label="Velocity layers">
                            <button id="autoVelDown" class="interval-step-btn" type="button" aria-label="Decrease velocity layers">&lt;</button>
                            <input id="autoVelValue" class="interval-input" type="text" value="3" maxlength="1" inputmode="numeric" aria-label="Velocity layers value">
                            <button id="autoVelUp" class="interval-step-btn" type="button" aria-label="Increase velocity layers">&gt;</button>
                          </div>
                        </div>
                        <div id="autoRRField" class="field note-inline">
                          <label for="autoRRValue">Round Robin</label>
                          <div class="interval-stepper" role="group" aria-label="Round robin per note">
                            <button id="autoRRDown" class="interval-step-btn" type="button" aria-label="Decrease round robin per note">&lt;</button>
                            <input id="autoRRValue" class="interval-input" type="text" value="2" maxlength="1" inputmode="numeric" aria-label="Round robin per note value">
                            <button id="autoRRUp" class="interval-step-btn" type="button" aria-label="Increase round robin per note">&gt;</button>
                          </div>
                        </div>
                        <div class="field auto-ms-field">
                          <label for="autoHoldMs">Sustain</label>
                          <input id="autoHoldMs" class="ms-input" type="text" value="1800" inputmode="numeric">
                        </div>
                        <div class="field auto-ms-field">
                          <label for="autoTailMs">Release Tail</label>
                          <input id="autoTailMs" class="ms-input" type="text" value="700" inputmode="numeric">
                        </div>
                        <div class="field auto-ms-field">
                          <label for="autoPrerollMs">Pre-roll</label>
                          <input id="autoPrerollMs" class="ms-input" type="text" value="120" inputmode="numeric">
                        </div>
                      </div>
                      <div class="field-grid auto-stack-grid">
                        <div class="field auto-loop-row">
                          <label for="autoLoop" class="auto-loop-row-label">Loop Samples</label>
                          <label class="sample-velocity-toggle auto-loop-inline auto-loop-check" title="Loop samples" aria-label="Loop samples">
                            <input id="autoLoop" type="checkbox">
                            <span class="sample-velocity-toggle-mark">âœ“</span>
                          </label>
                        </div>
                        <div class="field auto-loop-row">
                          <label for="autoNormalizeRecorded" class="auto-loop-row-label">Normalize</label>
                          <label class="sample-velocity-toggle auto-loop-inline auto-loop-check" title="Normalize recorded samples" aria-label="Normalize recorded samples">
                            <input id="autoNormalizeRecorded" type="checkbox">
                            <span class="sample-velocity-toggle-mark">âœ“</span>
                          </label>
                        </div>
                        <div id="autoLoopDetails" class="auto-loop-options hidden">
                          <div class="field auto-loop-option-row">
                            <label for="autoLoopMode">Auto Loop</label>
                            <label class="sample-velocity-toggle auto-loop-inline" title="Auto loop" aria-label="Auto loop">
                              <input id="autoLoopMode" type="checkbox" checked>
                              <span class="sample-velocity-toggle-mark">âœ“</span>
                            </label>
                          </div>
                          <div class="field auto-loop-option-row">
                            <label for="autoLoopStartPct">Loop Start</label>
                            <div class="auto-loop-value-wrap">
                              <input id="autoLoopStartPct" class="ms-input" type="text" value="10" inputmode="numeric">
                              <span class="auto-loop-unit">%</span>
                            </div>
                          </div>
                          <div class="field auto-loop-option-row">
                            <label for="autoLoopEndPct">Loop End</label>
                            <div class="auto-loop-value-wrap">
                              <input id="autoLoopEndPct" class="ms-input" type="text" value="90" inputmode="numeric">
                              <span class="auto-loop-unit">%</span>
                            </div>
                          </div>
                          <div class="field auto-loop-option-row">
                            <label for="autoLoopCutAtEnd">Cut Loop At End</label>
                            <label class="sample-velocity-toggle auto-loop-inline" title="Cut loop at end" aria-label="Cut loop at end">
                              <input id="autoLoopCutAtEnd" type="checkbox">
                              <span class="sample-velocity-toggle-mark">âœ“</span>
                            </label>
                          </div>
                          <div class="field auto-loop-option-row">
                            <label for="autoLoopCrossfadeMs">Loop Crossfade</label>
                            <div class="auto-loop-value-wrap">
                              <input id="autoLoopCrossfadeMs" class="ms-input" type="text" value="30" inputmode="numeric">
                              <span class="auto-loop-unit">ms</span>
                            </div>
                          </div>
                        </div>
                        <div class="field auto-pack-row-inline">
                          <div id="autoPackAsWrap" class="auto-pack-as-wrap auto-pack-as-row">
                            <label for="autoPackAsBtn" class="auto-pack-row-label">Save Samples As</label>
                            <button id="autoPackAsBtn" class="auto-pack-trigger" type="button" aria-haspopup="true" aria-expanded="false" aria-label="Save samples as options">v</button>
                            <div id="autoPackAsMenu" class="auto-pack-as-menu hidden" role="menu" aria-label="Save samples as format">
                              <label class="auto-pack-check">
                                <input class="auto-pack-check-input" type="checkbox" data-pack-ext="keyswitch">
                                <span class="auto-pack-check-mark">âœ“</span>
                                <span class="auto-pack-check-text">.keysw</span>
                              </label>
                              <label class="auto-pack-check">
                                <input class="auto-pack-check-input" type="checkbox" data-pack-ext="smpinst" checked>
                                <span class="auto-pack-check-mark">âœ“</span>
                                <span class="auto-pack-check-text">.smpinst</span>
                              </label>
                              <label class="auto-pack-check">
                                <input class="auto-pack-check-input" type="checkbox" data-pack-ext="elmulti">
                                <span class="auto-pack-check-mark">âœ“</span>
                                <span class="auto-pack-check-text">.elmulti</span>
                              </label>
                              <label class="auto-pack-check">
                                <input class="auto-pack-check-input" type="checkbox" data-pack-ext="dspreset">
                                <span class="auto-pack-check-mark">âœ“</span>
                                <span class="auto-pack-check-text">.dspreset</span>
                              </label>
                              <label class="auto-pack-check">
                                <input class="auto-pack-check-input" type="checkbox" data-pack-ext="sfz">
                                <span class="auto-pack-check-mark">âœ“</span>
                                <span class="auto-pack-check-text">.sfz</span>
                              </label>
                            </div>
                          </div>
                        </div>
                        <div class="field auto-pack-row-inline">
                          <div id="autoPresetWrap" class="auto-pack-as-wrap auto-pack-as-row">
                            <label for="autoPresetBtn" class="auto-pack-row-label">Preset</label>
                            <button id="autoPresetBtn" class="auto-pack-trigger" type="button" aria-haspopup="true" aria-expanded="false" aria-label="Preset options">v</button>
                            <div id="autoPresetMenu" class="auto-pack-as-menu auto-preset-menu hidden" role="menu" aria-label="Preset options">
                              <button id="autoPresetSaveBtn" class="sample-loop-tool-btn auto-preset-save-btn" type="button">Save Preset</button>
                              <div id="autoPresetCreateRow" class="auto-preset-create hidden">
                                <input id="autoPresetNameInput" class="auto-preset-name-input" type="text" maxlength="40" placeholder="Preset name">
                                <button id="autoPresetConfirmBtn" class="sample-loop-tool-btn auto-preset-confirm-btn" type="button">Save</button>
                              </div>
                              <div id="autoPresetList" class="auto-preset-list">
                                <div class="auto-preset-empty">No presets</div>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>

                <div class="auto-sampler-right">
                  <div class="section computed-preview">
                    <h2>Computed Preview</h2>
                    <div id="renderTotal" class="render"><strong>0</strong> total renders</div>
                    <div id="renderTime" class="render render-time">Estimated record time: <span class="render-time-value">0:00</span></div>
                    <div id="renderSize" class="render render-size">Estimated file size: <span class="render-size-value">0 B</span></div>
                    <button id="startSamplingBtn" class="sample-loop-tool-btn start-sampling-btn" type="button">Start Sampling</button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div id="keyboardMapSection" class="section setup-map-wide collapsible collapsed">
            <h2 id="keyboardMapToggle" class="setup-map-toggle" role="button" tabindex="0" aria-expanded="false" aria-controls="keyboardMapBody">Keyboard Map</h2>
            <div id="keyboardMapBody" class="section-body">
              <div id="keyswitchMapToolbar" class="keyswitch-map-toolbar hidden">
                <label for="keyswitchMapSelect">Keyswitch Set</label>
                <select id="keyswitchMapSelect" class="keyswitch-map-select" aria-label="Select keyswitch set"></select>
                <div id="keyswitchMapKeyWrap" class="keyswitch-map-key-wrap hidden">
                  <label for="keyswitchMapKeyInput">Key</label>
                  <input id="keyswitchMapKeyInput" class="keyswitch-map-key" type="text" maxlength="3" inputmode="text" aria-label="Keyswitch key">
                </div>
                <span id="keyswitchMapWarning" class="keyswitch-map-warning hidden" aria-live="polite"></span>
              </div>
              <div class="map-shell">
              <div id="sampleEditor" class="sample-editor hidden">
                <div class="sample-waveform-box">
                  <div class="sample-controls-bar">
                    <div class="sample-loop-tools">
                      <button id="sampleLoopPrevBtn" class="sample-loop-tool-btn" type="button" title="Previous loop candidate">&lt;</button>
                      <button id="sampleLoopNextBtn" class="sample-loop-tool-btn" type="button" title="Next loop candidate">&gt;</button>
                      <button id="sampleFindLoopBtn" class="sample-loop-tool-btn" type="button" title="Find best loop">Find</button>
                      <button id="sampleLoopApplyAllBtn" class="sample-loop-tool-btn" type="button" title="Apply current loop strategy to all samples">All</button>
                    </div>
                    <div id="sampleLoopXfadeKnob" class="sample-finetune sample-loop-xfade" aria-label="Loop crossfade">
                      <div class="sample-finetune-knob" role="slider" tabindex="0" aria-valuemin="0" aria-valuemax="500" aria-valuenow="30" aria-label="Loop crossfade milliseconds">
                        <div id="sampleLoopXfadePointer" class="sample-finetune-pointer sample-loop-xfade-pointer"></div>
                      </div>
                    </div>
                    <label class="sample-velocity-toggle" title="Velocity crossfade 30%" aria-label="Velocity crossfade 30%">
                      <input id="velocityXfadeToggle" type="checkbox">
                      <span class="sample-velocity-toggle-mark">âœ“</span>
                    </label>
                    <div id="sampleFineTuneKnob" class="sample-finetune sample-finetune-tune" aria-label="Fine tune">
                      <div class="sample-finetune-knob" role="slider" tabindex="0" aria-valuemin="-100" aria-valuemax="100" aria-valuenow="0" aria-label="Fine tune cents">
                        <div id="sampleFineTunePointer" class="sample-finetune-pointer"></div>
                      </div>
                    </div>
                    <button id="sampleEditorClose" class="sample-editor-close" type="button" aria-label="Close sample editor">x</button>
                  </div>
                  <div class="sample-waveform-info">
                    <div id="sampleEditorTitle" class="sample-editor-title"></div>
                    <div id="sampleEditorMeta" class="sample-editor-meta"></div>
                  </div>
                  <div id="sampleWaveformViewport" class="sample-waveform-viewport">
                    <div id="sampleWaveformContent" class="sample-waveform-content">
                      <canvas id="sampleWaveform" class="sample-waveform"></canvas>
                      <div id="sampleGainLine" class="sample-gain-line hidden" aria-label="Sample gain line">
                        <span id="sampleGainReadout" class="sample-gain-readout">0.0 dB</span>
                      </div>
                      <div id="sampleLoopRegion" class="sample-loop-region hidden"></div>
                      <div id="sampleLoopFadeRegion" class="sample-loop-fade-region hidden"></div>
                      <div id="samplePlayhead" class="sample-playhead hidden"></div>
                      <div id="sampleLoopFade" class="sample-loop-handle sample-loop-fade-handle hidden" aria-label="Loop crossfade start"></div>
                      <div id="sampleLoopStart" class="sample-loop-handle hidden" aria-label="Loop start"></div>
                      <div id="sampleLoopEnd" class="sample-loop-handle hidden" aria-label="Loop end"></div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="map-viewport">
                <button id="octaveDownBtn" class="octave-nav left" type="button" aria-label="Previous octave">&lt;</button>
                <button id="octaveUpBtn" class="octave-nav right" type="button" aria-label="Next octave">&gt;</button>
                <div id="mapEmpty" class="map-empty hidden">Import samples to see key mapping.</div>
                <div id="mapSamples" class="map-samples"></div>
                <div id="mapKeys" class="map-keys"></div>
              </div>
            </div>
            </div>
          </div>

          <div id="effectsSection" class="section collapsible collapsed">
            <h2 id="effectsToggle" role="button" tabindex="0" aria-expanded="false" aria-controls="effectsBody">Effects</h2>
            <div id="effectsBody" class="section-body">
              <div id="effectsStatus" class="status">Effects controls coming next.</div>
            </div>
          </div>
        </div>
      </div>
    </section>

  </main>

  <div id="summaryModal" class="modal-backdrop hidden" role="dialog" aria-modal="true" aria-labelledby="summaryModalTitle">
    <div class="modal-window">
      <div class="modal-head">
        <h2 id="summaryModalTitle" class="modal-title">Imported Summary</h2>
        <button id="closeSummaryBtn" class="modal-close" type="button" aria-label="Close Imported Summary">&times;</button>
      </div>
      <div class="modal-body">
        <div id="importLog" class="log">No files imported.</div>
      </div>
    </div>
  </div>

  <script>
    const NOTE_TO_SEMITONE = {
      C: 0, "C#": 1, Db: 1, D: 2, "D#": 3, Eb: 3, E: 4,
      F: 5, "F#": 6, Gb: 6, G: 7, "G#": 8, Ab: 8, A: 9, "A#": 10, Bb: 10, B: 11
    };
    const NOTE_NAMES = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const BLACK_SEMITONES = new Set([1, 3, 6, 8, 10]);
    const AUDIO_REGEX = /\.(wav|aif|aiff|flac|ogg|mp3)$/i;
    const IMAGE_EXT_REGEX = /\.(png|jpe?g|webp|gif|bmp|svg|avif)$/i;
    const SETUP_COLLAPSE_STATE_KEY = "samplePlayer.setupCollapseState.v1";
    const AUTO_PRESET_STORAGE_KEY = "samplePlayer.autoSamplerPresets.v1";
    const SAME_KEY_RETRIGGER_FADE_SEC = 0.05;
    const PLAYER_KB_START_MIDI = 12; // C0
    const PLAYER_KB_END_MIDI = 84; // C6
    const HOST_EDITOR_WIDTH = 1040;
    const HOST_PLAYER_FIXED_HEIGHT = 760;
    const HOST_SETUP_MIN_HEIGHT = 560;
    const HOST_SETUP_MAX_HEIGHT = 2600;

    const state = {
      wallpaperUrl: "",
      wallpaperName: "",
      wallpaperObjectUrl: "",
      wallpaperPosition: "middle-center",
      wallpaperMenuOpen: false,
      logoUrl: "",
      logoName: "",
      logoObjectUrl: "",
      logoPosition: "top-left",
      logoMenuOpen: false,
      packLoaded: false,
      setupOctaveStart: 48,
      rrCursor: {},
      entries: [],
      manualRootRanges: {},
      knobs: {},
      allowPitchUpAboveHighest: true,
      autoRR: true,
      velocityCrossfadePercent: 0,
      velocityCrossfadeByRoot: {},
      loopCrossfadeMs: 30,
      autoGainCrossfade: true,
      selectedMapEntryOrder: null,
      waveformCache: new Map(),
      waveformRequestId: 0,
      audioContext: null,
      waveformZoom: 1,
      loopCandidates: [],
      loopCandidateIndex: -1,
      loopCandidateOrder: null,
      loopSearchBusy: false,
      loopNavVisible: false,
      playheadAnimationId: 0,
      playheadSession: null,
      previewVoicesByKey: new Map(),
      previewVoiceId: 0,
      previewHtmlAudioByKey: new Map(),
      previewTriggerSerialByKey: new Map(),
      modWheelValue: 0,
      pitchBendValue: 0,
      playerParticlesEnabled: true,
      playerGodRaysEnabled: true,
      playerParticleRgb: [218, 222, 229],
      playerParticleGlowRgb: [238, 242, 248],
      playerParticles: [],
      playerParticlesRaf: 0,
      playerParticlesLastTs: 0,
      playerParticlesRunning: false,
      playerParticlesDpr: 1,
      autoPresets: [],
      keyswitchSets: [],
      activeMapSetId: "base",
      nextVirtualOrder: -1,
      samplingCountdownTimer: 0,
      samplingCountdownEndsAt: 0,
      nativeAutoSamplerAvailable: false,
      nativeAutoSamplerActive: false,
      nativeAutoSamplerExpected: 0,
      nativeAutoSamplerCaptured: 0,
      nativeAutoSamplerTakeCount: 0,
      deferredAutoLoopOrders: [],
      nativeAutoSamplerInputDetected: false,
      nativeAutoSamplerMessage: "",
      nativeAutoSamplerListeners: [],
      hostResizeRaf: 0,
      lastHostResizeWidth: 0,
      lastHostResizeHeight: 0
    };

    const el = {
      tabsBar: document.querySelector(".tabs"),
      playerControls: document.querySelector(".player-controls"),
      playerAuthorDisplay: document.getElementById("playerAuthorDisplay"),
      playerParticles: document.getElementById("playerParticles"),
      wallpaperInput: document.getElementById("wallpaperInput"),
      logoInput: document.getElementById("logoInput"),
      wallpaperToggle: document.getElementById("wallpaperToggle"),
      wallpaperMenuWrap: document.getElementById("wallpaperMenuWrap"),
      wallpaperPositionMenu: document.getElementById("wallpaperPositionMenu"),
      wallpaperPositionButtons: Array.from(document.querySelectorAll("#wallpaperPositionMenu .wallpaper-pos-btn")),
      wallpaperRemoveBtn: document.getElementById("wallpaperRemoveBtn"),
      logoToggle: document.getElementById("logoToggle"),
      particlesToggle: document.getElementById("particlesToggle"),
      godRaysToggle: document.getElementById("godRaysToggle"),
      importPackControls: document.getElementById("graphicsControls"),
      logoMenuWrap: document.getElementById("logoMenuWrap"),
      logoPositionMenu: document.getElementById("logoPositionMenu"),
      logoPositionButtons: Array.from(document.querySelectorAll("#logoPositionMenu .logo-pos-btn")),
      logoRemoveBtn: document.getElementById("logoRemoveBtn"),
      playerStage: document.getElementById("playerStage"),
      playerLogoWrap: document.getElementById("playerLogoWrap"),
      playerLogo: document.getElementById("playerLogo"),
      playerEmptyState: document.getElementById("playerEmptyState"),
      playerLoadInstrumentBtn: document.getElementById("playerLoadInstrumentBtn"),
      playerModWheelSlot: document.getElementById("playerModWheelSlot"),
      playerModWheelTape: document.getElementById("playerModWheelTape"),
      playerPitchWheelSlot: document.getElementById("playerPitchWheelSlot"),
      playerPitchWheelTape: document.getElementById("playerPitchWheelTape"),
      playerKeyboardViewport: document.getElementById("playerKeyboardViewport"),
      playerKeyboard: document.getElementById("playerKeyboard"),
      playerKeyboardWhites: document.getElementById("playerKeyboardWhites"),
      playerKeyboardBlacks: document.getElementById("playerKeyboardBlacks"),
      octaveDownBtn: document.getElementById("octaveDownBtn"),
      octaveUpBtn: document.getElementById("octaveUpBtn"),
      mapSamples: document.getElementById("mapSamples"),
      mapKeys: document.getElementById("mapKeys"),
      mapEmpty: document.getElementById("mapEmpty"),
      keyswitchMapToolbar: document.getElementById("keyswitchMapToolbar"),
      keyswitchMapSelect: document.getElementById("keyswitchMapSelect"),
      keyswitchMapKeyWrap: document.getElementById("keyswitchMapKeyWrap"),
      keyswitchMapKeyInput: document.getElementById("keyswitchMapKeyInput"),
      keyswitchMapWarning: document.getElementById("keyswitchMapWarning"),
      sampleEditor: document.getElementById("sampleEditor"),
      sampleEditorTitle: document.getElementById("sampleEditorTitle"),
      sampleEditorMeta: document.getElementById("sampleEditorMeta"),
      sampleFineTuneKnob: document.getElementById("sampleFineTuneKnob"),
      sampleFineTunePointer: document.getElementById("sampleFineTunePointer"),
      sampleLoopXfadeKnob: document.getElementById("sampleLoopXfadeKnob"),
      sampleLoopXfadePointer: document.getElementById("sampleLoopXfadePointer"),
      sampleFindLoopBtn: document.getElementById("sampleFindLoopBtn"),
      sampleLoopPrevBtn: document.getElementById("sampleLoopPrevBtn"),
      sampleLoopNextBtn: document.getElementById("sampleLoopNextBtn"),
      sampleLoopApplyAllBtn: document.getElementById("sampleLoopApplyAllBtn"),
      sampleWaveformViewport: document.getElementById("sampleWaveformViewport"),
      sampleWaveformContent: document.getElementById("sampleWaveformContent"),
      sampleWaveform: document.getElementById("sampleWaveform"),
      sampleGainLine: document.getElementById("sampleGainLine"),
      sampleGainReadout: document.getElementById("sampleGainReadout"),
      sampleLoopRegion: document.getElementById("sampleLoopRegion"),
      sampleLoopFadeRegion: document.getElementById("sampleLoopFadeRegion"),
      samplePlayhead: document.getElementById("samplePlayhead"),
      sampleLoopFade: document.getElementById("sampleLoopFade"),
      sampleLoopStart: document.getElementById("sampleLoopStart"),
      sampleLoopEnd: document.getElementById("sampleLoopEnd"),
      sampleEditorClose: document.getElementById("sampleEditorClose"),
      importPackSection: document.getElementById("importPackSection"),
      importPackToggle: document.getElementById("importPackToggle"),
      graphicsSection: document.getElementById("graphicsSection"),
      graphicsToggle: document.getElementById("graphicsToggle"),
      autoSamplerSection: document.getElementById("autoSamplerSection"),
      autoSamplerToggle: document.getElementById("autoSamplerToggle"),
      keyboardMapSection: document.getElementById("keyboardMapSection"),
      keyboardMapToggle: document.getElementById("keyboardMapToggle"),
      effectsSection: document.getElementById("effectsSection"),
      effectsToggle: document.getElementById("effectsToggle"),

      tabs: Array.from(document.querySelectorAll(".tab-btn")),
      panels: {
        player: document.getElementById("panel-player"),
        setup: document.getElementById("panel-setup")
      },

      addFilesBtn: document.getElementById("addFilesBtn"),
      addFolderBtn: document.getElementById("addFolderBtn"),
      clearInstrumentBtn: document.getElementById("clearInstrumentBtn"),
      importKeyswitchesBtn: document.getElementById("importKeyswitchesBtn"),
      saveSmpinstBtn: document.getElementById("saveSmpinstBtn"),
      loadPackBtn: document.getElementById("loadPackBtn"),
      packBtn: document.getElementById("packBtn"),
      openSummaryBtn: document.getElementById("openSummaryBtn"),
      closeSummaryBtn: document.getElementById("closeSummaryBtn"),
      summaryModal: document.getElementById("summaryModal"),
      filesInput: document.getElementById("filesInput"),
      folderInput: document.getElementById("folderInput"),
      packInput: document.getElementById("packInput"),
      keyswitchInput: document.getElementById("keyswitchInput"),
      dropZone: document.getElementById("dropZone"),
      velocityXfadeToggle: document.getElementById("velocityXfadeToggle"),
      setupStatus: document.getElementById("setupStatus"),
      importLog: document.getElementById("importLog"),

      autoStart: document.getElementById("autoStart"),
      autoStartDown: document.getElementById("autoStartDown"),
      autoStartUp: document.getElementById("autoStartUp"),
      autoEnd: document.getElementById("autoEnd"),
      autoEndDown: document.getElementById("autoEndDown"),
      autoEndUp: document.getElementById("autoEndUp"),
      autoIntervalValue: document.getElementById("autoIntervalValue"),
      autoIntervalDown: document.getElementById("autoIntervalDown"),
      autoIntervalUp: document.getElementById("autoIntervalUp"),
      autoVelValue: document.getElementById("autoVelValue"),
      autoVelDown: document.getElementById("autoVelDown"),
      autoVelUp: document.getElementById("autoVelUp"),
      autoRRValue: document.getElementById("autoRRValue"),
      autoRRDown: document.getElementById("autoRRDown"),
      autoRRUp: document.getElementById("autoRRUp"),
      autoLoop: document.getElementById("autoLoop"),
      autoLoopDetails: document.getElementById("autoLoopDetails"),
      autoLoopMode: document.getElementById("autoLoopMode"),
      autoLoopStartPct: document.getElementById("autoLoopStartPct"),
      autoLoopEndPct: document.getElementById("autoLoopEndPct"),
      autoLoopCutAtEnd: document.getElementById("autoLoopCutAtEnd"),
      autoNormalizeRecorded: document.getElementById("autoNormalizeRecorded"),
      autoLoopCrossfadeMs: document.getElementById("autoLoopCrossfadeMs"),
      autoHoldMs: document.getElementById("autoHoldMs"),
      autoTailMs: document.getElementById("autoTailMs"),
      autoPrerollMs: document.getElementById("autoPrerollMs"),
      autoPackAsWrap: document.getElementById("autoPackAsWrap"),
      autoPackAsBtn: document.getElementById("autoPackAsBtn"),
      autoPackAsMenu: document.getElementById("autoPackAsMenu"),
      autoPackChecks: Array.from(document.querySelectorAll(".auto-pack-check-input")),
      autoPresetWrap: document.getElementById("autoPresetWrap"),
      autoPresetBtn: document.getElementById("autoPresetBtn"),
      autoPresetMenu: document.getElementById("autoPresetMenu"),
      autoPresetSaveBtn: document.getElementById("autoPresetSaveBtn"),
      autoPresetCreateRow: document.getElementById("autoPresetCreateRow"),
      autoPresetNameInput: document.getElementById("autoPresetNameInput"),
      autoPresetConfirmBtn: document.getElementById("autoPresetConfirmBtn"),
      autoPresetList: document.getElementById("autoPresetList"),
      autoPackKeyswitchCheck: document.querySelector('.auto-pack-check-input[data-pack-ext="keyswitch"]'),
      autoDestination: document.getElementById("autoDestination"),
      autoDestinationPicker: document.getElementById("autoDestinationPicker"),
      autoInstrumentLabel: document.getElementById("autoInstrumentLabel"),
      autoInstrument: document.getElementById("autoInstrument"),
      autoAuthorLabel: document.getElementById("autoAuthorLabel"),
      autoAuthor: document.getElementById("autoAuthor"),
      renderTotal: document.getElementById("renderTotal"),
      renderTime: document.getElementById("renderTime"),
      renderSize: document.getElementById("renderSize"),
      startSamplingBtn: document.getElementById("startSamplingBtn")
    };

    function getDefaultSetupCollapseState() {
      return {
        importPack: true,
        graphics: true,
        autoSampler: true,
        keyboardMap: true,
        effects: true
      };
    }

    function loadSetupCollapseState() {
      const defaults = getDefaultSetupCollapseState();
      try {
        const raw = window.sessionStorage.getItem(SETUP_COLLAPSE_STATE_KEY);
        if (!raw) return defaults;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") return defaults;
        const next = { ...defaults };
        Object.keys(next).forEach((key) => {
          if (typeof parsed[key] === "boolean") next[key] = parsed[key];
        });
        return next;
      } catch {
        return defaults;
      }
    }

    function saveSetupCollapseState(key, collapsed) {
      const stateMap = loadSetupCollapseState();
      stateMap[key] = !!collapsed;
      try {
        window.sessionStorage.setItem(SETUP_COLLAPSE_STATE_KEY, JSON.stringify(stateMap));
      } catch {
        // ignore storage failures
      }
    }

    function midiToNote(midi) {
      return `${NOTE_NAMES[midi % 12]}${Math.floor(midi / 12) - 1}`;
    }

    function noteToMidi(note) {
      const match = String(note || "").trim().match(/^([A-Ga-g])([#b]?)(-?\d{1,2})$/);
      if (!match) return null;
      const token = `${match[1].toUpperCase()}${match[2]}`;
      const pitch = NOTE_TO_SEMITONE[token];
      if (pitch === undefined) return null;
      const midi = (Number(match[3]) + 1) * 12 + pitch;
      if (midi < 0 || midi > 127) return null;
      return midi;
    }

    function parseFilename(name) {
      const stem = name.replace(/\.[^/.]+$/, "");
      const note = stem.match(/([A-Ga-g])([#b]?)(-?\d{1,2})/);
      if (!note) return { valid: false, reason: "Missing NOTE token" };
      const noteToken = `${note[1].toUpperCase()}${note[2]}${note[3]}`;
      const rootMidi = noteToMidi(noteToken);
      if (rootMidi === null) return { valid: false, reason: `Invalid NOTE token ${noteToken}` };
      const parts = stem.split(/[^A-Za-z0-9#]+/).filter(Boolean);
      const partsUpper = parts.map((p) => p.toUpperCase());
      let velocityLayer = null;
      let hasVelocityToken = false;

      for (const token of partsUpper) {
        const byV = token.match(/^V([1-9][0-9]{0,2})$/);
        if (byV) {
          velocityLayer = Number(byV[1]);
          hasVelocityToken = true;
          break;
        }
        const byVelWord = token.match(/^VEL(?:OCITY)?([1-9][0-9]{0,2})$/);
        if (byVelWord) {
          velocityLayer = Number(byVelWord[1]);
          hasVelocityToken = true;
          break;
        }
      }

      if (velocityLayer === null) {
        const byV = stem.match(/(?:^|[^A-Za-z0-9])V([1-9][0-9]{0,2})(?:$|[^A-Za-z0-9])/i);
        if (byV) {
          velocityLayer = Number(byV[1]);
          hasVelocityToken = true;
        }
      }

      if (velocityLayer === null) {
        const byVelWord = stem.match(/VEL(?:OCITY)?[_-]?([1-9][0-9]{0,2})/i);
        if (byVelWord) {
          velocityLayer = Number(byVelWord[1]);
          hasVelocityToken = true;
        }
      }

      if (!Number.isFinite(velocityLayer)) velocityLayer = 3;
      velocityLayer = Math.max(1, Math.min(5, velocityLayer));

      let rrIndex = null;
      let hasRRToken = false;
      for (const token of partsUpper) {
        const rrToken = token.match(/^RR([1-9][0-9]*)$/);
        if (rrToken) {
          rrIndex = Number(rrToken[1]);
          hasRRToken = true;
          break;
        }
      }
      if (rrIndex === null) {
        const rr = stem.match(/(?:^|[^A-Za-z0-9])RR([1-9][0-9]*)(?:$|[^A-Za-z0-9])/i);
        if (rr) {
          rrIndex = Number(rr[1]);
          hasRRToken = true;
        }
      }

      const suffixSerialMatch = stem.match(/(?:_|-)(\d+)$/);
      const suffixSerial = suffixSerialMatch ? Number(suffixSerialMatch[1]) : null;
      const loopEnabled = partsUpper.includes("L");
      return {
        valid: true,
        noteToken,
        rootMidi,
        velocityLayer,
        rrIndex,
        loopEnabled,
        hasVelocityToken,
        hasRRToken,
        suffixSerial
      };
    }

    function setStatus(node, text, type = "") {
      node.textContent = text;
      node.classList.remove("ok", "warn", "bad");
      if (type) node.classList.add(type);
    }

    function getNativeBackend() {
      const backend = window.__JUCE__ && window.__JUCE__.backend;
      if (!backend || typeof backend !== "object") return null;
      return backend;
    }

    function emitNativeEvent(eventId, payload) {
      const backend = getNativeBackend();
      if (!backend || typeof backend.emitEvent !== "function") return false;
      try {
        backend.emitEvent(eventId, payload);
        return true;
      } catch {
        return false;
      }
    }

    function clampHostSize(value, min, max, fallback) {
      const num = Number(value);
      if (!Number.isFinite(num)) return fallback;
      return Math.max(min, Math.min(max, Math.round(num)));
    }

    function emitHostResize(width, height) {
      const nextWidth = clampHostSize(width, HOST_EDITOR_WIDTH, HOST_EDITOR_WIDTH, HOST_EDITOR_WIDTH);
      const nextHeight = clampHostSize(height, HOST_SETUP_MIN_HEIGHT, HOST_SETUP_MAX_HEIGHT, HOST_PLAYER_FIXED_HEIGHT);

      if (nextWidth === state.lastHostResizeWidth && nextHeight === state.lastHostResizeHeight) return;
      if (!emitNativeEvent("ui_resize", { width: nextWidth, height: nextHeight })) return;

      state.lastHostResizeWidth = nextWidth;
      state.lastHostResizeHeight = nextHeight;
    }

    function computeSetupHostHeight() {
      const tabsHeight = Math.ceil(el.tabsBar?.getBoundingClientRect?.().height || 0);
      const setupHeight = Math.ceil(el.panels.setup?.scrollHeight || 0);
      const shellBorder = 2;
      const target = tabsHeight + setupHeight + shellBorder;
      return clampHostSize(target, HOST_SETUP_MIN_HEIGHT, HOST_SETUP_MAX_HEIGHT, HOST_PLAYER_FIXED_HEIGHT);
    }

    function requestHostResizeForActiveTab() {
      const activeTab = document.querySelector(".tab-btn.active")?.dataset.tab || "player";
      const targetHeight = activeTab === "setup" ? computeSetupHostHeight() : HOST_PLAYER_FIXED_HEIGHT;
      emitHostResize(HOST_EDITOR_WIDTH, targetHeight);
    }

    function scheduleHostResizeForActiveTab() {
      if (state.hostResizeRaf) return;
      state.hostResizeRaf = window.requestAnimationFrame(() => {
        state.hostResizeRaf = 0;
        requestHostResizeForActiveTab();
      });
    }

    function buildNativeAutoSamplerSettings() {
      const startMidi = noteToMidi(el.autoStart?.value) ?? 36;
      const endMidi = noteToMidi(el.autoEnd?.value) ?? 72;
      const loopStartPercent = getAutoLoopStartPercent();
      const loopEndPercent = Math.max(loopStartPercent, getAutoLoopEndPercent());
      return {
        startMidi,
        endMidi,
        intervalSemitones: getAutoInterval(),
        velocityLayers: getAutoVelocityLayers(),
        roundRobinsPerNote: getAutoRRPerNote(),
        sustainMs: getAutoHoldMs(),
        releaseTailMs: getAutoTailMs(),
        prerollMs: getAutoPrerollMs(),
        loopSamples: !!el.autoLoop?.checked,
        autoLoopMode: !!el.autoLoopMode?.checked,
        loopStartPercent,
        loopEndPercent,
        cutLoopAtEnd: !!el.autoLoopCutAtEnd?.checked,
        loopCrossfadeMs: getAutoLoopCrossfadeMs(),
        normalizeRecorded: !!el.autoNormalizeRecorded?.checked
      };
    }

    function getAutoLoopConfigFromPayload(payload) {
      const info = (payload && typeof payload === "object") ? payload : {};
      const loopStartPercent = clampAutoPercent(info.loopStartPercent ?? getAutoLoopStartPercent());
      const loopEndPercent = Math.max(loopStartPercent, clampAutoPercent(info.loopEndPercent ?? getAutoLoopEndPercent()));
      return {
        loopSamples: !!(info.loopSamples ?? el.autoLoop?.checked),
        autoLoopMode: !!(info.autoLoopMode ?? el.autoLoopMode?.checked),
        loopStartPercent,
        loopEndPercent,
        loopCrossfadeMs: clampAutoMs(info.loopCrossfadeMs ?? getAutoLoopCrossfadeMs(), 0, 60000)
      };
    }

    function applyManualLoopConfigToEntry(entry, loopConfig, durationSec = null) {
      ensureEntryEditorState(entry);
      if (!loopConfig.loopSamples) {
        entry.loopStartNorm = 0;
        entry.loopEndNorm = 1;
        entry.loopFadeInNorm = 0;
        entry.loopEnabled = false;
        return;
      }

      const minGap = 0.002;
      const startNorm = clamp01(loopConfig.loopStartPercent / 100);
      const endNormRaw = clamp01(loopConfig.loopEndPercent / 100);
      const endNorm = Math.max(Math.min(1, startNorm + minGap), endNormRaw);
      entry.loopStartNorm = startNorm;
      entry.loopEndNorm = endNorm;
      entry.loopEnabled = true;

      if (Number.isFinite(durationSec) && durationSec > 0.0001) {
        const fadeNorm = clamp01((loopConfig.loopCrossfadeMs / 1000) / durationSec);
        entry.loopFadeInNorm = Math.max(0, startNorm - Math.min(startNorm, fadeNorm));
      } else {
        entry.loopFadeInNorm = startNorm;
      }
      ensureEntryEditorState(entry);
    }

    async function applyAutoLoopConfigToEntry(entry, payload) {
      if (!entry || !entry.sampleUrl) return;
      const loopConfig = getAutoLoopConfigFromPayload(payload);
      if (!loopConfig.loopSamples) {
        applyManualLoopConfigToEntry(entry, loopConfig, null);
        return;
      }

      let waveform = null;
      try {
        waveform = await getWaveformForEntry(entry);
      } catch {
        waveform = null;
      }

      const durationSec = Number.isFinite(waveform?.durationSec) ? waveform.durationSec : null;
      applyManualLoopConfigToEntry(entry, loopConfig, durationSec);

      if (loopConfig.autoLoopMode && waveform?.audioBuffer) {
        const candidates = buildLoopCandidatesFromBuffer(entry, waveform.audioBuffer, 1, loopConfig.loopCrossfadeMs);
        if (candidates.length > 0) {
          applyLoopCandidateToEntry(entry, candidates[0]);
        }
      }
    }

    function runDeferredAutoLoopPass() {
      if (state.nativeAutoSamplerActive) return;
      const uniqueOrders = Array.from(new Set(
        (state.deferredAutoLoopOrders || [])
          .map((value) => Math.round(Number(value)))
          .filter((value) => Number.isFinite(value))
      ));
      state.deferredAutoLoopOrders = [];
      if (!uniqueOrders.length) return;

      const payload = buildNativeAutoSamplerSettings();
      const tasks = uniqueOrders.map((order) => {
        const entry = getMapEntryByOrder(order);
        if (!entry) return Promise.resolve();
        return applyAutoLoopConfigToEntry(entry, payload).catch(() => {});
      });

      Promise.all(tasks).then(() => {
        renderSetup();
        syncAllKnobValues();
      });
    }

    function handleNativeAutoSamplerStatus(payload) {
      const info = (payload && typeof payload === "object") ? payload : {};
      const wasActive = !!state.nativeAutoSamplerActive;
      state.nativeAutoSamplerAvailable = true;
      state.nativeAutoSamplerActive = !!info.active;
      state.nativeAutoSamplerExpected = Math.max(0, Math.round(Number(info.expected) || 0));
      const capturedFromStatus = Math.max(0, Math.round(Number(info.captured) || 0));
      state.nativeAutoSamplerCaptured = Math.max(capturedFromStatus, state.nativeAutoSamplerTakeCount);
      state.nativeAutoSamplerInputDetected = !!info.inputDetected;
      state.nativeAutoSamplerMessage = String(info.message || "").trim();
      if (!state.nativeAutoSamplerActive && state.nativeAutoSamplerCaptured <= 0) {
        state.nativeAutoSamplerTakeCount = 0;
      }

      if (state.nativeAutoSamplerMessage) {
        let type = "ok";
        if (!state.nativeAutoSamplerInputDetected && state.nativeAutoSamplerMessage.toLowerCase().includes("no input")) {
          type = "warn";
        }
        setStatus(el.setupStatus, state.nativeAutoSamplerMessage, type);
      }

      if (wasActive && !state.nativeAutoSamplerActive) {
        runDeferredAutoLoopPass();
      }

      updateStartSamplingButtonLabel();
    }

    function appendNativeAutoSamplerTake(payload) {
      const info = (payload && typeof payload === "object") ? payload : {};
      const fileNameRaw = String(info.fileName || "").trim();
      const fileName = fileNameRaw || `AUTO_${Date.now()}.wav`;
      const dataUrl = String(info.dataUrl || "").trim();
      const hasAudioPayload = !!dataUrl;

      const rootMidi = Math.max(0, Math.min(127, Math.round(Number(info.rootMidi) || 60)));
      const velocityLayer = Math.max(1, Math.min(5, Math.round(Number(info.velocityLayer) || 1)));
      const rrIndexRaw = Math.round(Number(info.rrIndex));
      const rrIndex = Number.isFinite(rrIndexRaw) && rrIndexRaw > 0 ? rrIndexRaw : null;
      const velocityLow = Math.max(1, Math.min(127, Math.round(Number(info.velocityLow) || 1)));
      const velocityHigh = Math.max(velocityLow, Math.min(127, Math.round(Number(info.velocityHigh) || 127)));
      const velocity127 = Math.max(1, Math.min(127, Math.round(Number(info.velocity) || velocityHigh)));
      const hadValidEntries = state.entries.some((entry) => entry.valid);
      const normalizedRr = rrIndex === null ? null : Math.round(rrIndex);
      const pendingEntry = state.entries.find((entry) => (
        entry.valid
        && entry.autoCapturePending
        && entry.rootMidi === rootMidi
        && entry.velocityLayer === velocityLayer
        && ((Number.isFinite(entry.rrIndex) ? Math.round(entry.rrIndex) : null) === normalizedRr)
      )) || null;

      let entry = pendingEntry;
      if (!entry) {
        const nextOrder = state.entries.reduce((max, item) => (
          Number.isFinite(item?.order) ? Math.max(max, Math.round(item.order)) : max
        ), -1) + 1;

        entry = {
          fileName,
          order: nextOrder,
          sampleUrl: "",
          fineTuneCents: 0,
          loopStartNorm: 0,
          loopEndNorm: 1,
          loopFadeInNorm: 0,
          valid: true,
          reason: "",
          noteToken: midiToNote(rootMidi),
          rootMidi,
          velocityLayer,
          rrIndex,
          loopEnabled: false,
          hasVelocityToken: true,
          hasRRToken: rrIndex !== null,
          suffixSerial: null,
          velocityLow,
          velocityHigh,
          velocity127,
          autoCapturePending: !hasAudioPayload
        };
        state.entries.push(entry);
        if (!hadValidEntries) {
          state.setupOctaveStart = Math.floor(rootMidi / 12) * 12;
        }
        state.nativeAutoSamplerTakeCount = Math.max(0, state.nativeAutoSamplerTakeCount) + 1;
        state.nativeAutoSamplerCaptured = Math.max(state.nativeAutoSamplerCaptured, state.nativeAutoSamplerTakeCount);
      } else {
        entry.fileName = fileName;
        entry.noteToken = midiToNote(rootMidi);
        entry.rootMidi = rootMidi;
        entry.velocityLayer = velocityLayer;
        entry.rrIndex = rrIndex;
        entry.velocityLow = velocityLow;
        entry.velocityHigh = velocityHigh;
        entry.velocity127 = velocity127;
      }

      if (hasAudioPayload) {
        const blob = dataUrl.startsWith("data:") ? null : dataUrlToBlob(dataUrl);
        const sampleUrl = blob ? URL.createObjectURL(blob) : dataUrl;
        if (!sampleUrl) return;
        if (entry.sampleUrl && entry.sampleUrl.startsWith("blob:") && entry.sampleUrl !== sampleUrl) {
          URL.revokeObjectURL(entry.sampleUrl);
        }
        entry.sampleUrl = sampleUrl;
        entry.autoCapturePending = false;
      }

      state.activeMapSetId = "base";
      state.rrCursor = {};
      assignImplicitVelocityLayers();
      renderSetup();
      updatePlayerEmptyState();
      syncAllKnobValues();
      updateStartSamplingButtonLabel();

      if (!hasAudioPayload) return;

      const loopConfig = getAutoLoopConfigFromPayload(info);
      applyManualLoopConfigToEntry(entry, loopConfig, null);
      if (loopConfig.loopSamples && loopConfig.autoLoopMode) {
        if (state.nativeAutoSamplerActive) {
          state.deferredAutoLoopOrders.push(entry.order);
        } else {
          void applyAutoLoopConfigToEntry(entry, info).then(() => {
            if (!state.entries.includes(entry)) return;
            renderSetup();
            syncAllKnobValues();
          });
        }
      }
    }

    function setupNativeAutoSamplerBridge() {
      const backend = getNativeBackend();
      if (!backend || typeof backend.addEventListener !== "function") return;
      if (state.nativeAutoSamplerListeners.length) return;
      state.nativeAutoSamplerAvailable = true;

      try {
        const statusToken = backend.addEventListener("autosampler_status", (payload) => {
          handleNativeAutoSamplerStatus(payload);
        });
        const takeToken = backend.addEventListener("autosampler_take", (payload) => {
          appendNativeAutoSamplerTake(payload);
        });
        state.nativeAutoSamplerListeners = [statusToken, takeToken];
      } catch {
        state.nativeAutoSamplerAvailable = false;
      }
    }

    function stripFileExtension(name) {
      return String(name || "").replace(/\.[^/.]+$/, "");
    }

    function normalizeKeyswitchKey(rawValue, fallbackMidi = 12) {
      const raw = String(rawValue || "").trim().toUpperCase();
      const parsed = noteToMidi(raw);
      if (parsed === null) {
        const safeMidi = Math.max(0, Math.min(127, Math.round(Number(fallbackMidi) || 12)));
        return {
          keyMidi: safeMidi,
          key: midiToNote(safeMidi),
          valid: false
        };
      }
      return {
        keyMidi: parsed,
        key: midiToNote(parsed),
        valid: true
      };
    }

    function suggestUnusedKeyswitchMidi() {
      const used = new Set();
      (state.keyswitchSets || []).forEach((set) => {
        if (Number.isFinite(set?.keyMidi)) used.add(Math.round(set.keyMidi));
      });
      for (let midi = 12; midi <= 48; midi += 1) {
        if (!used.has(midi)) return midi;
      }
      return 12;
    }

    function collectDuplicateKeyswitchKeys() {
      const byMidi = new Map();
      (state.keyswitchSets || []).forEach((set) => {
        const midi = Number.isFinite(set?.keyMidi) ? Math.round(set.keyMidi) : null;
        if (midi === null) return;
        if (!byMidi.has(midi)) byMidi.set(midi, []);
        byMidi.get(midi).push(set.id);
      });
      const duplicates = new Map();
      byMidi.forEach((ids, midi) => {
        if (ids.length > 1) duplicates.set(midi, ids);
      });
      return duplicates;
    }

    function getKeyswitchSetById(setId) {
      const id = String(setId || "");
      return (state.keyswitchSets || []).find((set) => String(set.id || "") === id) || null;
    }

    function getDuplicateKeyswitchNotes() {
      return Array.from(collectDuplicateKeyswitchKeys().keys())
        .sort((a, b) => a - b)
        .map((midi) => midiToNote(midi));
    }

    function getBaseMapEntries() {
      return state.entries.filter((entry) => entry.valid);
    }

    function getAvailableMapSets() {
      const sets = [];
      const baseEntries = getBaseMapEntries();
      const keyswitchSets = Array.isArray(state.keyswitchSets) ? state.keyswitchSets : [];
      const keyswitchMode = keyswitchSets.length > 0;
      if (!keyswitchMode && baseEntries.length) {
        sets.push({
          id: "base",
          label: "Main",
          entries: baseEntries,
          manualRanges: state.manualRootRanges
        });
      }

      keyswitchSets.forEach((set) => {
        const keyLabel = set.key ? ` (${set.key})` : "";
        sets.push({
          id: set.id,
          label: `${set.name}${keyLabel}`,
          entries: Array.isArray(set.entries) ? set.entries.filter((entry) => entry.valid) : [],
          manualRanges: set.manualRanges || {}
        });
      });
      if (!sets.length) {
        sets.push({
          id: "base",
          label: "Main",
          entries: baseEntries,
          manualRanges: state.manualRootRanges
        });
      }
      return sets;
    }

    function getActiveMapSet() {
      const available = getAvailableMapSets();
      if (!available.length) return null;
      let active = available.find((item) => item.id === state.activeMapSetId) || null;
      if (!active) {
        active = available[0];
        state.activeMapSetId = active.id;
      }
      return active;
    }

    function getActiveMapEntries() {
      const active = getActiveMapSet();
      if (!active) return [];
      return Array.isArray(active.entries) ? active.entries : [];
    }

    function getActiveMapManualRanges() {
      const active = getActiveMapSet();
      if (!active || !active.manualRanges) return state.manualRootRanges;
      return active.manualRanges;
    }

    function getPlayerPlaybackSource() {
      const keyswitchSets = Array.isArray(state.keyswitchSets) ? state.keyswitchSets : [];
      if (keyswitchSets.length > 0) {
        const activeKeyswitchSet = getKeyswitchSetById(state.activeMapSetId) || keyswitchSets[0];
        if (activeKeyswitchSet && activeKeyswitchSet.id !== state.activeMapSetId) {
          state.activeMapSetId = activeKeyswitchSet.id;
          updateKeyswitchMapSelector();
        }
        return {
          entries: Array.isArray(activeKeyswitchSet?.entries) ? activeKeyswitchSet.entries.filter((entry) => entry.valid) : [],
          manualRanges: activeKeyswitchSet?.manualRanges || {}
        };
      }
      return {
        entries: state.entries.filter((entry) => entry.valid),
        manualRanges: state.manualRootRanges
      };
    }

    function setActiveMapSet(setId, shouldRender = true) {
      const next = String(setId || "base");
      const available = getAvailableMapSets();
      const keyswitchMode = (state.keyswitchSets || []).length > 0;
      const exists = available.some((item) => item.id === next);
      let resolvedId = exists ? next : (available[0]?.id || "base");
      if (keyswitchMode && resolvedId === "base") {
        resolvedId = available.find((item) => item.id !== "base")?.id || resolvedId;
      }
      const changed = state.activeMapSetId !== resolvedId;
      state.activeMapSetId = resolvedId;
      if (changed) stopAllPreviewVoices();
      closeSampleEditor();
      if (shouldRender) {
        renderKeyboardMap(undefined, true);
        renderPlayerKeyboard();
      }
      updateKeyswitchMapSelector();
    }

    function updateKeyswitchToolbarKeyEditor() {
      if (!el.keyswitchMapKeyWrap || !el.keyswitchMapKeyInput || !el.keyswitchMapWarning) return;
      const activeKeyswitchSet = getKeyswitchSetById(state.activeMapSetId);
      const showKeyEditor = !!activeKeyswitchSet;
      el.keyswitchMapKeyWrap.classList.toggle("hidden", !showKeyEditor);
      if (!showKeyEditor) {
        el.keyswitchMapKeyInput.value = "";
        const duplicates = getDuplicateKeyswitchNotes();
        if (duplicates.length > 0) {
          el.keyswitchMapWarning.classList.remove("hidden");
          el.keyswitchMapWarning.textContent = `Duplicate keys: ${duplicates.join(", ")}`;
        } else {
          el.keyswitchMapWarning.classList.add("hidden");
          el.keyswitchMapWarning.textContent = "";
        }
        return;
      }

      const displayKey = activeKeyswitchSet.key || (Number.isFinite(activeKeyswitchSet.keyMidi) ? midiToNote(activeKeyswitchSet.keyMidi) : "");
      el.keyswitchMapKeyInput.value = displayKey;
      const duplicates = collectDuplicateKeyswitchKeys();
      const activeMidi = Number.isFinite(activeKeyswitchSet.keyMidi) ? Math.round(activeKeyswitchSet.keyMidi) : null;
      if (activeMidi !== null && duplicates.has(activeMidi)) {
        el.keyswitchMapWarning.classList.remove("hidden");
        el.keyswitchMapWarning.textContent = `Duplicate key ${midiToNote(activeMidi)}. Change key.`;
      } else {
        el.keyswitchMapWarning.classList.add("hidden");
        el.keyswitchMapWarning.textContent = "";
      }
    }

    function applyActiveKeyswitchSetKeyInput(shouldRender = true) {
      if (!el.keyswitchMapKeyInput) return false;
      const set = getKeyswitchSetById(state.activeMapSetId);
      if (!set) return false;
      const parsed = noteToMidi(String(el.keyswitchMapKeyInput.value || "").trim().toUpperCase());
      if (parsed === null) {
        el.keyswitchMapKeyInput.value = set.key || midiToNote(Number(set.keyMidi) || 12);
        setStatus(el.setupStatus, "Invalid keyswitch key. Use note format like C0.", "warn");
        return false;
      }
      set.keyMidi = parsed;
      set.key = midiToNote(parsed);
      updateKeyswitchMapSelector();
      const duplicates = getDuplicateKeyswitchNotes();
      if (duplicates.length > 0) {
        setStatus(el.setupStatus, `Duplicate keyswitch keys: ${duplicates.join(", ")}. Change key values.`, "warn");
      } else {
        setStatus(el.setupStatus, `Keyswitch key updated to ${set.key}.`, "ok");
      }
      if (shouldRender) {
        renderKeyboardMap(undefined, true);
        renderPlayerKeyboard();
      }
      return true;
    }

    function updateKeyswitchMapSelector() {
      if (!el.keyswitchMapToolbar || !el.keyswitchMapSelect) return;
      const available = getAvailableMapSets();
      const show = available.length > 1;
      el.keyswitchMapToolbar.classList.toggle("hidden", !show);
      if (!show) {
        el.keyswitchMapSelect.innerHTML = "";
        if (!available.length) state.activeMapSetId = "base";
        else state.activeMapSetId = available[0].id;
        updateKeyswitchToolbarKeyEditor();
        return;
      }

      el.keyswitchMapSelect.innerHTML = "";
      available.forEach((item) => {
        const option = document.createElement("option");
        option.value = item.id;
        option.textContent = item.label;
        option.selected = item.id === state.activeMapSetId;
        el.keyswitchMapSelect.appendChild(option);
      });
      if (!available.some((item) => item.id === state.activeMapSetId)) {
        state.activeMapSetId = available[0].id;
      }
      el.keyswitchMapSelect.value = state.activeMapSetId;
      updateKeyswitchToolbarKeyEditor();
    }

    function buildKeyswitchEntriesFromManifest(data, options = null) {
      const useVirtualOrder = options?.useVirtualOrder !== false;
      let linearOrder = Math.max(0, Math.round(Number(options?.startOrder) || 0));
      const mapping = Array.isArray(data?.mapping) ? data.mapping : [];
      const entries = [];
      mapping.forEach((bucket, bucketIndex) => {
        const rootMidi = Math.max(0, Math.min(127, Math.round(Number(bucket?.rootMidiNote))));
        if (!Number.isFinite(rootMidi)) return;
        const velocityLayer = Math.max(1, Math.min(5, Math.round(Number(bucket?.velocityLayer) || 3)));
        const variants = Array.isArray(bucket?.rrVariants) && bucket.rrVariants.length
          ? bucket.rrVariants
          : [null];

        variants.forEach((variant, rrIndex) => {
          const variantObj = variant && typeof variant === "object" ? variant : {};
          const fallbackName = `${midiToNote(rootMidi)}_V${velocityLayer}_RR${rrIndex + 1}.wav`;
          const fileName = String(
            variantObj.originalFilename
            || variantObj.path
            || fallbackName
          );
          const loopStartNorm = clamp01(variantObj.loopStartNorm ?? 0);
          const loopEndNorm = clamp01(variantObj.loopEndNorm ?? 1);
          const embeddedSampleUrl = typeof variantObj.sampleDataUrl === "string"
            ? String(variantObj.sampleDataUrl).trim()
            : "";
          const entry = {
            fileName,
            order: useVirtualOrder ? state.nextVirtualOrder : linearOrder,
            sampleUrl: embeddedSampleUrl,
            valid: true,
            noteToken: midiToNote(rootMidi),
            rootMidi,
            velocityLayer,
            rrIndex: Number.isFinite(Number(variantObj.rrIndex))
              ? Math.max(1, Math.round(Number(variantObj.rrIndex)))
              : (variants.length > 1 ? rrIndex + 1 : null),
            loopEnabled: !!variantObj.loopEnabled,
            hasVelocityToken: true,
            hasRRToken: variants.length > 1,
            suffixSerial: bucketIndex + 1,
            reason: "",
            fineTuneCents: clampFineTune(variantObj.fineTuneCents ?? 0),
            loopStartNorm,
            loopEndNorm,
            loopFadeInNorm: clamp01(variantObj.loopFadeInNorm ?? loopStartNorm)
          };
          if (useVirtualOrder) {
            state.nextVirtualOrder -= 1;
          } else {
            linearOrder += 1;
          }
          entries.push(entry);
        });
      });
      return entries;
    }

    function importKeyswitchPack(file) {
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(String(reader.result || "{}"));
          const entries = buildKeyswitchEntriesFromManifest(data);
          if (!entries.length) {
            setStatus(el.setupStatus, `No mapping data found in ${file.name}.`, "warn");
            return;
          }

          const rawKey = String(
            data?.keyswitchKey
            || data?.metadata?.keyswitchKey
            || data?.author
            || data?.metadata?.author
            || ""
          ).trim();
          const normalizedKey = normalizeKeyswitchKey(rawKey, suggestUnusedKeyswitchMidi());
          const set = {
            id: `ks_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`,
            name: String(data?.instrumentName || stripFileExtension(file.name) || "Keyswitch").trim(),
            key: normalizedKey.key,
            keyMidi: normalizedKey.keyMidi,
            sourceFile: file.name,
            entries,
            manualRanges: {}
          };

          state.keyswitchSets.push(set);
          state.activeMapSetId = set.id;
          updateKeyswitchMapSelector();
          renderKeyboardMap(undefined, true);
          const duplicates = collectDuplicateKeyswitchKeys();
          if (duplicates.has(set.keyMidi)) {
            setStatus(el.setupStatus, `Imported keyswitch "${set.name}" with duplicate key ${set.key}. Change it in Keyboard Map.`, "warn");
          } else {
            setStatus(el.setupStatus, `Imported keyswitch "${set.name}" (${set.key}) with ${entries.length} sample slot(s).`, "ok");
          }
        } catch {
          setStatus(el.setupStatus, `Could not parse keyswitch file ${file.name}.`, "bad");
        }
      };
      reader.readAsText(file);
    }

    function formatKnobValue(v, unit, decimals) {
      const n = Number(v);
      const fixed = decimals !== null ? n.toFixed(decimals) : (Number.isInteger(n) ? String(n) : n.toFixed(2));
      return unit ? `${fixed} ${unit}` : fixed;
    }

    function rgbToHsv(r, g, b) {
      const rn = r / 255;
      const gn = g / 255;
      const bn = b / 255;
      const max = Math.max(rn, gn, bn);
      const min = Math.min(rn, gn, bn);
      const delta = max - min;
      const s = max === 0 ? 0 : delta / max;
      const v = max;
      return { s, v };
    }

    function mixRgb(a, b, ratio = 0.5) {
      const t = Math.max(0, Math.min(1, Number(ratio) || 0));
      return [
        Math.round((a[0] * (1 - t)) + (b[0] * t)),
        Math.round((a[1] * (1 - t)) + (b[1] * t)),
        Math.round((a[2] * (1 - t)) + (b[2] * t))
      ];
    }

    function luminanceOfRgb(rgb) {
      return (0.2126 * rgb[0]) + (0.7152 * rgb[1]) + (0.0722 * rgb[2]);
    }

    function deriveWheelColorFromSwatch(swatch, dark, light) {
      let wheel = [swatch[0], swatch[1], swatch[2]];
      const lum = luminanceOfRgb(wheel);
      if (lum < 95) {
        wheel = mixRgb(wheel, light, 0.45);
      } else if (lum > 185) {
        wheel = mixRgb(wheel, dark, 0.4);
      }

      const adjustedLum = luminanceOfRgb(wheel);
      if (adjustedLum < 105) wheel = mixRgb(wheel, [170, 174, 182], 0.35);
      if (adjustedLum > 180) wheel = mixRgb(wheel, [160, 166, 174], 0.28);
      return wheel;
    }

    function extractSwatchFromImageFile(file) {
      return new Promise((resolve) => {
        const img = new Image();
        const objectUrl = URL.createObjectURL(file);
        img.onload = () => {
          try {
            const size = 32;
            const canvas = document.createElement("canvas");
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext("2d", { willReadFrequently: true });
            ctx.drawImage(img, 0, 0, size, size);
            const { data } = ctx.getImageData(0, 0, size, size);

            let rSum = 0;
            let gSum = 0;
            let bSum = 0;
            let weightSum = 0;
            const pixels = [];

            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const a = data[i + 3];
              if (a < 96) continue;
              const { s, v } = rgbToHsv(r, g, b);
              const weight = 0.2 + (s * 1.2) + (v * 0.6);
              rSum += r * weight;
              gSum += g * weight;
              bSum += b * weight;
              weightSum += weight;
              const luminance = (0.2126 * r) + (0.7152 * g) + (0.0722 * b);
              pixels.push({ r, g, b, luminance });
            }

            if (weightSum <= 0 || !pixels.length) {
              resolve({
                swatch: [38, 40, 46],
                dark: [38, 40, 46],
                light: [140, 146, 156]
              });
            } else {
              const swatch = [
                Math.round(rSum / weightSum),
                Math.round(gSum / weightSum),
                Math.round(bSum / weightSum)
              ];
              const sampleCount = Math.max(1, Math.round(pixels.length * 0.18));
              const darkestPixels = pixels
                .sort((a, b) => a.luminance - b.luminance)
                .slice(0, sampleCount);
              const darkSum = darkestPixels.reduce((acc, px) => {
                acc.r += px.r;
                acc.g += px.g;
                acc.b += px.b;
                return acc;
              }, { r: 0, g: 0, b: 0 });
              const dark = [
                Math.round(darkSum.r / darkestPixels.length),
                Math.round(darkSum.g / darkestPixels.length),
                Math.round(darkSum.b / darkestPixels.length)
              ];
              const lightestPixels = pixels
                .sort((a, b) => b.luminance - a.luminance)
                .slice(0, sampleCount);
              const lightSum = lightestPixels.reduce((acc, px) => {
                acc.r += px.r;
                acc.g += px.g;
                acc.b += px.b;
                return acc;
              }, { r: 0, g: 0, b: 0 });
              const light = [
                Math.round(lightSum.r / lightestPixels.length),
                Math.round(lightSum.g / lightestPixels.length),
                Math.round(lightSum.b / lightestPixels.length)
              ];
              resolve({ swatch, dark, light });
            }
          } catch {
            resolve({
              swatch: [38, 40, 46],
              dark: [38, 40, 46],
              light: [140, 146, 156]
            });
          } finally {
            URL.revokeObjectURL(objectUrl);
          }
        };
        img.onerror = () => {
          URL.revokeObjectURL(objectUrl);
          resolve({
            swatch: [38, 40, 46],
            dark: [38, 40, 46],
            light: [140, 146, 156]
          });
        };
        img.src = objectUrl;
      });
    }

    function updateTopBarTheme(activeTab = null) {
      if (!el.tabsBar) return;
      const currentTab = activeTab
        || document.querySelector(".tab-btn.active")?.dataset.tab
        || "player";
      const useWallpaperTheme = currentTab === "player" && !!state.wallpaperName;
      el.tabsBar.classList.toggle("player-topbar-swatch", useWallpaperTheme);
    }

    function getPlayerParticleTargetCount(width, height) {
      const area = Math.max(0, width) * Math.max(0, height);
      if (area <= 0) return 0;
      return Math.max(14, Math.min(54, Math.round(area / 26000)));
    }

    function createPlayerParticle(width, height, spawnInside = false) {
      const size = 2.6 + (Math.random() * 3.4);
      return {
        baseX: Math.random() * Math.max(1, width),
        y: spawnInside
          ? (Math.random() * Math.max(1, height))
          : (-(Math.random() * Math.max(12, height * 0.95)) - 8),
        size,
        speed: 18 + (Math.random() * 44),
        drift: 8 + (Math.random() * 22),
        phase: Math.random() * Math.PI * 2,
        rotation: Math.random() * Math.PI * 2,
        spin: (Math.random() < 0.5 ? -1 : 1) * (0.22 + (Math.random() * 0.85)),
        alpha: 0.24 + (Math.random() * 0.42)
      };
    }

    function respawnPlayerParticle(particle, width, height) {
      const reset = createPlayerParticle(width, height, false);
      particle.baseX = reset.baseX;
      particle.y = reset.y;
      particle.size = reset.size;
      particle.speed = reset.speed;
      particle.drift = reset.drift;
      particle.phase = reset.phase;
      particle.rotation = reset.rotation;
      particle.spin = reset.spin;
      particle.alpha = reset.alpha;
    }

    function syncPlayerParticles(width, height, spawnInside = false) {
      const targetCount = getPlayerParticleTargetCount(width, height);
      while (state.playerParticles.length < targetCount) {
        state.playerParticles.push(createPlayerParticle(width, height, spawnInside));
      }
      if (state.playerParticles.length > targetCount) {
        state.playerParticles.length = targetCount;
      }
    }

    function getPlayerParticlesViewportSize() {
      if (!el.playerStage) return { width: 0, height: 0 };
      const rect = el.playerStage.getBoundingClientRect();
      const kbHeight = Number.parseFloat(getComputedStyle(el.playerStage).getPropertyValue("--player-kb-height")) || 0;
      return {
        width: Math.max(0, rect.width),
        height: Math.max(0, rect.height - kbHeight)
      };
    }

    function resizePlayerParticlesCanvas(spawnInside = false) {
      if (!el.playerParticles) return { width: 0, height: 0 };
      const { width, height } = getPlayerParticlesViewportSize();
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      el.playerParticles.style.width = `${width}px`;
      el.playerParticles.style.height = `${height}px`;
      const pixelWidth = Math.max(1, Math.round(width * dpr));
      const pixelHeight = Math.max(1, Math.round(height * dpr));
      if (el.playerParticles.width !== pixelWidth || el.playerParticles.height !== pixelHeight) {
        el.playerParticles.width = pixelWidth;
        el.playerParticles.height = pixelHeight;
      }
      state.playerParticlesDpr = dpr;

      if (!spawnInside) {
        state.playerParticles = [];
      } else {
        state.playerParticles.forEach((particle) => {
          particle.baseX = Math.max(-24, Math.min(width + 24, particle.baseX));
          particle.y = Math.max(-48, Math.min(height + 48, particle.y));
        });
      }
      syncPlayerParticles(width, height, spawnInside);
      return { width, height };
    }

    function drawPlayerParticle(ctx, particle, rgb, glowRgb) {
      const sway = Math.sin((particle.y * 0.016) + particle.phase) * particle.drift;
      const x = particle.baseX + sway;
      const y = particle.y;
      const leafWidth = particle.size;
      const leafHeight = particle.size * 2.2;
      const alpha = particle.alpha;
      const fillRgb = [
        Math.round((rgb[0] * 0.78) + (glowRgb[0] * 0.22)),
        Math.round((rgb[1] * 0.78) + (glowRgb[1] * 0.22)),
        Math.round((rgb[2] * 0.78) + (glowRgb[2] * 0.22))
      ];

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(particle.rotation);
      ctx.shadowColor = `rgba(${glowRgb[0]}, ${glowRgb[1]}, ${glowRgb[2]}, ${Math.min(0.96, alpha)})`;
      ctx.shadowBlur = particle.size * 5.4;
      ctx.fillStyle = `rgba(${fillRgb[0]}, ${fillRgb[1]}, ${fillRgb[2]}, ${Math.min(0.94, alpha + 0.08)})`;
      ctx.beginPath();
      ctx.moveTo(0, -leafHeight * 0.55);
      ctx.bezierCurveTo(leafWidth * 0.68, -leafHeight * 0.22, leafWidth * 0.52, leafHeight * 0.2, 0, leafHeight * 0.56);
      ctx.bezierCurveTo(-leafWidth * 0.52, leafHeight * 0.2, -leafWidth * 0.68, -leafHeight * 0.22, 0, -leafHeight * 0.55);
      ctx.fill();
      ctx.strokeStyle = `rgba(${glowRgb[0]}, ${glowRgb[1]}, ${glowRgb[2]}, ${Math.min(0.9, alpha * 0.6)})`;
      ctx.lineWidth = Math.max(0.55, particle.size * 0.18);
      ctx.beginPath();
      ctx.moveTo(0, -leafHeight * 0.46);
      ctx.lineTo(0, leafHeight * 0.48);
      ctx.stroke();
      ctx.restore();
    }

    function animatePlayerParticlesFrame(ts) {
      if (!state.playerParticlesRunning || !el.playerParticles) {
        state.playerParticlesRaf = 0;
        return;
      }
      const ctx = el.playerParticles.getContext("2d");
      if (!ctx) {
        state.playerParticlesRaf = 0;
        return;
      }

      const { width, height } = getPlayerParticlesViewportSize();
      if (width <= 0 || height <= 0) {
        state.playerParticlesLastTs = ts;
        state.playerParticlesRaf = window.requestAnimationFrame(animatePlayerParticlesFrame);
        return;
      }

      syncPlayerParticles(width, height, true);
      const dpr = state.playerParticlesDpr || 1;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      ctx.clearRect(0, 0, width, height);

      const prevTs = state.playerParticlesLastTs || ts;
      const dt = Math.min(0.05, Math.max(0.001, (ts - prevTs) / 1000));
      state.playerParticlesLastTs = ts;
      const rgb = state.playerParticleRgb || [218, 222, 229];
      const glowRgb = state.playerParticleGlowRgb || rgb;

      state.playerParticles.forEach((particle) => {
        particle.y += particle.speed * dt;
        particle.rotation += particle.spin * dt;
        if (particle.y > (height + (particle.size * 8))) {
          respawnPlayerParticle(particle, width, height);
        }
        drawPlayerParticle(ctx, particle, rgb, glowRgb);
      });

      state.playerParticlesRaf = window.requestAnimationFrame(animatePlayerParticlesFrame);
    }

    function shouldRunPlayerParticles() {
      if (!state.wallpaperName) return false;
      if (!state.playerParticlesEnabled) return false;
      const currentTab = document.querySelector(".tab-btn.active")?.dataset.tab || "player";
      if (currentTab !== "player") return false;
      if (typeof window.matchMedia === "function" && window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
        return false;
      }
      return true;
    }

    function updateParticlesToggle() {
      if (!el.particlesToggle) return;
      const enabled = !!state.playerParticlesEnabled;
      el.particlesToggle.textContent = enabled ? "Particles On" : "Particles Off";
      el.particlesToggle.setAttribute("aria-pressed", enabled ? "true" : "false");
      el.particlesToggle.title = enabled ? "Disable particles" : "Enable particles";
    }

    function updateGodRaysToggle() {
      if (!el.godRaysToggle) return;
      const enabled = !!state.playerGodRaysEnabled;
      el.godRaysToggle.textContent = enabled ? "God Rays On" : "God Rays Off";
      el.godRaysToggle.setAttribute("aria-pressed", enabled ? "true" : "false");
      el.godRaysToggle.title = enabled ? "Disable god rays" : "Enable god rays";
    }

    function updatePlayerGodRaysState() {
      if (!el.playerStage) return;
      el.playerStage.classList.toggle("god-rays-disabled", !state.playerGodRaysEnabled);
    }

    function stopPlayerParticles(hideCanvas = true) {
      state.playerParticlesRunning = false;
      state.playerParticlesLastTs = 0;
      if (state.playerParticlesRaf) {
        window.cancelAnimationFrame(state.playerParticlesRaf);
        state.playerParticlesRaf = 0;
      }
      if (!el.playerParticles) return;
      if (hideCanvas) el.playerParticles.classList.add("hidden");
      const ctx = el.playerParticles.getContext("2d");
      if (ctx) {
        const { width, height } = getPlayerParticlesViewportSize();
        const dpr = state.playerParticlesDpr || 1;
        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        ctx.clearRect(0, 0, width, height);
      }
    }

    function startPlayerParticles() {
      if (!el.playerParticles) return;
      el.playerParticles.classList.remove("hidden");
      // Spawn in-view so the effect is visible immediately (AE-like pre-roll look).
      resizePlayerParticlesCanvas(true);
      state.playerParticlesRunning = true;
      state.playerParticlesLastTs = 0;
      if (!state.playerParticlesRaf) {
        state.playerParticlesRaf = window.requestAnimationFrame(animatePlayerParticlesFrame);
      }
    }

    function refreshPlayerParticles() {
      if (shouldRunPlayerParticles()) {
        startPlayerParticles();
      } else {
        stopPlayerParticles(true);
      }
    }

    function setupPlayerParticles() {
      if (!el.playerParticles) return;
      const onResize = () => {
        if (playerParticlesResizeRaf) return;
        playerParticlesResizeRaf = window.requestAnimationFrame(() => {
          playerParticlesResizeRaf = 0;
          if (!state.playerParticlesRunning) return;
          resizePlayerParticlesCanvas(true);
        });
      };
      window.addEventListener("resize", onResize);
      if (typeof window.matchMedia === "function") {
        const media = window.matchMedia("(prefers-reduced-motion: reduce)");
        const onMediaChange = () => refreshPlayerParticles();
        if (typeof media.addEventListener === "function") {
          media.addEventListener("change", onMediaChange);
        } else if (typeof media.addListener === "function") {
          media.addListener(onMediaChange);
        }
      }
    }

    function isLikelyImageFile(file) {
      if (!file) return false;
      if (file.type && file.type.startsWith("image/")) return true;
      return IMAGE_EXT_REGEX.test(String(file.name || ""));
    }

    let playerControlsHideTimer = 0;
    let playerControlsHovering = false;
    let playerControlsDragging = 0;
    let playerKeyboardResizeRaf = 0;
    let playerParticlesResizeRaf = 0;

    function clearPlayerControlsHideTimer() {
      if (!playerControlsHideTimer) return;
      window.clearTimeout(playerControlsHideTimer);
      playerControlsHideTimer = 0;
    }

    function setPlayerControlsVisible(visible) {
      if (!el.playerControls) return;
      el.playerControls.classList.toggle("force-visible", !!visible);
    }

    function schedulePlayerControlsAutoHide(delayMs = 3000) {
      if (!el.playerControls) return;
      clearPlayerControlsHideTimer();
      playerControlsHideTimer = window.setTimeout(() => {
        playerControlsHideTimer = 0;
        if (playerControlsHovering) return;
        if (playerControlsDragging > 0) return;
        setPlayerControlsVisible(false);
      }, Math.max(0, Number(delayMs) || 0));
    }

    function pulsePlayerControlsVisibility() {
      if (!el.playerControls) return;
      setPlayerControlsVisible(true);
      clearPlayerControlsHideTimer();
      if (!playerControlsHovering && playerControlsDragging === 0) {
        schedulePlayerControlsAutoHide(3000);
      }
    }

    function beginPlayerControlsDrag() {
      if (!el.playerControls) return;
      playerControlsDragging += 1;
      setPlayerControlsVisible(true);
      clearPlayerControlsHideTimer();
    }

    function endPlayerControlsDrag() {
      if (!el.playerControls) return;
      playerControlsDragging = Math.max(0, playerControlsDragging - 1);
      if (!playerControlsHovering && playerControlsDragging === 0) {
        schedulePlayerControlsAutoHide(3000);
      }
    }

    function setupPlayerControlsVisibility() {
      if (!el.playerControls) return;
      el.playerControls.addEventListener("pointerenter", () => {
        playerControlsHovering = true;
        setPlayerControlsVisible(true);
        clearPlayerControlsHideTimer();
      });
      el.playerControls.addEventListener("pointerleave", () => {
        playerControlsHovering = false;
        if (playerControlsDragging === 0) {
          schedulePlayerControlsAutoHide(3000);
        }
      });
      el.playerControls.addEventListener("wheel", () => {
        pulsePlayerControlsVisibility();
      }, { passive: true });
      el.playerControls.addEventListener("focusin", () => {
        playerControlsHovering = true;
        setPlayerControlsVisible(true);
        clearPlayerControlsHideTimer();
      });
      el.playerControls.addEventListener("focusout", () => {
        playerControlsHovering = false;
        if (playerControlsDragging === 0) {
          schedulePlayerControlsAutoHide(3000);
        }
      });
    }

    function updatePerformanceWheelVisuals() {
      const mod = Math.max(0, Math.min(1, Number(state.modWheelValue) || 0));
      const pitch = Math.max(-1, Math.min(1, Number(state.pitchBendValue) || 0));
      if (el.playerModWheelTape) {
        const y = (0.5 - mod) * 120;
        el.playerModWheelTape.style.transform = `translateY(${y}px)`;
      }
      if (el.playerPitchWheelTape) {
        const normalized = (pitch + 1) * 0.5;
        const y = (0.5 - normalized) * 120;
        el.playerPitchWheelTape.style.transform = `translateY(${y}px)`;
      }
      if (el.playerModWheelSlot) el.playerModWheelSlot.setAttribute("aria-valuenow", mod.toFixed(3));
      if (el.playerPitchWheelSlot) el.playerPitchWheelSlot.setAttribute("aria-valuenow", pitch.toFixed(3));
    }

    function setupPerformanceWheels() {
      function bindWheel(slot, mode) {
        if (!slot) return;
        let dragging = false;
        let pointerId = null;
        let lastY = 0;
        let returnAnim = 0;
        const sensitivity = mode === "pitch" ? 0.012 : 0.008;

        function clampValue(v) {
          const n = Number(v) || 0;
          if (mode === "pitch") return Math.max(-1, Math.min(1, n));
          return Math.max(0, Math.min(1, n));
        }

        function getValue() {
          return mode === "pitch" ? state.pitchBendValue : state.modWheelValue;
        }

        function setValue(next) {
          const value = clampValue(next);
          if (mode === "pitch") state.pitchBendValue = value;
          else state.modWheelValue = value;
          updatePerformanceWheelVisuals();
        }

        function stopReturnAnim() {
          if (!returnAnim) return;
          window.cancelAnimationFrame(returnAnim);
          returnAnim = 0;
        }

        function animatePitchReturn() {
          stopReturnAnim();
          const start = state.pitchBendValue;
          const startTs = performance.now();
          const durationMs = 160;
          const step = (now) => {
            const t = Math.max(0, Math.min(1, (now - startTs) / durationMs));
            const eased = 1 - Math.pow(1 - t, 3);
            state.pitchBendValue = start + ((0 - start) * eased);
            updatePerformanceWheelVisuals();
            if (t < 1) returnAnim = window.requestAnimationFrame(step);
            else returnAnim = 0;
          };
          returnAnim = window.requestAnimationFrame(step);
        }

        slot.addEventListener("pointerdown", (ev) => {
          if (typeof ev.button === "number" && ev.button > 0) return;
          ev.preventDefault();
          stopReturnAnim();
          dragging = true;
          pointerId = ev.pointerId;
          lastY = ev.clientY;
          slot.classList.add("dragging");
          if (slot.setPointerCapture) {
            try {
              slot.setPointerCapture(pointerId);
            } catch {}
          }
        });

        slot.addEventListener("pointermove", (ev) => {
          if (!dragging || ev.pointerId !== pointerId) return;
          const dy = lastY - ev.clientY;
          lastY = ev.clientY;
          setValue(getValue() + (dy * sensitivity));
        });

        function release(ev) {
          if (!dragging) return;
          if (ev && ev.pointerId !== pointerId) return;
          dragging = false;
          slot.classList.remove("dragging");
          if (slot.releasePointerCapture && pointerId !== null && slot.hasPointerCapture && slot.hasPointerCapture(pointerId)) {
            try {
              slot.releasePointerCapture(pointerId);
            } catch {}
          }
          pointerId = null;
          if (mode === "pitch") animatePitchReturn();
        }

        slot.addEventListener("pointerup", release);
        slot.addEventListener("pointercancel", release);
        slot.addEventListener("lostpointercapture", release);
      }

      bindWheel(el.playerModWheelSlot, "mod");
      bindWheel(el.playerPitchWheelSlot, "pitch");
      updatePerformanceWheelVisuals();
    }

    function setupPlayerKeyboardSizing() {
      window.addEventListener("resize", () => {
        if (playerKeyboardResizeRaf) return;
        playerKeyboardResizeRaf = window.requestAnimationFrame(() => {
          playerKeyboardResizeRaf = 0;
          renderPlayerKeyboard();
        });
      });
    }

    function setupKnobs() {
      const nodes = Array.from(document.querySelectorAll(".knob"));
      nodes.forEach((node) => {
        const isPlayerControlKnob = !!node.closest(".player-controls");
        const parsedMin = Number(node.dataset.min);
        const parsedMax = Number(node.dataset.max);
        const min = Number.isFinite(parsedMin) ? parsedMin : 0;
        const max = Number.isFinite(parsedMax) ? parsedMax : 1;
        const maxValue = Math.max(min, max);
        const parsedStep = Number(node.dataset.step ?? 1);
        const step = Number.isFinite(parsedStep) && parsedStep > 0 ? parsedStep : 1;
        const unit = node.dataset.unit || "";
        const decimals = node.dataset.decimals ? Number(node.dataset.decimals) : null;
        const param = node.dataset.param || `knob_${Math.random().toString(16).slice(2)}`;
        const pointer = node.querySelector(".knob-pointer");
        const out = node.querySelector(".knob-value");
        const labelNode = node.querySelector(".knob-label");
        const showValueTooltip = param === "gain" || node.dataset.tooltipValue === "true";
        const tooltipLabel = param === "gain"
          ? "Output gain"
          : ((labelNode ? labelNode.textContent : "") || param).trim();
        const initialValue = Number(node.dataset.value);
        let value = Number.isFinite(initialValue) ? initialValue : min;

        function clamp(v) {
          const raw = Number(v);
          const safe = Number.isFinite(raw) ? raw : min;
          const snapped = min + (Math.round((safe - min) / step) * step);
          return Math.min(maxValue, Math.max(min, snapped));
        }

        function angle(v) {
          const t = (v - min) / (maxValue - min || 1);
          return -135 + t * 270;
        }

        function set(v, emit = true) {
          value = clamp(v);
          node.dataset.value = String(value);
          if (pointer) pointer.style.transform = `translate(-50%, -100%) rotate(${angle(value)}deg)`;
          const formatted = formatKnobValue(value, unit, decimals);
          if (out) out.textContent = formatted;
          if (showValueTooltip) {
            const tooltip = `${tooltipLabel}: ${formatted}`;
            node.dataset.tooltip = tooltip;
            node.setAttribute("aria-label", tooltip);
          }
          if (emit) {
            node.dispatchEvent(new CustomEvent("knobchange", { detail: { param, value } }));
          }
        }

        node.addEventListener("wheel", (ev) => {
          ev.preventDefault();
          const dir = ev.deltaY < 0 ? 1 : -1;
          set(value + dir * step);
          if (isPlayerControlKnob) pulsePlayerControlsVisibility();
        }, { passive: false });

        node.addEventListener("pointerdown", (ev) => {
          ev.preventDefault();
          if (isPlayerControlKnob) beginPlayerControlsDrag();
          const startY = ev.clientY;
          const startValue = value;
          const sensitivity = (maxValue - min) / 180;

          function move(moveEv) {
            const delta = startY - moveEv.clientY;
            set(startValue + delta * sensitivity);
          }

          function up() {
            window.removeEventListener("pointermove", move);
            window.removeEventListener("pointerup", up);
            window.removeEventListener("pointercancel", up);
            if (isPlayerControlKnob) endPlayerControlsDrag();
          }

          window.addEventListener("pointermove", move);
          window.addEventListener("pointerup", up);
          window.addEventListener("pointercancel", up);
        });

        node.addEventListener("dblclick", (ev) => {
          if (param !== "gain") return;
          ev.preventDefault();
          set(0);
        });

        set(value, false);
        state.knobs[param] = {
          get: () => value,
          set,
          emit: () => set(value, true)
        };
      });
    }

    function getKnobNumericValue(param, fallback) {
      const knob = state.knobs[param];
      if (!knob || typeof knob.get !== "function") return fallback;
      const value = Number(knob.get());
      return Number.isFinite(value) ? value : fallback;
    }

    function syncAllKnobValues() {
      Object.values(state.knobs).forEach((knob) => {
        if (!knob || typeof knob.emit !== "function") return;
        knob.emit();
      });
    }

    async function setWallpaper(file) {
      if (!isLikelyImageFile(file)) return;
      if (state.wallpaperObjectUrl) URL.revokeObjectURL(state.wallpaperObjectUrl);
      const url = URL.createObjectURL(file);
      state.wallpaperObjectUrl = url;
      state.wallpaperUrl = url;
      state.wallpaperName = file.name;
      if (el.playerStage) el.playerStage.classList.add("has-wallpaper");
      // Show wallpaper/effects immediately; swatch refinement is applied after extract.
      el.playerStage.style.setProperty("--player-wallpaper", `url('${url}')`);
      applyWallpaperPosition(state.wallpaperPosition);
      refreshPlayerParticles();
      const { swatch, dark, light } = await extractSwatchFromImageFile(file);
      const [swatchR, swatchG, swatchB] = swatch;
      const [darkR, darkG, darkB] = dark;
      const [lightR, lightG, lightB] = light;
      const wheelRgb = deriveWheelColorFromSwatch(swatch, dark, light);
      const wheelDarkRgb = mixRgb(wheelRgb, [90, 96, 108], 0.18);
      const glowBaseR = Math.round((swatchR * 0.72) + (lightR * 0.28));
      const glowBaseG = Math.round((swatchG * 0.72) + (lightG * 0.28));
      const glowBaseB = Math.round((swatchB * 0.72) + (lightB * 0.28));
      const glowR = Math.round(glowBaseR + ((255 - glowBaseR) * 0.2));
      const glowG = Math.round(glowBaseG + ((255 - glowBaseG) * 0.2));
      const glowB = Math.round(glowBaseB + ((255 - glowBaseB) * 0.2));
      document.documentElement.style.setProperty("--player-swatch-rgb", `${swatchR}, ${swatchG}, ${swatchB}`);
      document.documentElement.style.setProperty("--player-topbar-rgb", `${darkR}, ${darkG}, ${darkB}`);
      document.documentElement.style.setProperty("--player-line-rgb", `${lightR}, ${lightG}, ${lightB}`);
      document.documentElement.style.setProperty("--player-bright-rgb", `${lightR}, ${lightG}, ${lightB}`);
      document.documentElement.style.setProperty("--player-press-glow-rgb", `${glowR}, ${glowG}, ${glowB}`);
      document.documentElement.style.setProperty("--player-wheel-rgb", `${wheelRgb[0]}, ${wheelRgb[1]}, ${wheelRgb[2]}`);
      document.documentElement.style.setProperty("--player-wheel-rgb-dark", `${wheelDarkRgb[0]}, ${wheelDarkRgb[1]}, ${wheelDarkRgb[2]}`);
      state.playerParticleRgb = [lightR, lightG, lightB];
      state.playerParticleGlowRgb = mixRgb([lightR, lightG, lightB], [255, 255, 255], 0.32);
      document.documentElement.style.setProperty("--player-key-tint-alpha-top", "0.33");
      document.documentElement.style.setProperty("--player-key-tint-alpha-bottom", "0.45");
      document.documentElement.style.setProperty("--player-key-press-tint-alpha-top", "0.46");
      document.documentElement.style.setProperty("--player-key-press-tint-alpha-bottom", "0.6");
      document.documentElement.style.setProperty("--player-key-press-black-alpha-top", "0.38");
      document.documentElement.style.setProperty("--player-key-press-black-alpha-bottom", "0.5");
      setWallpaperMenuOpen(false);
      updateWallpaperToggle();
      updateTopBarTheme();
      refreshPlayerParticles();
    }

    function clearWallpaper() {
      if (state.wallpaperObjectUrl) URL.revokeObjectURL(state.wallpaperObjectUrl);
      state.wallpaperObjectUrl = "";
      state.wallpaperUrl = "";
      state.wallpaperName = "";
      if (el.playerStage) el.playerStage.classList.remove("has-wallpaper");
      el.playerStage.style.removeProperty("--player-wallpaper");
      el.playerStage.style.removeProperty("--player-wallpaper-position");
      document.documentElement.style.setProperty("--player-swatch-rgb", "38, 40, 46");
      document.documentElement.style.setProperty("--player-topbar-rgb", "38, 40, 46");
      document.documentElement.style.setProperty("--player-line-rgb", "140, 146, 156");
      document.documentElement.style.setProperty("--player-bright-rgb", "218, 222, 229");
      document.documentElement.style.setProperty("--player-press-glow-rgb", "218, 222, 229");
      state.playerParticleRgb = [218, 222, 229];
      state.playerParticleGlowRgb = [238, 242, 248];
      document.documentElement.style.setProperty("--player-key-tint-alpha-top", "0");
      document.documentElement.style.setProperty("--player-key-tint-alpha-bottom", "0");
      document.documentElement.style.setProperty("--player-key-press-tint-alpha-top", "0");
      document.documentElement.style.setProperty("--player-key-press-tint-alpha-bottom", "0");
      document.documentElement.style.setProperty("--player-key-press-black-alpha-top", "0");
      document.documentElement.style.setProperty("--player-key-press-black-alpha-bottom", "0");
      updateWheelBaseTheme();
      el.wallpaperInput.value = "";
      setWallpaperMenuOpen(false);
      updateWallpaperToggle();
      updateTopBarTheme();
      refreshPlayerParticles();
    }

    function updateWheelBaseTheme() {
      if (state.wallpaperName) return;
      const hasSamples = state.entries.some((entry) => entry.valid && !!entry.sampleUrl);
      if (hasSamples) {
        document.documentElement.style.setProperty("--player-wheel-rgb", "236, 239, 244");
        document.documentElement.style.setProperty("--player-wheel-rgb-dark", "214, 218, 224");
      } else {
        document.documentElement.style.setProperty("--player-wheel-rgb", "69, 75, 84");
        document.documentElement.style.setProperty("--player-wheel-rgb-dark", "44, 49, 56");
      }
    }

    function updateWallpaperToggle() {
      const hasWallpaper = !!state.wallpaperName;
      el.wallpaperToggle.textContent = hasWallpaper ? "Position Wallpaper" : "Add Wallpaper";
      el.wallpaperToggle.setAttribute("aria-label", hasWallpaper ? "Wallpaper position menu" : "Add wallpaper");
      el.wallpaperToggle.title = hasWallpaper ? "Wallpaper position menu" : "Add wallpaper";
      el.wallpaperToggle.setAttribute("aria-haspopup", "menu");
      el.wallpaperToggle.setAttribute("aria-expanded", String(hasWallpaper && state.wallpaperMenuOpen));
    }

    function normalizeWallpaperPosition(position) {
      const valid = new Set([
        "top-left",
        "top-center",
        "top-right",
        "middle-left",
        "middle-center",
        "middle-right",
        "bottom-left",
        "bottom-center",
        "bottom-right"
      ]);
      return valid.has(position) ? position : "middle-center";
    }

    function normalizeLogoPosition(position) {
      const alias = {
        "middle-left": "top-left",
        "middle-center": "top-center",
        "middle-right": "top-right",
        "bottom-left": "top-left",
        "bottom-center": "top-center",
        "bottom-right": "top-right"
      };
      const normalizedInput = alias[position] || position;
      const valid = new Set([
        "top-left",
        "top-center",
        "top-right"
      ]);
      return valid.has(normalizedInput) ? normalizedInput : "top-left";
    }

    function syncGraphicsMenuOverflowState() {
      if (!el.importPackControls) return;
      const hasOpenMenu = !!state.logoMenuOpen || !!state.wallpaperMenuOpen;
      el.importPackControls.classList.toggle("logo-menu-open", hasOpenMenu);
    }

    function setWallpaperMenuOpen(open) {
      if (!el.wallpaperPositionMenu) return;
      const next = !!open && !!state.wallpaperName;
      state.wallpaperMenuOpen = next;
      el.wallpaperPositionMenu.classList.toggle("hidden", !next);
      syncGraphicsMenuOverflowState();
      if (el.wallpaperToggle) el.wallpaperToggle.setAttribute("aria-expanded", String(next));
    }

    function updateWallpaperPositionMenu() {
      if (!el.wallpaperPositionButtons || !el.wallpaperPositionButtons.length) return;
      const current = normalizeWallpaperPosition(state.wallpaperPosition);
      el.wallpaperPositionButtons.forEach((btn) => {
        const isActive = btn.dataset.wallpaperPos === current;
        btn.classList.toggle("active", isActive);
        btn.setAttribute("aria-pressed", String(isActive));
      });
    }

    function applyWallpaperPosition(position) {
      const normalized = normalizeWallpaperPosition(position);
      state.wallpaperPosition = normalized;
      if (!el.playerStage) return;

      const map = {
        "top-left": "left top",
        "top-center": "center top",
        "top-right": "right top",
        "middle-left": "left center",
        "middle-center": "center center",
        "middle-right": "right center",
        "bottom-left": "left bottom",
        "bottom-center": "center bottom",
        "bottom-right": "right bottom"
      };

      const cssPos = map[normalized] || "center center";
      el.playerStage.style.setProperty("--player-wallpaper-position", cssPos);
      updateWallpaperPositionMenu();
    }

    function setLogoMenuOpen(open) {
      if (!el.logoPositionMenu) return;
      const next = !!open && !!state.logoName;
      state.logoMenuOpen = next;
      el.logoPositionMenu.classList.toggle("hidden", !next);
      syncGraphicsMenuOverflowState();
      if (el.logoToggle) el.logoToggle.setAttribute("aria-expanded", String(next));
    }

    function updateLogoPositionMenu() {
      if (!el.logoPositionButtons || !el.logoPositionButtons.length) return;
      const current = normalizeLogoPosition(state.logoPosition);
      el.logoPositionButtons.forEach((btn) => {
        const isActive = btn.dataset.logoPos === current;
        btn.classList.toggle("active", isActive);
        btn.setAttribute("aria-pressed", String(isActive));
      });
    }

    function applyLogoPosition(position) {
      const normalized = normalizeLogoPosition(position);
      state.logoPosition = normalized;
      if (!el.playerLogoWrap) return;

      const col = normalized.endsWith("-left")
        ? "left"
        : normalized.endsWith("-center")
          ? "center"
          : "right";

      const top = "12px";
      const bottom = "auto";
      const left = col === "left" ? "12px" : col === "center" ? "50%" : "auto";
      const right = col === "right" ? "12px" : "auto";

      let transform = "none";
      if (col === "center") transform = "translateX(-50%)";

      el.playerLogoWrap.style.setProperty("--player-logo-top", top);
      el.playerLogoWrap.style.setProperty("--player-logo-bottom", bottom);
      el.playerLogoWrap.style.setProperty("--player-logo-left", left);
      el.playerLogoWrap.style.setProperty("--player-logo-right", right);
      el.playerLogoWrap.style.setProperty("--player-logo-transform", transform);
      updateLogoPositionMenu();
    }

    function setLogo(file) {
      if (!isLikelyImageFile(file)) return;
      if (state.logoObjectUrl) URL.revokeObjectURL(state.logoObjectUrl);
      const url = URL.createObjectURL(file);
      state.logoObjectUrl = url;
      state.logoUrl = url;
      state.logoName = file.name;
      if (el.playerLogo) {
        el.playerLogo.src = url;
        el.playerLogo.alt = `Instrument logo ${file.name}`;
      }
      if (el.playerLogoWrap) {
        el.playerLogoWrap.classList.remove("hidden");
      }
      applyLogoPosition(state.logoPosition);
      setLogoMenuOpen(false);
      updateLogoToggle();
    }

    function clearLogo() {
      if (state.logoObjectUrl) URL.revokeObjectURL(state.logoObjectUrl);
      state.logoObjectUrl = "";
      state.logoUrl = "";
      state.logoName = "";
      if (el.playerLogo) {
        el.playerLogo.removeAttribute("src");
        el.playerLogo.alt = "";
      }
      if (el.playerLogoWrap) {
        el.playerLogoWrap.classList.add("hidden");
      }
      if (el.logoInput) el.logoInput.value = "";
      setLogoMenuOpen(false);
      updateLogoToggle();
      updateLogoPositionMenu();
    }

    function updateLogoToggle() {
      if (!el.logoToggle) return;
      const hasLogo = !!state.logoName;
      el.logoToggle.textContent = hasLogo ? "Position Logo" : "Add Logo";
      el.logoToggle.setAttribute("aria-label", hasLogo ? "Logo position menu" : "Add logo");
      el.logoToggle.title = hasLogo ? "Logo position menu" : "Add logo";
      el.logoToggle.setAttribute("aria-haspopup", "menu");
      el.logoToggle.setAttribute("aria-expanded", String(!!state.logoMenuOpen));
    }

    function updatePlayerEmptyState() {
      const hasKeyswitchEntries = (state.keyswitchSets || []).some((set) => (
        Array.isArray(set?.entries) && set.entries.length > 0
      ));
      const show = state.entries.length === 0 && !state.packLoaded && !hasKeyswitchEntries;
      el.playerEmptyState.classList.toggle("hidden", !show);
      updateWheelBaseTheme();
      renderPlayerKeyboard();
    }

    function assignImplicitVelocityLayers() {
      const groups = new Map();
      state.entries.forEach((entry) => {
        if (!entry.valid) return;
        if (entry.hasVelocityToken || entry.hasRRToken) return;
        const key = String(entry.rootMidi);
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(entry);
      });

      groups.forEach((group) => {
        if (group.length === 1) {
          group[0].velocityLayer = 3;
          group[0].rrIndex = null;
          return;
        }

        group.sort((a, b) => {
          const aSuffix = a.suffixSerial ?? -1;
          const bSuffix = b.suffixSerial ?? -1;
          if (aSuffix !== bSuffix) return aSuffix - bSuffix;
          return a.order - b.order;
        });

        const maxIndex = Math.max(1, group.length - 1);
        group.forEach((entry, index) => {
          entry.velocityLayer = 1 + Math.round((index * 4) / maxIndex);
          entry.rrIndex = null;
        });
      });
    }

    function getKeyboardMapBounds(validEntries) {
      if (!validEntries.length) {
        return { minStart: 0, maxStart: 120 };
      }
      const roots = validEntries.map((entry) => entry.rootMidi);
      const minRoot = Math.min(...roots);
      const maxRoot = Math.max(...roots);
      const minStart = Math.max(0, (Math.floor(minRoot / 12) * 12) - 12);
      const maxStart = Math.min(120, (Math.floor(maxRoot / 12) * 12) + 12);
      return {
        minStart,
        maxStart: Math.max(minStart, maxStart)
      };
    }

    function getMappedSampleRoots(validEntries = state.entries) {
      return Array.from(new Set(
        validEntries
          .filter((entry) => entry.valid && !!entry.sampleUrl)
          .map((entry) => entry.rootMidi)
      )).sort((a, b) => a - b);
    }

    function getRootRangeLimits(rootMidi, sortedRoots) {
      const idx = sortedRoots.indexOf(rootMidi);
      if (idx < 0) {
        return { minLow: Math.max(0, rootMidi), maxHigh: Math.min(127, rootMidi) };
      }
      const prevRoot = idx > 0 ? sortedRoots[idx - 1] : null;
      const nextRoot = idx < sortedRoots.length - 1 ? sortedRoots[idx + 1] : null;
      return {
        minLow: prevRoot === null ? 0 : prevRoot + 1,
        maxHigh: nextRoot === null ? 127 : nextRoot - 1
      };
    }

    function getResolvedRootRanges(validEntries = state.entries, manualRanges = state.manualRootRanges) {
      const roots = getMappedSampleRoots(validEntries);
      const rootSet = new Set(roots);
      const store = (manualRanges && typeof manualRanges === "object") ? manualRanges : state.manualRootRanges;
      Object.keys(store).forEach((key) => {
        const midi = Number(key);
        if (!rootSet.has(midi)) delete store[key];
      });

      const rangesByRoot = new Map();
      roots.forEach((rootMidi, idx) => {
        const { minLow, maxHigh } = getRootRangeLimits(rootMidi, roots);
        const defaultLow = idx === 0 ? rootMidi : roots[idx - 1] + 1;
        const defaultHigh = rootMidi;
        const saved = store[rootMidi] || {};
        const lowRaw = Number.isFinite(saved.low) ? Math.round(saved.low) : defaultLow;
        const highRaw = Number.isFinite(saved.high) ? Math.round(saved.high) : defaultHigh;
        const low = Math.max(minLow, Math.min(rootMidi, lowRaw));
        const high = Math.max(rootMidi, Math.min(maxHigh, highRaw));
        store[rootMidi] = { low, high };
        rangesByRoot.set(rootMidi, { low, high, minLow, maxHigh });
      });

      return { roots, rangesByRoot };
    }

    function setManualRangeForRoot(rootMidi, low, high, sortedRoots = null, manualRanges = state.manualRootRanges) {
      const roots = Array.isArray(sortedRoots) ? sortedRoots : getMappedSampleRoots();
      if (!roots.length || !roots.includes(rootMidi)) return null;
      const { minLow, maxHigh } = getRootRangeLimits(rootMidi, roots);
      const clampedLow = Math.max(minLow, Math.min(rootMidi, Math.round(Number(low) || rootMidi)));
      const clampedHigh = Math.max(rootMidi, Math.min(maxHigh, Math.round(Number(high) || rootMidi)));
      const range = { low: clampedLow, high: clampedHigh, minLow, maxHigh };
      const store = (manualRanges && typeof manualRanges === "object") ? manualRanges : state.manualRootRanges;
      store[rootMidi] = { low: range.low, high: range.high };
      return range;
    }

    function getMapEntryByOrder(order) {
      if (!Number.isFinite(order)) return null;
      const activeEntries = getActiveMapEntries();
      const source = activeEntries.length ? activeEntries : state.entries;
      return source.find((entry) => (
        entry.valid
        && !!entry.sampleUrl
        && entry.order === order
      )) || null;
    }

    function clamp01(v) {
      return Math.max(0, Math.min(1, Number(v) || 0));
    }

    function clampFineTune(v) {
      return Math.max(-100, Math.min(100, Math.round(Number(v) || 0)));
    }

    function clampLoopCrossfadeMs(v) {
      return Math.max(0, Math.min(500, Math.round(Number(v) || 0)));
    }

    function clampVelocityCrossfadePercent(v) {
      return Number(v) > 0 ? 30 : 0;
    }

    function clampSampleGainDb(v) {
      return Math.max(-24, Math.min(24, Number(v) || 0));
    }

    function clampAutoInterval(v) {
      return Math.max(1, Math.min(12, Math.round(Number(v) || 1)));
    }

    function getAutoInterval() {
      return clampAutoInterval(el.autoIntervalValue?.value ?? 1);
    }

    function setAutoIntervalValue(next, shouldRender = true) {
      const value = clampAutoInterval(next);
      if (el.autoIntervalValue) el.autoIntervalValue.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function clampAutoVelocityLayers(v) {
      return Math.max(1, Math.min(5, Math.round(Number(v) || 1)));
    }

    function getAutoVelocityLayers() {
      return clampAutoVelocityLayers(el.autoVelValue?.value ?? 1);
    }

    function setAutoVelocityLayers(next, shouldRender = true) {
      const value = clampAutoVelocityLayers(next);
      if (el.autoVelValue) el.autoVelValue.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function clampAutoRRPerNote(v) {
      return Math.max(1, Math.min(8, Math.round(Number(v) || 1)));
    }

    function getAutoRRPerNote() {
      return clampAutoRRPerNote(el.autoRRValue?.value ?? 1);
    }

    function setAutoRRPerNote(next, shouldRender = true) {
      const value = clampAutoRRPerNote(next);
      if (el.autoRRValue) el.autoRRValue.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function clampAutoMs(v, min = 0, max = 60000) {
      return Math.max(min, Math.min(max, Math.round(Number(v) || 0)));
    }

    function getAutoHoldMs() {
      return clampAutoMs(el.autoHoldMs?.value ?? 1, 1, 60000);
    }

    function setAutoHoldMs(next, shouldRender = true) {
      const value = clampAutoMs(next, 1, 60000);
      if (el.autoHoldMs) el.autoHoldMs.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function getAutoTailMs() {
      return clampAutoMs(el.autoTailMs?.value ?? 0, 0, 60000);
    }

    function setAutoTailMs(next, shouldRender = true) {
      const value = clampAutoMs(next, 0, 60000);
      if (el.autoTailMs) el.autoTailMs.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function getAutoPrerollMs() {
      return clampAutoMs(el.autoPrerollMs?.value ?? 0, 0, 60000);
    }

    function setAutoPrerollMs(next, shouldRender = true) {
      const value = clampAutoMs(next, 0, 60000);
      if (el.autoPrerollMs) el.autoPrerollMs.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function clampAutoPercent(v) {
      return Math.max(0, Math.min(100, Math.round(Number(v) || 0)));
    }

    function getAutoLoopStartPercent() {
      return clampAutoPercent(el.autoLoopStartPct?.value ?? 0);
    }

    function setAutoLoopStartPercent(next, shouldRender = true) {
      const value = clampAutoPercent(next);
      if (el.autoLoopStartPct) el.autoLoopStartPct.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function getAutoLoopEndPercent() {
      return clampAutoPercent(el.autoLoopEndPct?.value ?? 100);
    }

    function setAutoLoopEndPercent(next, shouldRender = true) {
      const value = clampAutoPercent(next);
      if (el.autoLoopEndPct) el.autoLoopEndPct.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function getAutoLoopCrossfadeMs() {
      return clampAutoMs(el.autoLoopCrossfadeMs?.value ?? 0, 0, 60000);
    }

    function setAutoLoopCrossfadeMs(next, shouldRender = true) {
      const value = clampAutoMs(next, 0, 60000);
      if (el.autoLoopCrossfadeMs) el.autoLoopCrossfadeMs.value = String(value);
      if (shouldRender) renderAuto();
      return value;
    }

    function updateAutoLoopDetailsVisibility() {
      if (!el.autoLoopDetails) return;
      const show = !!el.autoLoop?.checked;
      el.autoLoopDetails.classList.toggle("hidden", !show);
      scheduleHostResizeForActiveTab();
    }

    function getPackCheckByExt(ext) {
      const token = String(ext || "").trim().toLowerCase();
      return (el.autoPackChecks || []).find((node) => (
        String(node.dataset.packExt || "").trim().toLowerCase() === token
      )) || null;
    }

    function isKeyswitchPackEnabled() {
      return !!el.autoPackKeyswitchCheck?.checked;
    }

    function updateKeyswitchMetaLabels() {
      const keyswitchEnabled = isKeyswitchPackEnabled();
      if (el.autoInstrumentLabel) {
        el.autoInstrumentLabel.textContent = keyswitchEnabled ? "Keyswitch Name" : "Instrument Name";
      }
      if (el.autoAuthorLabel) {
        el.autoAuthorLabel.textContent = keyswitchEnabled ? "Keyswitch Key" : "Author";
      }
      if (el.autoAuthor) {
        el.autoAuthor.placeholder = keyswitchEnabled ? "C0" : "";
        if (keyswitchEnabled) {
          el.autoAuthor.setAttribute("maxlength", "3");
        } else {
          el.autoAuthor.removeAttribute("maxlength");
        }
      }
    }

    function normalizeKeyswitchKeyInput(shouldRender = true) {
      if (!el.autoAuthor || !isKeyswitchPackEnabled()) return "";
      const raw = String(el.autoAuthor.value || "").trim().toUpperCase();
      if (!raw) {
        if (shouldRender) renderAuto();
        return "";
      }
      const midi = noteToMidi(raw);
      const normalized = midi === null ? "C0" : midiToNote(midi);
      if (el.autoAuthor.value !== normalized) el.autoAuthor.value = normalized;
      if (shouldRender) renderAuto();
      return normalized;
    }

    function applyPackFormatRules(shouldRender = true) {
      const keyswitchEnabled = isKeyswitchPackEnabled();
      const checks = el.autoPackChecks || [];
      checks.forEach((node) => {
        const ext = String(node.dataset.packExt || "").trim().toLowerCase();
        const isKeyswitch = ext === "keyswitch";
        if (!isKeyswitch && keyswitchEnabled) {
          node.checked = false;
        }
        node.disabled = !isKeyswitch && keyswitchEnabled;
        const row = node.closest(".auto-pack-check");
        if (row) row.classList.toggle("disabled", node.disabled);
      });

      if (!keyswitchEnabled) {
        const hasAnySelected = checks.some((node) => (
          !node.disabled && !!node.checked
        ));
        if (!hasAnySelected) {
          const native = getPackCheckByExt("smpinst");
          if (native) native.checked = true;
        }
      } else {
        normalizeKeyswitchKeyInput(false);
      }

      updateKeyswitchMetaLabels();
      if (shouldRender) renderAuto();
    }

    function getAutoPresetSettingsSnapshot() {
      const startMidi = normalizeAutoNoteInput(el.autoStart, 36, false);
      const endMidi = normalizeAutoNoteInput(el.autoEnd, 72, false);
      return {
        startNote: midiToNote(startMidi ?? 36),
        endNote: midiToNote(endMidi ?? 72),
        sampleInterval: getAutoInterval(),
        velocityLayers: getAutoVelocityLayers(),
        roundRobin: getAutoRRPerNote(),
        sustainMs: getAutoHoldMs(),
        releaseTailMs: getAutoTailMs(),
        prerollMs: getAutoPrerollMs(),
        loopSamples: !!el.autoLoop?.checked,
        autoLoop: !!el.autoLoopMode?.checked,
        loopStartPercent: getAutoLoopStartPercent(),
        loopEndPercent: getAutoLoopEndPercent(),
        cutLoopAtEnd: !!el.autoLoopCutAtEnd?.checked,
        loopCrossfadeMs: getAutoLoopCrossfadeMs(),
        normalizeRecorded: !!el.autoNormalizeRecorded?.checked
      };
    }

    function normalizeAutoPresetRecord(rawPreset, fallbackIndex = 0) {
      if (!rawPreset || typeof rawPreset !== "object") return null;
      const sourceSettings = (rawPreset.settings && typeof rawPreset.settings === "object")
        ? rawPreset.settings
        : rawPreset;
      const fallbackName = `Preset ${fallbackIndex + 1}`;
      const name = String(rawPreset.name || fallbackName).trim() || fallbackName;
      const startMidi = noteToMidi(sourceSettings.startNote);
      const endMidi = noteToMidi(sourceSettings.endNote);
      return {
        id: String(rawPreset.id || `preset_${Date.now()}_${fallbackIndex}`),
        name,
        settings: {
          startNote: midiToNote(startMidi === null ? 36 : startMidi),
          endNote: midiToNote(endMidi === null ? 72 : endMidi),
          sampleInterval: clampAutoInterval(sourceSettings.sampleInterval),
          velocityLayers: clampAutoVelocityLayers(sourceSettings.velocityLayers),
          roundRobin: clampAutoRRPerNote(sourceSettings.roundRobin),
          sustainMs: clampAutoMs(sourceSettings.sustainMs, 1, 60000),
          releaseTailMs: clampAutoMs(sourceSettings.releaseTailMs, 0, 60000),
          prerollMs: clampAutoMs(sourceSettings.prerollMs, 0, 60000),
          loopSamples: !!sourceSettings.loopSamples,
          autoLoop: !!sourceSettings.autoLoop,
          loopStartPercent: clampAutoPercent(sourceSettings.loopStartPercent),
          loopEndPercent: clampAutoPercent(sourceSettings.loopEndPercent),
          cutLoopAtEnd: !!sourceSettings.cutLoopAtEnd,
          loopCrossfadeMs: clampAutoMs(sourceSettings.loopCrossfadeMs, 0, 60000),
          normalizeRecorded: !!sourceSettings.normalizeRecorded
        }
      };
    }

    function loadAutoPresetsFromStorage() {
      try {
        const raw = window.localStorage.getItem(AUTO_PRESET_STORAGE_KEY);
        if (!raw) return [];
        const parsed = JSON.parse(raw);
        if (!Array.isArray(parsed)) return [];
        return parsed
          .map((preset, index) => normalizeAutoPresetRecord(preset, index))
          .filter(Boolean);
      } catch {
        return [];
      }
    }

    function saveAutoPresetsToStorage() {
      try {
        window.localStorage.setItem(AUTO_PRESET_STORAGE_KEY, JSON.stringify(state.autoPresets || []));
      } catch {
        // ignore storage failures
      }
    }

    function applyAutoPresetSettings(presetSettings) {
      const settings = normalizeAutoPresetRecord({ settings: presetSettings }, 0)?.settings;
      if (!settings) return;
      if (el.autoStart) el.autoStart.value = settings.startNote;
      if (el.autoEnd) el.autoEnd.value = settings.endNote;
      normalizeAutoNoteInput(el.autoStart, 36, false);
      normalizeAutoNoteInput(el.autoEnd, 72, false);
      setAutoIntervalValue(settings.sampleInterval, false);
      setAutoVelocityLayers(settings.velocityLayers, false);
      setAutoRRPerNote(settings.roundRobin, false);
      setAutoHoldMs(settings.sustainMs, false);
      setAutoTailMs(settings.releaseTailMs, false);
      setAutoPrerollMs(settings.prerollMs, false);
      if (el.autoLoop) el.autoLoop.checked = settings.loopSamples;
      if (el.autoLoopMode) el.autoLoopMode.checked = settings.autoLoop;
      setAutoLoopStartPercent(settings.loopStartPercent, false);
      setAutoLoopEndPercent(settings.loopEndPercent, false);
      if (el.autoLoopCutAtEnd) el.autoLoopCutAtEnd.checked = settings.cutLoopAtEnd;
      setAutoLoopCrossfadeMs(settings.loopCrossfadeMs, false);
      if (el.autoNormalizeRecorded) el.autoNormalizeRecorded.checked = settings.normalizeRecorded;
      updateAutoLoopDetailsVisibility();
      renderAuto();
    }

    function renderAutoPresetList() {
      if (!el.autoPresetList) return;
      el.autoPresetList.innerHTML = "";
      const presets = Array.isArray(state.autoPresets) ? state.autoPresets : [];
      if (!presets.length) {
        const empty = document.createElement("div");
        empty.className = "auto-preset-empty";
        empty.textContent = "No presets";
        el.autoPresetList.appendChild(empty);
        return;
      }

      presets.forEach((preset) => {
        const row = document.createElement("div");
        row.className = "auto-preset-row";

        const loadBtn = document.createElement("button");
        loadBtn.type = "button";
        loadBtn.className = "sample-loop-tool-btn auto-preset-item";
        loadBtn.textContent = preset.name;
        loadBtn.title = `Load preset ${preset.name}`;
        loadBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          applyAutoPresetSettings(preset.settings);
          if (el.autoPresetMenu) el.autoPresetMenu.classList.add("hidden");
          if (el.autoPresetBtn) el.autoPresetBtn.setAttribute("aria-expanded", "false");
        });

        const deleteBtn = document.createElement("button");
        deleteBtn.type = "button";
        deleteBtn.className = "sample-loop-tool-btn auto-preset-delete-btn";
        deleteBtn.textContent = "x";
        deleteBtn.title = `Delete preset ${preset.name}`;
        deleteBtn.setAttribute("aria-label", `Delete preset ${preset.name}`);
        deleteBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          ev.stopPropagation();
          const targetId = String(preset.id || "");
          state.autoPresets = (state.autoPresets || []).filter((item) => (
            String(item.id || "") !== targetId
          ));
          saveAutoPresetsToStorage();
          renderAutoPresetList();
        });

        row.append(loadBtn, deleteBtn);
        el.autoPresetList.appendChild(row);
      });
    }

    function formatDurationMs(ms) {
      const totalSeconds = Math.max(0, Math.round((Number(ms) || 0) / 1000));
      const h = Math.floor(totalSeconds / 3600);
      const m = Math.floor((totalSeconds % 3600) / 60);
      const s = totalSeconds % 60;
      if (h > 0) return `${h}:${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
      return `${m}:${String(s).padStart(2, "0")}`;
    }

    function formatFileSize(bytes) {
      const value = Number(bytes) || 0;
      if (value <= 0) return "0 B";
      const units = ["B", "KB", "MB", "GB", "TB"];
      let unitIndex = 0;
      let size = value;
      while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex += 1;
      }
      const precision = size >= 100 || unitIndex === 0 ? 0 : (size >= 10 ? 1 : 2);
      return `${size.toFixed(precision)} ${units[unitIndex]}`;
    }

    function formatSampleRate(sampleRate) {
      const hz = Math.max(1, Number(sampleRate) || 44100);
      const khz = hz / 1000;
      const precision = Math.abs(Math.round(khz) - khz) < 0.05 ? 0 : 1;
      return `${khz.toFixed(precision)} kHz`;
    }

    function getAutoRenderSampleRate() {
      if (state.audioContext && Number.isFinite(state.audioContext.sampleRate) && state.audioContext.sampleRate > 0) {
        return state.audioContext.sampleRate;
      }
      try {
        const ctx = ensureAudioContext();
        if (ctx && Number.isFinite(ctx.sampleRate) && ctx.sampleRate > 0) return ctx.sampleRate;
      } catch {
        // fallback handled below
      }
      return 44100;
    }

    function mergeFolderNameIntoPath(currentPath, folderName) {
      const name = String(folderName || "").trim();
      if (!name) return String(currentPath || "");
      const base = String(currentPath || "").trim();
      if (!base) return name;
      const slashIdx = base.lastIndexOf("/");
      const backslashIdx = base.lastIndexOf("\\");
      const splitIdx = Math.max(slashIdx, backslashIdx);
      if (splitIdx < 0) return name;
      return `${base.slice(0, splitIdx + 1)}${name}`;
    }

    function normalizeAutoNoteInput(input, fallbackMidi = 60, shouldRender = false) {
      if (!input) return null;
      const parsed = noteToMidi(input.value);
      const fallback = Math.max(0, Math.min(127, Math.round(Number(fallbackMidi) || 60)));
      const midi = parsed === null ? fallback : parsed;
      const normalized = midiToNote(midi);
      if (input.value !== normalized) input.value = normalized;
      if (shouldRender) renderAuto();
      return midi;
    }

    function stepAutoNoteInput(input, delta, fallbackMidi = 60) {
      if (!input) return null;
      const current = normalizeAutoNoteInput(input, fallbackMidi, false);
      const stepped = Math.max(0, Math.min(127, (current ?? fallbackMidi) + (Number(delta) || 0)));
      input.value = midiToNote(stepped);
      renderAuto();
      return stepped;
    }

    function getVelocityCrossfadePercentForRoot(rootMidi) {
      if (!Number.isFinite(rootMidi)) return 0;
      const key = String(Math.round(rootMidi));
      if (Object.prototype.hasOwnProperty.call(state.velocityCrossfadeByRoot, key)) {
        return Number(state.velocityCrossfadeByRoot[key]) > 0 ? 30 : 0;
      }
      return 0;
    }

    function setVelocityCrossfadePercentForRoot(rootMidi, nextPercent) {
      if (!Number.isFinite(rootMidi)) return 0;
      const key = String(Math.round(rootMidi));
      const normalized = clampVelocityCrossfadePercent(nextPercent);
      state.velocityCrossfadeByRoot[key] = normalized;
      state.velocityCrossfadePercent = normalized;
      return normalized;
    }

    function ensureEntryEditorState(entry) {
      if (!entry) return;
      entry.fineTuneCents = clampFineTune(entry.fineTuneCents ?? 0);
      entry.editorGainDb = clampSampleGainDb(entry.editorGainDb ?? 0);
      entry.loopStartNorm = clamp01(entry.loopStartNorm ?? 0);
      entry.loopEndNorm = clamp01(entry.loopEndNorm ?? 1);
      entry.loopFadeInNorm = clamp01(entry.loopFadeInNorm ?? entry.loopStartNorm ?? 0);
      const minGap = 0.002;
      if (entry.loopEndNorm < entry.loopStartNorm + minGap) {
        entry.loopEndNorm = Math.min(1, entry.loopStartNorm + minGap);
      }
      if (entry.loopFadeInNorm > entry.loopStartNorm) {
        entry.loopFadeInNorm = entry.loopStartNorm;
      }
    }

    function isEntryLoopRegionActive(entry) {
      if (!entry) return false;
      ensureEntryEditorState(entry);
      return entry.loopStartNorm > 0.001 || entry.loopEndNorm < 0.999;
    }

    function getCachedDurationForEntry(entry) {
      if (!entry || !entry.sampleUrl) return null;
      const waveform = state.waveformCache.get(entry.sampleUrl);
      if (!waveform) return null;
      return Number.isFinite(waveform.durationSec) ? waveform.durationSec : null;
    }

    function getEntryLoopTimes(entry, durationSec) {
      ensureEntryEditorState(entry);
      const movedLoop = isEntryLoopRegionActive(entry);
      const active = movedLoop;
      const minLenSec = 0.01;
      const duration = Math.max(minLenSec, Number(durationSec) || minLenSec);
      const startNorm = movedLoop ? entry.loopStartNorm : 0;
      const endNorm = movedLoop ? entry.loopEndNorm : 1;
      const fadeNorm = movedLoop ? Math.min(entry.loopFadeInNorm ?? entry.loopStartNorm, startNorm) : startNorm;
      const startSec = Math.max(0, Math.min(duration - minLenSec, startNorm * duration));
      const endSec = Math.max(startSec + minLenSec, Math.min(duration, endNorm * duration));
      const fadeStartSec = Math.max(0, Math.min(startSec, fadeNorm * duration));
      return {
        active,
        startSec,
        endSec,
        fadeStartSec,
        crossfadeSec: Math.max(0, startSec - fadeStartSec)
      };
    }

    function getSampleEditorMeta(entry, durationSec = null) {
      ensureEntryEditorState(entry);
      const rr = entry.rrIndex === null ? "auto" : String(entry.rrIndex);
      const parts = [
        `root:${midiToNote(entry.rootMidi)}`,
        `V${entry.velocityLayer}`,
        `RR:${rr}`
      ];
      const fineTune = clampFineTune(entry.fineTuneCents ?? 0);
      parts.push(`tune:${fineTune >= 0 ? "+" : ""}${fineTune}c`);
      if (isEntryLoopRegionActive(entry)) {
        const startPct = (entry.loopStartNorm * 100).toFixed(1);
        const endPct = (entry.loopEndNorm * 100).toFixed(1);
        parts.push(`loop:${startPct}-${endPct}%`);
        if (Number.isFinite(durationSec)) {
          const xfadeMs = Math.round(Math.max(0, (entry.loopStartNorm - entry.loopFadeInNorm) * durationSec * 1000));
          if (xfadeMs > 0) parts.push(`xfade:${xfadeMs}ms`);
        }
      }
      if (Number.isFinite(durationSec)) parts.push(`${durationSec.toFixed(2)}s`);
      return parts.join(" | ");
    }

    function refreshSelectedSampleMeta() {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry) return;
      el.sampleEditorMeta.textContent = getSampleEditorMeta(entry, getCachedDurationForEntry(entry));
    }

    function syncSelectedMapSampleBox() {
      const selected = state.selectedMapEntryOrder;
      el.mapSamples.querySelectorAll(".map-rr-cell").forEach((cell) => {
        const order = Number(cell.dataset.entryOrder);
        cell.classList.toggle("selected", Number.isFinite(selected) && order === selected);
      });
      el.mapSamples.querySelectorAll(".map-sample-box").forEach((box) => {
        const hasSelectedChild = !!box.querySelector(".map-rr-cell.selected");
        box.classList.toggle("selected", hasSelectedChild);
      });
    }

    function syncVelocityCrossfadeControl(entry = getMapEntryByOrder(state.selectedMapEntryOrder)) {
      if (!el.velocityXfadeToggle) return;
      if (!entry) {
        state.velocityCrossfadePercent = 0;
        el.velocityXfadeToggle.checked = false;
        return;
      }
      const value = getVelocityCrossfadePercentForRoot(entry.rootMidi);
      state.velocityCrossfadePercent = value;
      el.velocityXfadeToggle.checked = value > 0;
    }

    function updateSampleGainLine(entry = getMapEntryByOrder(state.selectedMapEntryOrder)) {
      if (!el.sampleGainLine || !el.sampleGainReadout) return;
      if (!entry || el.sampleEditor.classList.contains("hidden")) {
        el.sampleGainLine.classList.add("hidden");
        return;
      }
      ensureEntryEditorState(entry);
      const gainDb = clampSampleGainDb(entry.editorGainDb ?? 0);
      const minDb = -24;
      const maxDb = 24;
      const t = (gainDb - minDb) / (maxDb - minDb);
      const yPct = (1 - clamp01(t)) * 100;
      el.sampleGainLine.style.top = `${yPct.toFixed(3)}%`;
      el.sampleGainReadout.textContent = `${gainDb >= 0 ? "+" : ""}${gainDb.toFixed(1)} dB`;
      el.sampleGainLine.classList.remove("hidden");
    }

    function setSelectedSampleGainDb(nextDb) {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry) return;
      ensureEntryEditorState(entry);
      entry.editorGainDb = clampSampleGainDb(nextDb);
      updateSampleGainLine(entry);
    }

    function updateFineTuneKnob(entry = getMapEntryByOrder(state.selectedMapEntryOrder)) {
      const knob = el.sampleFineTuneKnob?.querySelector(".sample-finetune-knob");
      const pointer = el.sampleFineTunePointer;
      if (!knob || !pointer) return;
      if (!entry) {
        knob.classList.add("disabled");
        pointer.style.transform = "translate(-50%, -100%) rotate(0deg)";
        knob.setAttribute("aria-valuenow", "0");
        knob.setAttribute("aria-label", "Fine tune unavailable");
        knob.dataset.tooltip = "Fine tune unavailable";
        knob.title = "Fine tune unavailable";
        return;
      }
      ensureEntryEditorState(entry);
      const cents = clampFineTune(entry.fineTuneCents);
      const normalized = (cents + 100) / 200;
      const angle = -135 + (normalized * 270);
      pointer.style.transform = `translate(-50%, -100%) rotate(${angle.toFixed(2)}deg)`;
      knob.classList.remove("disabled");
      knob.setAttribute("aria-valuenow", String(cents));
      const label = `Fine tune: ${cents >= 0 ? "+" : ""}${cents} cents`;
      knob.setAttribute("aria-label", label);
      knob.dataset.tooltip = label;
      knob.title = label;
    }

    function setSelectedFineTune(nextCents) {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry) return;
      ensureEntryEditorState(entry);
      entry.fineTuneCents = clampFineTune(nextCents);
      updateFineTuneKnob(entry);
      refreshSelectedSampleMeta();
    }

    function updateLoopCrossfadeKnob() {
      const knob = el.sampleLoopXfadeKnob.querySelector(".sample-finetune-knob");
      const value = clampLoopCrossfadeMs(state.loopCrossfadeMs);
      state.loopCrossfadeMs = value;
      const t = value / 500;
      const angle = -135 + (t * 270);
      el.sampleLoopXfadePointer.style.transform = `translate(-50%, -100%) rotate(${angle}deg)`;
      knob.setAttribute("aria-valuenow", String(value));
      const label = `Loop crossfade ${value} ms`;
      knob.setAttribute("aria-label", label);
      el.sampleLoopXfadeKnob.title = label;
    }

    function setLoopCrossfadeMs(nextMs) {
      state.loopCrossfadeMs = clampLoopCrossfadeMs(nextMs);
      if (state.loopCandidates.length) clearLoopCandidates(false);
      updateLoopCrossfadeKnob();
      refreshSelectedSampleMeta();
      updateLoopToolButtons();
    }

    function clearLoopCandidates(updateUi = true) {
      state.loopCandidates = [];
      state.loopCandidateIndex = -1;
      state.loopCandidateOrder = null;
      if (updateUi) updateLoopToolButtons();
    }

    function updateLoopToolButtons() {
      const selectedEntry = getMapEntryByOrder(state.selectedMapEntryOrder);
      const hasEntry = !!selectedEntry;
      const candidatesForSelected = (
        hasEntry
        && state.loopCandidateOrder === selectedEntry.order
        && state.loopCandidates.length > 0
      );
      const validSampleCount = state.entries.filter((entry) => entry.valid && !!entry.sampleUrl).length;
      const navVisible = !!state.loopNavVisible;

      el.sampleFindLoopBtn.disabled = !hasEntry || state.loopSearchBusy;
      el.sampleLoopPrevBtn.classList.toggle("hidden", !navVisible);
      el.sampleLoopNextBtn.classList.toggle("hidden", !navVisible);
      el.sampleLoopPrevBtn.disabled = !navVisible || !candidatesForSelected || state.loopSearchBusy;
      el.sampleLoopNextBtn.disabled = !navVisible || !candidatesForSelected || state.loopSearchBusy;
      el.sampleLoopApplyAllBtn.disabled = !hasEntry || state.loopSearchBusy || validSampleCount <= 1;
      el.sampleFindLoopBtn.textContent = state.loopSearchBusy ? "..." : "Find";

      if (candidatesForSelected) {
        const idx = state.loopCandidateIndex + 1;
        const total = state.loopCandidates.length;
        el.sampleLoopPrevBtn.title = `Previous loop candidate (${idx}/${total})`;
        el.sampleLoopNextBtn.title = `Next loop candidate (${idx}/${total})`;
      } else {
        el.sampleLoopPrevBtn.title = "Previous loop candidate";
        el.sampleLoopNextBtn.title = "Next loop candidate";
      }
    }

    function applyLoopCandidateToEntry(entry, candidate) {
      if (!entry || !candidate) return;
      entry.loopStartNorm = clamp01(candidate.startNorm);
      entry.loopEndNorm = clamp01(candidate.endNorm);
      entry.loopFadeInNorm = Math.min(entry.loopStartNorm, clamp01(candidate.fadeInNorm));
      ensureEntryEditorState(entry);
    }

    function buildLoopCandidatesFromBuffer(entry, audioBuffer, maxCandidates = 7, crossfadeOverrideMs = null) {
      if (!entry || !audioBuffer || !audioBuffer.length) return [];
      ensureEntryEditorState(entry);
      const data = audioBuffer.getChannelData(0);
      if (!data || data.length < 512) return [];

      const length = audioBuffer.length;
      const sampleRate = audioBuffer.sampleRate || 44100;
      const windowSamples = Math.max(48, Math.round(sampleRate * 0.012));
      const minLoopSamples = Math.max(windowSamples * 2, Math.round(sampleRate * 0.08));
      const lastSafeSample = Math.max(windowSamples + 2, length - windowSamples - 3);
      const anchor = Math.max(
        windowSamples + 2,
        Math.min(lastSafeSample, Math.round(entry.loopStartNorm * length))
      );
      const searchOut = Math.max(
        anchor + minLoopSamples,
        Math.min(lastSafeSample, Math.round(entry.loopEndNorm * length))
      );
      const defaultRadius = (entry.loopEndNorm >= 0.999 && entry.loopStartNorm <= 0.001)
        ? Math.round(length * 0.35)
        : Math.round(length * 0.18);
      const searchRadius = Math.max(minLoopSamples, defaultRadius);

      let candidateStart = Math.max(anchor + minLoopSamples, searchOut - searchRadius);
      let candidateEnd = Math.min(lastSafeSample, searchOut + searchRadius);
      if (candidateEnd <= candidateStart + windowSamples) {
        candidateStart = anchor + minLoopSamples;
        candidateEnd = lastSafeSample;
      }
      if (candidateEnd <= candidateStart) return [];

      const step = Math.max(1, Math.round(sampleRate / 2000));
      const crossfadeMs = crossfadeOverrideMs === null ? state.loopCrossfadeMs : crossfadeOverrideMs;
      const crossfadeSamples = Math.max(0, Math.round((Math.max(0, Number(crossfadeMs) || 0) / 1000) * sampleRate));
      const scores = [];
      const anchorStart = anchor - windowSamples;

      for (let end = candidateStart; end <= candidateEnd; end += step) {
        const endStart = end - windowSamples;
        if (endStart < 0 || end + 1 >= length) continue;

        let ampDiff = 0;
        let slopeDiff = 0;
        for (let i = 0; i < windowSamples; i += 1) {
          const a = data[anchorStart + i] || 0;
          const b = data[endStart + i] || 0;
          const d = a - b;
          ampDiff += d * d;
          if (i < windowSamples - 1) {
            const da = (data[anchorStart + i + 1] || 0) - a;
            const db = (data[endStart + i + 1] || 0) - b;
            const ds = da - db;
            slopeDiff += ds * ds;
          }
        }

        const edgeDiff = Math.abs((data[anchor] || 0) - (data[end] || 0));
        const score = ampDiff + (slopeDiff * 0.55) + (edgeDiff * edgeDiff * windowSamples * 1.3);
        const startNorm = anchor / length;
        const endNorm = end / length;
        const fadeInNorm = Math.max(0, Math.min(startNorm, (anchor - crossfadeSamples) / length));
        scores.push({
          startNorm,
          endNorm,
          fadeInNorm,
          score
        });
      }

      scores.sort((a, b) => a.score - b.score);
      const deduped = [];
      for (const candidate of scores) {
        const isNearExisting = deduped.some((existing) => (
          Math.abs(existing.endNorm - candidate.endNorm) < 0.0025
        ));
        if (!isNearExisting) deduped.push(candidate);
        if (deduped.length >= maxCandidates) break;
      }
      return deduped;
    }

    async function findLoopCandidatesForSelectedEntry() {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry || !entry.sampleUrl) return;
      state.loopNavVisible = true;
      state.loopSearchBusy = true;
      updateLoopToolButtons();
      try {
        const waveform = await getWaveformForEntry(entry);
        const candidates = buildLoopCandidatesFromBuffer(entry, waveform?.audioBuffer, 7);
        state.loopCandidateOrder = entry.order;
        state.loopCandidates = candidates;
        state.loopCandidateIndex = candidates.length ? 0 : -1;
        if (candidates.length) {
          applyLoopCandidateToEntry(entry, candidates[0]);
          renderKeyboardMap(state.entries.filter((sample) => sample.valid), true);
          syncSelectedMapSampleBox();
          updateLoopHandles();
          refreshSelectedSampleMeta();
          setStatus(el.setupStatus, `Found ${candidates.length} loop candidate(s).`, "ok");
        } else {
          setStatus(el.setupStatus, "No loop candidates found in this search range.", "warn");
        }
      } catch {
        setStatus(el.setupStatus, "Loop search failed for this sample.", "bad");
      } finally {
        state.loopSearchBusy = false;
        updateLoopToolButtons();
      }
    }

    function stepSelectedLoopCandidate(direction) {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry) return;
      if (state.loopCandidateOrder !== entry.order || !state.loopCandidates.length) return;
      const total = state.loopCandidates.length;
      state.loopCandidateIndex = (state.loopCandidateIndex + direction + total) % total;
      applyLoopCandidateToEntry(entry, state.loopCandidates[state.loopCandidateIndex]);
      renderKeyboardMap(state.entries.filter((sample) => sample.valid), true);
      syncSelectedMapSampleBox();
      updateLoopHandles();
      refreshSelectedSampleMeta();
      updateLoopToolButtons();
    }

    async function applyCurrentLoopStrategyToAll() {
      const selected = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!selected) return;
      const targets = state.entries.filter((entry) => entry.valid && !!entry.sampleUrl);
      if (!targets.length) return;
      const strategyStart = clamp01(selected.loopStartNorm);
      const strategyEnd = clamp01(selected.loopEndNorm);

      state.loopSearchBusy = true;
      clearLoopCandidates(false);
      updateLoopToolButtons();

      let applied = 0;
      for (const entry of targets) {
        ensureEntryEditorState(entry);
        entry.loopStartNorm = strategyStart;
        entry.loopEndNorm = Math.max(strategyStart + 0.002, strategyEnd);
        entry.loopFadeInNorm = Math.min(entry.loopStartNorm, entry.loopFadeInNorm);
        try {
          const waveform = await getWaveformForEntry(entry);
          const best = buildLoopCandidatesFromBuffer(entry, waveform?.audioBuffer, 1)[0];
          if (best) {
            applyLoopCandidateToEntry(entry, best);
            applied += 1;
          }
        } catch {
          // skip samples that cannot be decoded in browser preview
        }
      }

      state.loopSearchBusy = false;
      renderKeyboardMap(state.entries.filter((entry) => entry.valid), true);
      syncSelectedMapSampleBox();
      updateLoopHandles();
      refreshSelectedSampleMeta();
      updateLoopToolButtons();
      setStatus(el.setupStatus, `Applied auto-loop strategy to ${applied}/${targets.length} sample(s).`, applied ? "ok" : "warn");
    }

    function updateLoopHandles() {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry || el.sampleEditor.classList.contains("hidden")) {
        el.sampleLoopFade.classList.add("hidden");
        el.sampleLoopStart.classList.add("hidden");
        el.sampleLoopEnd.classList.add("hidden");
        el.sampleLoopRegion.classList.add("hidden");
        el.sampleLoopFadeRegion.classList.add("hidden");
        return;
      }
      ensureEntryEditorState(entry);
      const contentWidth = Math.max(1, el.sampleWaveformContent.clientWidth || el.sampleWaveformViewport.clientWidth || 1);
      const fadeX = entry.loopFadeInNorm * contentWidth;
      const startX = entry.loopStartNorm * contentWidth;
      const endX = entry.loopEndNorm * contentWidth;

      el.sampleLoopFade.classList.remove("hidden");
      el.sampleLoopStart.classList.remove("hidden");
      el.sampleLoopEnd.classList.remove("hidden");
      el.sampleLoopFade.style.left = `${fadeX}px`;
      el.sampleLoopStart.style.left = `${startX}px`;
      el.sampleLoopEnd.style.left = `${endX}px`;

      if (isEntryLoopRegionActive(entry)) {
        el.sampleLoopRegion.classList.remove("hidden");
        el.sampleLoopRegion.style.left = `${Math.min(startX, endX)}px`;
        el.sampleLoopRegion.style.width = `${Math.max(0, endX - startX)}px`;

        if (entry.loopFadeInNorm < entry.loopStartNorm - 0.0005) {
          el.sampleLoopFadeRegion.classList.remove("hidden");
          el.sampleLoopFadeRegion.style.left = `${Math.min(fadeX, startX)}px`;
          el.sampleLoopFadeRegion.style.width = `${Math.max(0, startX - fadeX)}px`;
        } else {
          el.sampleLoopFadeRegion.classList.add("hidden");
        }
      } else {
        el.sampleLoopRegion.classList.add("hidden");
        el.sampleLoopFadeRegion.classList.add("hidden");
      }
    }

    function startLoopHandleDrag(which, ev) {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry) return;
      ensureEntryEditorState(entry);
      ev.preventDefault();

      const viewport = el.sampleWaveformViewport;
      const minGap = 0.002;

      function update(clientX) {
        const rect = viewport.getBoundingClientRect();
        const contentWidth = Math.max(1, el.sampleWaveformContent.clientWidth || viewport.clientWidth || 1);
        const absoluteX = (clientX - rect.left) + viewport.scrollLeft;
        let next = clamp01(absoluteX / contentWidth);
        if (next < 0.005) next = 0;
        if (next > 0.995) next = 1;

        if (which === "start") {
          const wasLinked = Math.abs((entry.loopFadeInNorm ?? 0) - entry.loopStartNorm) < minGap;
          entry.loopStartNorm = Math.min(next, entry.loopEndNorm - minGap);
          if (wasLinked || entry.loopFadeInNorm > entry.loopStartNorm) {
            entry.loopFadeInNorm = entry.loopStartNorm;
          }
        } else if (which === "fade") {
          entry.loopFadeInNorm = Math.min(next, entry.loopStartNorm);
          if (entry.loopStartNorm - entry.loopFadeInNorm < minGap) {
            entry.loopFadeInNorm = entry.loopStartNorm;
          }
        } else {
          entry.loopEndNorm = Math.max(next, entry.loopStartNorm + minGap);
        }
        updateLoopHandles();
        refreshSelectedSampleMeta();
      }

      update(ev.clientX);

      function onMove(moveEv) {
        update(moveEv.clientX);
      }

      function onUp() {
        window.removeEventListener("pointermove", onMove);
        window.removeEventListener("pointerup", onUp);
      }

      window.addEventListener("pointermove", onMove);
      window.addEventListener("pointerup", onUp);
    }

    function stopWaveformPlayhead() {
      if (state.playheadAnimationId) {
        window.cancelAnimationFrame(state.playheadAnimationId);
        state.playheadAnimationId = 0;
      }
      state.playheadSession = null;
      el.samplePlayhead.classList.add("hidden");
    }

    function startWaveformPlayhead(entry, ctx, durationSec, segments, stopSec) {
      if (
        !entry
        || !ctx
        || !Number.isFinite(durationSec)
        || durationSec <= 0
        || !Array.isArray(segments)
        || !segments.length
      ) {
        stopWaveformPlayhead();
        return;
      }
      if (state.selectedMapEntryOrder !== entry.order || el.sampleEditor.classList.contains("hidden")) {
        return;
      }

      const sanitized = segments
        .map((segment) => ({
          t0: Number(segment.t0) || 0,
          t1: Number(segment.t1) || 0,
          src0: Math.max(0, Math.min(durationSec, Number(segment.src0) || 0)),
          src1: Math.max(0, Math.min(durationSec, Number(segment.src1) || 0))
        }))
        .filter((segment) => segment.t1 > segment.t0 && segment.src1 >= segment.src0)
        .sort((a, b) => a.t0 - b.t0);

      if (!sanitized.length) {
        stopWaveformPlayhead();
        return;
      }

      stopWaveformPlayhead();
      el.samplePlayhead.classList.remove("hidden");
      state.playheadSession = {
        entryOrder: entry.order,
        ctx,
        durationSec,
        segments: sanitized,
        stopSec: Number.isFinite(stopSec) ? stopSec : sanitized[sanitized.length - 1].t1
      };

      function tick() {
        const session = state.playheadSession;
        if (!session) return;
        if (
          session.entryOrder !== state.selectedMapEntryOrder
          || el.sampleEditor.classList.contains("hidden")
          || session.ctx !== ctx
        ) {
          stopWaveformPlayhead();
          return;
        }

        const now = session.ctx.currentTime;
        if (now >= session.stopSec + 0.04) {
          stopWaveformPlayhead();
          return;
        }

        let active = session.segments[0];
        for (const segment of session.segments) {
          if (now >= segment.t0) active = segment;
          if (now >= segment.t0 && now <= segment.t1) {
            active = segment;
          }
        }

        const clampedNow = Math.max(active.t0, Math.min(active.t1, now));
        const dur = Math.max(0.000001, active.t1 - active.t0);
        const ratio = (clampedNow - active.t0) / dur;
        const srcPos = active.src0 + ((active.src1 - active.src0) * ratio);
        const norm = Math.max(0, Math.min(1, srcPos / session.durationSec));
        const contentWidth = Math.max(1, el.sampleWaveformContent.clientWidth || el.sampleWaveformViewport.clientWidth || 1);
        el.samplePlayhead.style.left = `${norm * contentWidth}px`;
        state.playheadAnimationId = window.requestAnimationFrame(tick);
      }

      tick();
    }

    function closeSampleEditor() {
      stopWaveformPlayhead();
      clearLoopCandidates(false);
      state.loopNavVisible = false;
      state.selectedMapEntryOrder = null;
      syncVelocityCrossfadeControl(null);
      updateSampleGainLine(null);
      state.waveformRequestId += 1;
      state.waveformZoom = 1;
      el.sampleEditor.classList.add("hidden");
      el.sampleWaveformViewport.scrollLeft = 0;
      updateWaveformScrollControl();
      syncSelectedMapSampleBox();
      updateWaveformZoomButtons();
      updateFineTuneKnob(null);
      updateLoopHandles();
      updateLoopToolButtons();
    }

    function ensureAudioContext() {
      if (state.audioContext) return state.audioContext;
      const Ctor = window.AudioContext || window.webkitAudioContext;
      if (!Ctor) throw new Error("WebAudio unavailable");
      state.audioContext = new Ctor();
      return state.audioContext;
    }

    function prepareWaveformCanvas(zoom = state.waveformZoom) {
      const canvas = el.sampleWaveform;
      const viewport = el.sampleWaveformViewport;
      const viewportWidth = Math.max(1, Math.round(viewport.clientWidth || 1));
      const cssHeight = Math.max(1, Math.round(viewport.clientHeight || 234));
      const zoomLevel = Math.max(1, Math.min(8, Number(zoom) || 1));
      const drawWidth = Math.max(1, Math.round(viewportWidth * zoomLevel));
      el.sampleWaveformContent.style.width = `${drawWidth}px`;
      el.sampleWaveformContent.style.height = `${cssHeight}px`;
      canvas.style.width = "100%";
      canvas.style.height = "100%";
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.max(1, Math.round(drawWidth * dpr));
      canvas.height = Math.max(1, Math.round(cssHeight * dpr));
      const ctx = canvas.getContext("2d");
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return { ctx, drawWidth, cssHeight };
    }

    function updateWaveformZoomButtons() {
      const minZoom = 1;
      const maxZoom = 8;
      state.waveformZoom = Math.max(minZoom, Math.min(maxZoom, Number(state.waveformZoom) || minZoom));
    }

    function updateWaveformScrollControl() {
      const hasSelection = Number.isFinite(state.selectedMapEntryOrder);
      const viewport = el.sampleWaveformViewport;
      const max = Math.max(0, Math.round(viewport.scrollWidth - viewport.clientWidth));
      const canPan = hasSelection && max > 0;
      viewport.classList.toggle("pannable", canPan);
      if (!canPan) viewport.classList.remove("panning");
      updateLoopHandles();
    }

    function setupWaveformPan() {
      const viewport = el.sampleWaveformViewport;
      let pointerId = null;
      let startX = 0;
      let startScroll = 0;

      function endPan() {
        pointerId = null;
        viewport.classList.remove("panning");
      }

      viewport.addEventListener("pointerdown", (ev) => {
        if (ev.button !== 0) return;
        if (!viewport.classList.contains("pannable")) return;
        if (ev.target.closest(".sample-loop-handle")) return;
        if (ev.target.closest(".sample-gain-line")) return;
        pointerId = ev.pointerId;
        startX = ev.clientX;
        startScroll = viewport.scrollLeft;
        viewport.classList.add("panning");
        if (viewport.setPointerCapture) viewport.setPointerCapture(pointerId);
        ev.preventDefault();
      });

      viewport.addEventListener("pointermove", (ev) => {
        if (pointerId === null || ev.pointerId !== pointerId) return;
        const deltaX = ev.clientX - startX;
        viewport.scrollLeft = Math.round(startScroll - deltaX);
        updateWaveformScrollControl();
      });

      function onPointerEnd(ev) {
        if (pointerId === null || ev.pointerId !== pointerId) return;
        if (viewport.releasePointerCapture && viewport.hasPointerCapture && viewport.hasPointerCapture(pointerId)) {
          viewport.releasePointerCapture(pointerId);
        }
        endPan();
      }

      viewport.addEventListener("pointerup", onPointerEnd);
      viewport.addEventListener("pointercancel", onPointerEnd);
      viewport.addEventListener("lostpointercapture", endPan);

      viewport.addEventListener("wheel", (ev) => {
        if (!Number.isFinite(state.selectedMapEntryOrder)) return;
        if (ev.target.closest(".sample-loop-handle")) return;
        const deltaNorm = Math.max(-1, Math.min(1, (-ev.deltaY || 0) / 100));
        const step = ev.shiftKey ? 0.45 : 0.18;
        const nextZoom = Math.max(1, Math.min(8, state.waveformZoom + (deltaNorm * step)));
        if (Math.abs(nextZoom - state.waveformZoom) < 0.001) return;
        ev.preventDefault();
        setWaveformZoom(nextZoom);
      }, { passive: false });
    }

    function redrawSelectedWaveform() {
      const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
      if (!entry) return;
      const waveform = state.waveformCache.get(entry.sampleUrl);
      if (!waveform) return;
      drawWaveformPeaks(waveform.peaks, state.waveformZoom);
      updateWaveformScrollControl();
    }

    function setWaveformZoom(nextZoom) {
      const minZoom = 1;
      const maxZoom = 8;
      const viewport = el.sampleWaveformViewport;
      const maxBefore = Math.max(0, viewport.scrollWidth - viewport.clientWidth);
      const scrollRatio = maxBefore > 0 ? (viewport.scrollLeft / maxBefore) : 0;
      const zoom = Math.max(minZoom, Math.min(maxZoom, Number(nextZoom) || minZoom));
      state.waveformZoom = zoom;
      updateWaveformZoomButtons();
      redrawSelectedWaveform();
      window.requestAnimationFrame(() => {
        const maxAfter = Math.max(0, viewport.scrollWidth - viewport.clientWidth);
        viewport.scrollLeft = Math.round(scrollRatio * maxAfter);
        updateWaveformScrollControl();
      });
    }

    function drawWaveformMessage(text) {
      const { ctx, drawWidth, cssHeight } = prepareWaveformCanvas(1);
      ctx.clearRect(0, 0, drawWidth, cssHeight);
      ctx.fillStyle = "rgba(4, 8, 14, 0.92)";
      ctx.fillRect(0, 0, drawWidth, cssHeight);
      ctx.fillStyle = "rgba(184, 202, 234, 0.85)";
      ctx.font = '11px "SFMono-Regular", Menlo, monospace';
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.fillText(text, drawWidth / 2, cssHeight / 2);
      updateWaveformScrollControl();
    }

    function drawWaveformPeaks(peaks, zoom = state.waveformZoom) {
      const { ctx, drawWidth, cssHeight } = prepareWaveformCanvas(zoom);
      ctx.clearRect(0, 0, drawWidth, cssHeight);
      ctx.fillStyle = "rgba(4, 8, 14, 0.92)";
      ctx.fillRect(0, 0, drawWidth, cssHeight);

      const mid = (cssHeight - 1) * 0.5;
      ctx.strokeStyle = "rgba(140, 146, 156, 0.24)";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(0, mid);
      ctx.lineTo(drawWidth, mid);
      ctx.stroke();

      let minValues = [];
      let maxValues = [];

      if (Array.isArray(peaks)) {
        minValues = peaks.map((value) => -Math.max(0, Math.min(1, Number(value) || 0)));
        maxValues = peaks.map((value) => Math.max(0, Math.min(1, Number(value) || 0)));
      } else if (peaks && Array.isArray(peaks.center) && Array.isArray(peaks.min) && Array.isArray(peaks.max)) {
        minValues = peaks.min;
        maxValues = peaks.max;
      }

      const count = Math.min(minValues.length, maxValues.length);
      if (!count) return;

      const stepX = count > 1 ? drawWidth / (count - 1) : drawWidth;
      let centerBiasSum = 0;
      let centerBiasCount = 0;
      for (let i = 0; i < count; i += 1) {
        const hi = Number(maxValues[i]) || 0;
        const lo = Number(minValues[i]) || 0;
        centerBiasSum += (hi + lo) * 0.5;
        centerBiasCount += 1;
      }

      const centerBias = centerBiasCount > 0 ? (centerBiasSum / centerBiasCount) : 0;
      let posPeak = 0;
      let negPeak = 0;
      for (let i = 0; i < count; i += 1) {
        const hi = Number(maxValues[i]) || 0;
        const lo = Number(minValues[i]) || 0;
        const centeredHi = hi - centerBias;
        const centeredLo = lo - centerBias;
        if (centeredHi > posPeak) posPeak = centeredHi;
        if (-centeredLo > negPeak) negPeak = -centeredLo;
      }
      posPeak = Math.max(0.0001, posPeak);
      negPeak = Math.max(0.0001, negPeak);
      const posNorm = 1 / posPeak;
      const negNorm = 1 / negPeak;
      const normalize = (value) => {
        const centered = (Number(value) || 0) - centerBias;
        return Math.max(-1, Math.min(1, centered >= 0 ? (centered * posNorm) : (centered * negNorm)));
      };
      const ampScale = Math.max(1, (cssHeight - 2) * 0.5);

      ctx.beginPath();
      for (let i = 0; i < count; i += 1) {
        const x = i * stepX;
        const y = mid - (normalize(Number(maxValues[i]) || 0) * ampScale);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      for (let i = count - 1; i >= 0; i -= 1) {
        const x = i * stepX;
        const y = mid - (normalize(Number(minValues[i]) || 0) * ampScale);
        ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fillStyle = "rgba(164, 170, 180, 0.2)";
      ctx.fill();

      ctx.beginPath();
      for (let i = 0; i < count; i += 1) {
        const x = i * stepX;
        const hi = Number(maxValues[i]) || 0;
        const lo = Number(minValues[i]) || 0;
        const y = mid - (normalize((hi + lo) * 0.5) * ampScale);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = "rgba(164, 170, 180, 0.95)";
      ctx.lineWidth = 1.1;
      ctx.stroke();
      updateWaveformScrollControl();
    }

    function buildWaveformPeaks(audioBuffer, pointCount = 2048) {
      const length = audioBuffer.length;
      if (!length) return { center: [], min: [], max: [] };
      const channels = Math.max(1, audioBuffer.numberOfChannels);
      const points = Math.max(512, Math.min(pointCount, length));
      const block = Math.max(1, Math.floor(length / points));
      const center = new Array(points).fill(0);
      const min = new Array(points).fill(0);
      const max = new Array(points).fill(0);

      for (let i = 0; i < points; i += 1) {
        const start = i * block;
        const end = Math.min(length, i === points - 1 ? length : start + block);
        let localMin = 1;
        let localMax = -1;
        let avg = 0;
        let count = 0;
        for (let n = start; n < end; n += 1) {
          let mixed = 0;
          let sampleMin = 1;
          let sampleMax = -1;
          for (let ch = 0; ch < channels; ch += 1) {
            const data = audioBuffer.getChannelData(ch);
            const value = data[n] || 0;
            mixed += value;
            if (value < sampleMin) sampleMin = value;
            if (value > sampleMax) sampleMax = value;
          }
          mixed /= channels;
          if (sampleMin < localMin) localMin = sampleMin;
          if (sampleMax > localMax) localMax = sampleMax;
          avg += mixed;
          count += 1;
        }
        if (!count) {
          center[i] = 0;
          min[i] = 0;
          max[i] = 0;
        } else {
          center[i] = avg / count;
          min[i] = localMin;
          max[i] = localMax;
        }
      }

      return {
        center,
        min,
        max
      };
    }

    async function getWaveformForEntry(entry) {
      const cacheKey = entry.sampleUrl;
      if (state.waveformCache.has(cacheKey)) {
        return state.waveformCache.get(cacheKey);
      }

      const ctx = ensureAudioContext();
      const response = await fetch(entry.sampleUrl);
      const source = await response.arrayBuffer();
      const audioBuffer = await ctx.decodeAudioData(source.slice(0));
      const waveform = {
        peaks: buildWaveformPeaks(audioBuffer),
        durationSec: Number(audioBuffer.duration) || 0,
        audioBuffer
      };
      state.waveformCache.set(cacheKey, waveform);
      return waveform;
    }

    async function openSampleEditor(entry) {
      if (!entry || !entry.sampleUrl) return;
      ensureEntryEditorState(entry);
      stopWaveformPlayhead();
      clearLoopCandidates(false);
      state.loopNavVisible = false;
      state.selectedMapEntryOrder = entry.order;
      state.waveformZoom = 1;
      state.waveformRequestId += 1;
      const requestId = state.waveformRequestId;
      el.sampleEditor.classList.remove("hidden");
      syncVelocityCrossfadeControl(entry);
      updateSampleGainLine(entry);
      el.sampleEditorTitle.textContent = entry.fileName;
      el.sampleEditorMeta.textContent = getSampleEditorMeta(entry, getCachedDurationForEntry(entry));
      el.sampleWaveformViewport.scrollLeft = 0;
      updateWaveformScrollControl();
      syncSelectedMapSampleBox();
      updateWaveformZoomButtons();
      updateFineTuneKnob(entry);
      updateLoopCrossfadeKnob();
      updateLoopHandles();
      updateLoopToolButtons();
      drawWaveformMessage("Loading waveform...");

      try {
        const waveform = await getWaveformForEntry(entry);
        if (requestId !== state.waveformRequestId || state.selectedMapEntryOrder !== entry.order) return;
        refreshSelectedSampleMeta();
        drawWaveformPeaks(waveform.peaks, state.waveformZoom);
        updateSampleGainLine(entry);
      } catch {
        if (requestId !== state.waveformRequestId || state.selectedMapEntryOrder !== entry.order) return;
        drawWaveformMessage("Waveform unavailable");
        updateSampleGainLine(entry);
      }
    }

    function renderKeyboardMap(validEntries = getActiveMapEntries(), preserveView = false) {
      updateKeyswitchMapSelector();
      const valid = [...validEntries].sort((a, b) => (
        a.rootMidi - b.rootMidi
        || a.velocityLayer - b.velocityLayer
        || ((a.rrIndex ?? 999) - (b.rrIndex ?? 999))
        || a.order - b.order
      ));
      const bounds = getKeyboardMapBounds(valid);

      state.setupOctaveStart = Math.round(Number(state.setupOctaveStart) || 48);

      if (!preserveView && valid.length) {
        const hasVisible = valid.some((entry) => (
          entry.rootMidi >= state.setupOctaveStart && entry.rootMidi <= state.setupOctaveStart + 11
        ));
        if (!hasVisible) {
          state.setupOctaveStart = Math.floor(valid[0].rootMidi / 12) * 12;
        }
      }

      state.setupOctaveStart = Math.max(bounds.minStart, Math.min(bounds.maxStart, state.setupOctaveStart));

      const start = state.setupOctaveStart;
      el.octaveDownBtn.disabled = start <= bounds.minStart;
      el.octaveUpBtn.disabled = start >= bounds.maxStart;

      const buckets = Array.from({ length: 12 }, () => []);
      valid.forEach((entry) => {
        const index = entry.rootMidi - start;
        if (index >= 0 && index < 12) buckets[index].push(entry);
      });

      const { rangesByRoot } = getResolvedRootRanges(valid, getActiveMapManualRanges());

      el.mapSamples.textContent = "";
      buckets.forEach((entries, keyIndex) => {
        const col = document.createElement("div");
        col.className = "map-col";
        const layers = new Map();
        entries.forEach((entry) => {
          const layer = Math.max(1, Math.min(5, Math.round(Number(entry.velocityLayer) || 1)));
          if (!layers.has(layer)) layers.set(layer, []);
          layers.get(layer).push(entry);
        });

        const orderedLayers = Array.from(layers.keys()).sort((a, b) => b - a);
        orderedLayers.forEach((layer) => {
          const layerEntries = [...(layers.get(layer) || [])].sort((a, b) => (
            ((a.rrIndex ?? 999) - (b.rrIndex ?? 999)) || (a.order - b.order)
          ));
          if (!layerEntries.length) return;

          const primary = layerEntries[0];
          ensureEntryEditorState(primary);

          const rootRange = rangesByRoot.get(primary.rootMidi) || {
            low: primary.rootMidi,
            high: primary.rootMidi
          };
          const coverageStart = Math.max(start, rootRange.low);
          const coverageEnd = Math.min(start + 11, rootRange.high);
          const leftSpan = Math.max(0, primary.rootMidi - coverageStart);
          const rightSpan = Math.max(0, coverageEnd - primary.rootMidi);
          const spanTotal = Math.max(1, leftSpan + rightSpan + 1);

          const row = document.createElement("div");
          row.className = "map-velocity-row";

          const box = document.createElement("div");
          box.className = "map-sample-box";
          box.dataset.entryOrder = String(primary.order);
          box.dataset.rootMidi = String(primary.rootMidi);
          box.style.setProperty("--span-total", String(spanTotal));
          box.style.setProperty("--span-left", String(leftSpan));
          box.style.setProperty("--root-slot", String(leftSpan));
          if (keyIndex <= 1) box.classList.add("tooltip-left");
          if (keyIndex >= 10) box.classList.add("tooltip-right");
          box.dataset.tooltip = `root:${midiToNote(primary.rootMidi)} | covers:${midiToNote(coverageStart)}-${midiToNote(coverageEnd)} | V${layer} | RR:${layerEntries.length}`;
          box.setAttribute("aria-label", box.dataset.tooltip);

          const rrGrid = document.createElement("div");
          rrGrid.className = "map-rr-grid";
          rrGrid.style.setProperty("--rr-count", String(layerEntries.length));

          layerEntries.forEach((entry) => {
            ensureEntryEditorState(entry);
            const rr = entry.rrIndex === null ? "auto" : String(entry.rrIndex);
            const loopOn = isEntryLoopRegionActive(entry);
            const fineTune = clampFineTune(entry.fineTuneCents ?? 0);
            const xfadePct = Math.max(0, ((entry.loopStartNorm ?? 0) - (entry.loopFadeInNorm ?? entry.loopStartNorm ?? 0)) * 100);

            const rrCell = document.createElement("button");
            rrCell.type = "button";
            rrCell.className = "map-rr-cell";
            rrCell.dataset.entryOrder = String(entry.order);
            rrCell.dataset.rootMidi = String(entry.rootMidi);
            if (keyIndex <= 1) rrCell.classList.add("tooltip-left");
            if (keyIndex >= 10) rrCell.classList.add("tooltip-right");
            rrCell.dataset.tooltip = `${entry.fileName} | root:${midiToNote(entry.rootMidi)} | covers:${midiToNote(coverageStart)}-${midiToNote(coverageEnd)} | V${entry.velocityLayer} | RR:${rr} | tune:${fineTune >= 0 ? "+" : ""}${fineTune}c${loopOn ? ` | L:on${xfadePct > 0.05 ? ` | XF:${xfadePct.toFixed(1)}%` : ""}` : ""}`;
            rrCell.setAttribute("aria-label", rrCell.dataset.tooltip);
            rrGrid.appendChild(rrCell);
          });

          box.appendChild(rrGrid);

          const leftHandle = document.createElement("div");
          leftHandle.className = "map-range-handle left";
          leftHandle.dataset.side = "left";
          leftHandle.title = "Stretch down";
          const rightHandle = document.createElement("div");
          rightHandle.className = "map-range-handle right";
          rightHandle.dataset.side = "right";
          rightHandle.title = "Stretch up";

          box.appendChild(leftHandle);
          box.appendChild(rightHandle);
          row.appendChild(box);
          col.appendChild(row);
        });
        el.mapSamples.appendChild(col);
      });
      syncSelectedMapSampleBox();

      el.mapKeys.textContent = "";
      for (let i = 0; i < 12; i += 1) {
        const midi = start + i;
        const semitone = ((midi % 12) + 12) % 12;
        const key = document.createElement("div");
        key.className = `map-key ${BLACK_SEMITONES.has(semitone) ? "black" : "white"}`;
        if (midi > 127) {
          key.classList.add("disabled");
        } else {
          key.dataset.midi = String(midi);
          key.textContent = midiToNote(midi);
        }
        el.mapKeys.appendChild(key);
      }

      const visibleCount = buckets.reduce((sum, keyEntries) => sum + keyEntries.length, 0);
      if (!valid.length) {
        el.mapEmpty.textContent = "Import samples to see key mapping.";
        el.mapEmpty.classList.remove("hidden");
      } else if (visibleCount === 0) {
        el.mapEmpty.textContent = "No mapped samples in this octave. Hover near edges to switch octave.";
        el.mapEmpty.classList.remove("hidden");
      } else {
        el.mapEmpty.classList.add("hidden");
      }
    }

    function getPlayerKeyboardWhiteCount() {
      let count = 0;
      for (let midi = PLAYER_KB_START_MIDI; midi <= PLAYER_KB_END_MIDI; midi += 1) {
        const semitone = ((midi % 12) + 12) % 12;
        if (!BLACK_SEMITONES.has(semitone)) count += 1;
      }
      return count;
    }

    function getPlayerWhiteKeyWidthPx() {
      const whiteCount = getPlayerKeyboardWhiteCount();
      const viewportWidth = el.playerKeyboardViewport?.clientWidth ?? 0;
      if (whiteCount > 0 && Number.isFinite(viewportWidth) && viewportWidth > 0) {
        return Math.max(8, viewportWidth / whiteCount);
      }
      const raw = Number.parseFloat(getComputedStyle(el.playerStage).getPropertyValue("--player-white-key-width"));
      if (Number.isFinite(raw) && raw > 0) return raw;
      return 22;
    }

    function scrollPlayerKeyboardToMidi(midi = 60) {
      if (!el.playerKeyboardViewport) return;
      if ((el.playerKeyboardViewport.scrollWidth - el.playerKeyboardViewport.clientWidth) <= 1) {
        el.playerKeyboardViewport.scrollLeft = 0;
        return;
      }
      const clampedMidi = Math.max(PLAYER_KB_START_MIDI, Math.min(PLAYER_KB_END_MIDI, Math.round(Number(midi) || PLAYER_KB_START_MIDI)));
      const keyWidth = getPlayerWhiteKeyWidthPx();
      let whitesBefore = 0;
      for (let m = PLAYER_KB_START_MIDI; m < clampedMidi; m += 1) {
        const semitone = ((m % 12) + 12) % 12;
        if (!BLACK_SEMITONES.has(semitone)) whitesBefore += 1;
      }
      const target = Math.max(0, (whitesBefore * keyWidth) - (el.playerKeyboardViewport.clientWidth * 0.45));
      el.playerKeyboardViewport.scrollLeft = target;
    }

    function renderPlayerKeyboard() {
      if (!el.playerKeyboard || !el.playerKeyboardWhites || !el.playerKeyboardBlacks) return;

      el.playerKeyboardWhites.textContent = "";
      el.playerKeyboardBlacks.textContent = "";

      const whiteCount = getPlayerKeyboardWhiteCount();
      const whiteKeyWidth = getPlayerWhiteKeyWidthPx();
      if (el.playerStage) {
        el.playerStage.style.setProperty("--player-white-key-width", `${whiteKeyWidth}px`);
      }
      el.playerKeyboard.style.width = `${Math.max(1, whiteCount * whiteKeyWidth)}px`;

      const blackOffsets = { 1: 0.72, 3: 0.86, 6: 0.72, 8: 0.86, 10: 0.98 };

      const playbackSource = getPlayerPlaybackSource();
      const { roots, rangesByRoot } = getResolvedRootRanges(playbackSource.entries, playbackSource.manualRanges);
      const playableMidis = new Set();
      roots.forEach((rootMidi) => {
        const range = rangesByRoot.get(rootMidi);
        if (!range) return;
        for (let midi = range.low; midi <= range.high; midi += 1) {
          playableMidis.add(midi);
        }
      });

      function bindPlayerKeyEvents(keyNode, midi) {
        let releaseTimer = 0;
        let lastPressTs = -1;
        keyNode.dataset.midi = String(midi);
        keyNode.setAttribute("aria-label", `${midiToNote(midi)} (${midi})`);

        function triggerPressFromClientY(clientY, eventTimeStamp = null) {
          const stamp = Number.isFinite(eventTimeStamp) ? Number(eventTimeStamp) : performance.now();
          if (Number.isFinite(stamp) && lastPressTs >= 0 && Math.abs(stamp - lastPressTs) < 24) return;
          lastPressTs = stamp;
          if (releaseTimer) {
            window.clearTimeout(releaseTimer);
            releaseTimer = 0;
          }
          const rect = keyNode.getBoundingClientRect();
          const ratioY = clamp01((clientY - rect.top) / Math.max(1, rect.height));
          let triggered = false;
          try {
            triggered = !!triggerKeyboardMapKey(midi, ratioY);
          } catch {
            triggered = false;
          }
          if (!triggered) return;
          // Force animation retrigger on rapid repeated presses.
          keyNode.classList.remove("is-down");
          void keyNode.offsetWidth;
          keyNode.classList.add("is-down");
        }

        keyNode.addEventListener("pointerdown", (ev) => {
          if (typeof ev.button === "number" && ev.button > 0) return;
          ev.preventDefault();
          triggerPressFromClientY(ev.clientY, ev.timeStamp);
          if (keyNode.setPointerCapture) {
            try {
              keyNode.setPointerCapture(ev.pointerId);
            } catch {}
          }
        });

        const release = (ev) => {
          if (releaseTimer) window.clearTimeout(releaseTimer);
          releaseTimer = window.setTimeout(() => {
            keyNode.classList.remove("is-down");
            releaseTimer = 0;
          }, 240);
          if (ev && keyNode.releasePointerCapture && keyNode.hasPointerCapture && keyNode.hasPointerCapture(ev.pointerId)) {
            try {
              keyNode.releasePointerCapture(ev.pointerId);
            } catch {}
          }
        };

        keyNode.addEventListener("pointerup", release);
        keyNode.addEventListener("pointercancel", release);
        keyNode.addEventListener("lostpointercapture", release);
        keyNode.addEventListener("pointerleave", (ev) => {
          if ((ev.buttons & 1) !== 1) release();
        });

        keyNode.addEventListener("mousedown", (ev) => {
          if (typeof ev.button === "number" && ev.button > 0) return;
          ev.preventDefault();
          triggerPressFromClientY(ev.clientY, ev.timeStamp);
        });
        keyNode.addEventListener("mouseup", release);
        keyNode.addEventListener("mouseleave", release);
        keyNode.addEventListener("touchstart", (ev) => {
          const touch = ev.changedTouches && ev.changedTouches[0];
          if (!touch) return;
          ev.preventDefault();
          triggerPressFromClientY(touch.clientY, ev.timeStamp);
        }, { passive: false });
        keyNode.addEventListener("touchend", release);
        keyNode.addEventListener("touchcancel", release);
      }

      let whiteIndex = -1;
      for (let midi = PLAYER_KB_START_MIDI; midi <= PLAYER_KB_END_MIDI; midi += 1) {
        const semitone = ((midi % 12) + 12) % 12;
        if (BLACK_SEMITONES.has(semitone)) continue;

        const key = document.createElement("button");
        key.type = "button";
        key.className = "player-key player-key-white";

        if (semitone === 0) {
          key.classList.add("c-note");
          const label = document.createElement("span");
          label.className = "player-key-label";
          label.textContent = midiToNote(midi);
          key.appendChild(label);
        }

        const hasMappedSample = playableMidis.has(midi);
        if (hasMappedSample) key.classList.add("has-sample");
        else key.classList.add("no-sample");
        bindPlayerKeyEvents(key, midi);
        el.playerKeyboardWhites.appendChild(key);
        whiteIndex += 1;
      }

      whiteIndex = -1;
      for (let midi = PLAYER_KB_START_MIDI; midi <= PLAYER_KB_END_MIDI; midi += 1) {
        const semitone = ((midi % 12) + 12) % 12;
        if (!BLACK_SEMITONES.has(semitone)) {
          whiteIndex += 1;
          continue;
        }

        const key = document.createElement("button");
        key.type = "button";
        key.className = "player-key player-key-black";
        const offset = blackOffsets[semitone] ?? 0.8;
        key.style.left = `${(whiteIndex + offset) * whiteKeyWidth}px`;
        key.style.width = `${whiteKeyWidth * 0.68}px`;
        const hasMappedSample = playableMidis.has(midi);
        if (!hasMappedSample) key.classList.add("no-sample");
        bindPlayerKeyEvents(key, midi);
        el.playerKeyboardBlacks.appendChild(key);
      }

      window.requestAnimationFrame(() => scrollPlayerKeyboardToMidi(PLAYER_KB_START_MIDI));
    }

    function shiftKeyboardMapRange(direction, semitoneStep = 1) {
      const step = Math.max(1, Math.round(Number(semitoneStep) || 1));
      state.setupOctaveStart += direction * step;
      renderKeyboardMap(undefined, true);
    }

    function selectDonorRootForPlayedNote(playedMidi, entries = state.entries, manualRanges = state.manualRootRanges) {
      const { roots, rangesByRoot } = getResolvedRootRanges(entries, manualRanges);
      if (!roots.length) return null;
      for (let i = 0; i < roots.length; i += 1) {
        const root = roots[i];
        const range = rangesByRoot.get(root);
        if (!range) continue;
        if (playedMidi >= range.low && playedMidi <= range.high) return root;
      }
      return null;
    }

    function getVelocityLayersForRoot(donorRoot, entries = state.entries) {
      const layers = Array.from(new Set(
        entries
          .filter((entry) => entry.valid && !!entry.sampleUrl && entry.rootMidi === donorRoot)
          .map((entry) => entry.velocityLayer)
      )).sort((a, b) => a - b);
      return layers;
    }

    function getVelocityCrossfadePlan(donorRoot, midiVelocity, entries = state.entries) {
      const layers = getVelocityLayersForRoot(donorRoot, entries);
      if (!layers.length) return [];
      const v = Math.max(1, Math.min(127, Math.round(midiVelocity)));
      if (layers.length === 1) return [{ velocityLayer: layers[0], gain: 1, startDelaySec: 0 }];

      const layerCount = layers.length;
      const baseIdx = Math.min(layerCount - 1, Math.floor(((v - 1) * layerCount) / 127));
      const perRootPercent = getVelocityCrossfadePercentForRoot(donorRoot);
      const xfadePct = Math.max(0, Math.min(0.5, perRootPercent / 100));
      if (xfadePct <= 0.0001) return [{ velocityLayer: layers[baseIdx], gain: 1, startDelaySec: 0 }];

      const layerRange = 127 / layerCount;
      const halfWidth = Math.max(0.5, (layerRange * xfadePct * 0.5));
      for (let split = 1; split < layerCount; split += 1) {
        const splitVelocity = Math.ceil((split * 127) / layerCount) + 1;
        const center = splitVelocity - 0.5;
        const zoneStart = center - halfWidth;
        const zoneEnd = center + halfWidth;
        if (v < zoneStart || v > zoneEnd) continue;
        const t = clamp01((v - zoneStart) / Math.max(0.0001, zoneEnd - zoneStart));
        const lowerGain = Math.max(0, 1 - t);
        const upperGain = Math.max(0, t);

        // Mitigate comb-filter phasing when two layers overlap: delay the weaker layer slightly.
        const blendCenterWeight = 1 - Math.abs((t * 2) - 1);
        const baseDelaySec = 0.00045 + (blendCenterWeight * 0.00035);
        const jitterSec = ((Math.random() * 2) - 1) * 0.00006;
        const delaySec = Math.max(0.0002, Math.min(0.0012, baseDelaySec + jitterSec));
        const lowerDelaySec = lowerGain <= upperGain ? delaySec : 0;
        const upperDelaySec = upperGain < lowerGain ? delaySec : 0;

        return [
          { velocityLayer: layers[split - 1], gain: lowerGain, startDelaySec: lowerDelaySec },
          { velocityLayer: layers[split], gain: upperGain, startDelaySec: upperDelaySec }
        ].filter((item) => item.gain > 0.0001);
      }

      return [{ velocityLayer: layers[baseIdx], gain: 1, startDelaySec: 0 }];
    }

    function pickSampleEntryForPlayback(playedMidi, donorRoot, velocityLayer, entries = state.entries) {
      const variants = entries
        .filter((entry) => (
          entry.valid
          && !!entry.sampleUrl
          && entry.rootMidi === donorRoot
          && entry.velocityLayer === velocityLayer
        ))
        .sort((a, b) => ((a.rrIndex ?? 999) - (b.rrIndex ?? 999)) || (a.order - b.order));
      if (!variants.length) return null;

      const cursorKey = `${playedMidi}:${velocityLayer}`;
      const cursor = state.rrCursor[cursorKey] ?? 0;
      const pick = variants[cursor % variants.length];
      state.rrCursor[cursorKey] = (cursor + 1) % variants.length;
      return pick;
    }

    function computeAudioRms(audioBuffer, fromSec, toSec) {
      if (!audioBuffer || !audioBuffer.length) return 0;
      const sampleRate = audioBuffer.sampleRate || 44100;
      const start = Math.max(0, Math.min(audioBuffer.length - 1, Math.floor((Number(fromSec) || 0) * sampleRate)));
      const end = Math.max(start + 1, Math.min(audioBuffer.length, Math.ceil((Number(toSec) || 0) * sampleRate)));
      if (end <= start) return 0;

      const channels = Math.max(1, audioBuffer.numberOfChannels || 1);
      let sumSquares = 0;
      let count = 0;

      for (let ch = 0; ch < channels; ch += 1) {
        const data = audioBuffer.getChannelData(ch);
        for (let i = start; i < end; i += 1) {
          const sample = data[i] || 0;
          sumSquares += sample * sample;
          count += 1;
        }
      }

      if (!count) return 0;
      return Math.sqrt(sumSquares / count);
    }

    function computeLoopIncomingGainScale(audioBuffer, loop) {
      if (!state.autoGainCrossfade) return 1;
      if (!loop || !Number.isFinite(loop.crossfadeSec) || loop.crossfadeSec <= 0.0005) return 1;

      const outFrom = Math.max(0, loop.endSec - loop.crossfadeSec);
      const outTo = loop.endSec;
      const inFrom = loop.fadeStartSec;
      const inTo = loop.startSec;
      const outgoingRms = computeAudioRms(audioBuffer, outFrom, outTo);
      const incomingRms = computeAudioRms(audioBuffer, inFrom, inTo);
      if (outgoingRms < 0.00001 || incomingRms < 0.00001) return 1;

      const gainScale = outgoingRms / incomingRms;
      return Math.max(0.25, Math.min(4, gainScale));
    }

    function dbToGain(db) {
      return Math.pow(10, (Number(db) || 0) / 20);
    }

    function getPlayerVoiceSettings() {
      const attackSec = Math.max(0, getKnobNumericValue("ampAttack", 10) / 1000);
      const decaySec = Math.max(0, getKnobNumericValue("ampDecay", 120) / 1000);
      const sustainLevel = clamp01(getKnobNumericValue("ampSustain", 100) / 100);
      const releaseSec = Math.max(0.005, getKnobNumericValue("ampRelease", 320) / 1000);
      const cutoffHz = Math.max(20, getKnobNumericValue("filterCutoff", 12000));
      const resonance = Math.max(0.1, getKnobNumericValue("filterResonance", 0.7));
      const outputGain = Math.max(0, dbToGain(getKnobNumericValue("gain", 0)));
      return {
        attackSec,
        decaySec,
        sustainLevel,
        releaseSec,
        cutoffHz,
        resonance,
        outputGain
      };
    }

    function createLadderFilterChain(ctx, cutoffHz, resonance) {
      const nyquist = Math.max(120, (ctx.sampleRate * 0.5) - 100);
      const cutoff = Math.max(20, Math.min(nyquist, Number(cutoffHz) || 12000));
      const res = Math.max(0.1, Math.min(12, Number(resonance) || 0.7));
      const stages = Array.from({ length: 4 }, () => ctx.createBiquadFilter());
      stages.forEach((stage) => {
        stage.type = "lowpass";
        stage.frequency.setValueAtTime(cutoff, ctx.currentTime);
      });
      stages[0].Q.setValueAtTime(Math.max(0.0001, 0.22 + (res * 0.18)), ctx.currentTime);
      stages[1].Q.setValueAtTime(Math.max(0.0001, 0.30 + (res * 0.26)), ctx.currentTime);
      stages[2].Q.setValueAtTime(Math.max(0.0001, 0.38 + (res * 0.34)), ctx.currentTime);
      stages[3].Q.setValueAtTime(Math.max(0.0001, 0.45 + (res * 0.46)), ctx.currentTime);

      for (let i = 0; i < stages.length - 1; i += 1) {
        stages[i].connect(stages[i + 1]);
      }
      return {
        input: stages[0],
        output: stages[stages.length - 1]
      };
    }

    function scheduleAmpEnvelope(param, now, releaseAnchor, settings, peakGain) {
      const attackSec = Math.max(0.001, Number(settings.attackSec) || 0);
      const decaySec = Math.max(0, Number(settings.decaySec) || 0);
      const sustainLevel = clamp01(Number(settings.sustainLevel));
      const releaseSec = Math.max(0.005, Number(settings.releaseSec) || 0.005);
      const peak = Math.max(0.0001, Number(peakGain) || 0.0001);
      const sustain = Math.max(0.0001, peak * sustainLevel);

      param.cancelScheduledValues(now);
      param.setValueAtTime(0.0001, now);
      const attackEnd = now + attackSec;
      param.linearRampToValueAtTime(peak, attackEnd);
      const decayEnd = attackEnd + decaySec;
      param.linearRampToValueAtTime(sustain, decayEnd);

      const releaseStart = Math.max(decayEnd, Number(releaseAnchor) || decayEnd);
      param.setValueAtTime(sustain, releaseStart);
      const releaseEnd = releaseStart + releaseSec;
      param.linearRampToValueAtTime(0.0001, releaseEnd);
      return releaseEnd;
    }

    function schedulePlaybackSegment(
      ctx,
      destinationNode,
      audioBuffer,
      playbackRate,
      whenSec,
      sourceStartSec,
      sourceEndSec,
      fadeInSec,
      fadeOutSec,
      gainScale = 1,
      hardStopSec = Number.POSITIVE_INFINITY
    ) {
      const srcStart = Math.max(0, Math.min(audioBuffer.duration, Number(sourceStartSec) || 0));
      const srcEndRaw = Math.max(srcStart + 0.002, Math.min(audioBuffer.duration, Number(sourceEndSec) || audioBuffer.duration));
      const srcDuration = srcEndRaw - srcStart;
      const naturalEndSec = whenSec + (srcDuration / playbackRate);
      const cappedEndSec = Number.isFinite(hardStopSec) ? Math.min(naturalEndSec, hardStopSec) : naturalEndSec;
      if (!Number.isFinite(cappedEndSec) || cappedEndSec <= whenSec + 0.0002) return null;

      const playOutSec = cappedEndSec - whenSec;
      const safeFadeIn = Math.max(0, Math.min(Number(fadeInSec) || 0, playOutSec * 0.5));
      const safeFadeOut = Math.max(0, Math.min(Number(fadeOutSec) || 0, playOutSec * 0.5));
      const scale = Math.max(0.05, Math.min(4, Number(gainScale) || 1));

      const source = ctx.createBufferSource();
      source.buffer = audioBuffer;
      source.playbackRate.value = playbackRate;

      const gain = ctx.createGain();
      source.connect(gain);
      gain.connect(destinationNode);

      gain.gain.setValueAtTime(0.0001, whenSec);
      if (safeFadeIn > 0.0005) {
        gain.gain.linearRampToValueAtTime(scale, whenSec + safeFadeIn);
      } else {
        gain.gain.setValueAtTime(scale, whenSec + 0.0005);
      }

      const fadeOutStartSec = Math.max(whenSec, cappedEndSec - safeFadeOut);
      gain.gain.setValueAtTime(scale, fadeOutStartSec);
      if (safeFadeOut > 0.0005 || cappedEndSec < naturalEndSec) {
        gain.gain.linearRampToValueAtTime(0.0001, cappedEndSec);
      }

      source.start(whenSec, srcStart, srcDuration);
      source.stop(cappedEndSec + 0.02);

      const playedSourceDuration = Math.max(0, (cappedEndSec - whenSec) * playbackRate);
      const srcEnd = Math.min(srcEndRaw, srcStart + playedSourceDuration);
      return {
        t0: whenSec,
        t1: cappedEndSec,
        src0: srcStart,
        src1: srcEnd,
        source
      };
    }

    function stopPreviewHtmlAudioForKey(keyMidi, fadeOutSec = 0) {
      if (!Number.isFinite(keyMidi)) return;
      const activeGroup = state.previewHtmlAudioByKey.get(keyMidi);
      if (!activeGroup) return;
      state.previewHtmlAudioByKey.delete(keyMidi);
      const audios = Array.isArray(activeGroup.audios) ? activeGroup.audios : [activeGroup];
      const fadeMs = Math.max(0, Math.round((Number(fadeOutSec) || 0) * 1000));
      audios.forEach((audio) => {
        try {
          const startVolume = Number.isFinite(audio.volume) ? audio.volume : 1;
          if (fadeMs <= 4 || startVolume <= 0.0001) {
            audio.pause();
            audio.currentTime = 0;
            audio.volume = startVolume;
            return;
          }

          const steps = Math.max(2, Math.round(fadeMs / 16));
          const stepMs = Math.max(8, Math.round(fadeMs / steps));
          let step = 0;
          const timerId = window.setInterval(() => {
            step += 1;
            const t = Math.min(1, step / steps);
            audio.volume = Math.max(0, startVolume * (1 - t));
            if (t >= 1) {
              window.clearInterval(timerId);
              try {
                audio.pause();
                audio.currentTime = 0;
              } catch {
                // best effort
              }
              audio.volume = startVolume;
            }
          }, stepMs);
        } catch {
          // best effort
        }
      });
    }

    function disconnectPreviewVoiceNodes(voice) {
      if (!voice) return;
      if (Array.isArray(voice.sources)) {
        voice.sources.forEach((src) => {
          try { src.disconnect(); } catch {}
        });
      }
      try { voice.voiceInput.disconnect(); } catch {}
      try { voice.filterOutput.disconnect(); } catch {}
      try { voice.ampEnvelope.disconnect(); } catch {}
    }

    function stopPreviewVoice(voice, fadeOutSec = 0.007, atTime = null) {
      if (!voice || voice.stopping) return;
      voice.stopping = true;

      const ctx = voice.ctx;
      const now = Number.isFinite(atTime) ? atTime : (ctx?.currentTime ?? 0);
      const stopAt = now + Math.max(0.001, Number(fadeOutSec) || 0.007);

      const gainParam = voice.ampEnvelope?.gain;
      if (gainParam) {
        try {
          const currentGain = Math.max(0.0001, Number(gainParam.value) || 0.0001);
          gainParam.cancelScheduledValues(now);
          gainParam.setValueAtTime(currentGain, now);
          gainParam.linearRampToValueAtTime(0.0001, stopAt);
        } catch {
          // gain schedule may be stale
        }
      }

      if (Array.isArray(voice.sources)) {
        voice.sources.forEach((src) => {
          try { src.stop(stopAt + 0.02); } catch {}
        });
      }

      const cleanupMs = Math.max(40, Math.round(((stopAt - now) + 0.08) * 1000));
      window.setTimeout(() => {
        disconnectPreviewVoiceNodes(voice);
      }, cleanupMs);
    }

    function stopPreviewVoiceForKey(keyMidi, fadeOutSec = 0.007, atTime = null) {
      if (!Number.isFinite(keyMidi)) return;
      const existingGroup = state.previewVoicesByKey.get(keyMidi);
      if (existingGroup) {
        state.previewVoicesByKey.delete(keyMidi);
        const voices = Array.isArray(existingGroup.voices) ? existingGroup.voices : [existingGroup];
        voices.forEach((voice) => stopPreviewVoice(voice, fadeOutSec, atTime));
      }
      stopPreviewHtmlAudioForKey(keyMidi, fadeOutSec);
    }

    function stopAllPreviewVoices(fadeOutSec = 0.007) {
      const now = state.audioContext ? state.audioContext.currentTime : null;
      state.previewVoicesByKey.forEach((group) => {
        const voices = Array.isArray(group.voices) ? group.voices : [group];
        voices.forEach((voice) => stopPreviewVoice(voice, fadeOutSec, now));
      });
      state.previewVoicesByKey.clear();
      state.previewHtmlAudioByKey.forEach((group) => {
        const audios = Array.isArray(group.audios) ? group.audios : [group];
        audios.forEach((audio) => {
          try {
            audio.pause();
            audio.currentTime = 0;
          } catch {
            // best effort
          }
        });
      });
      state.previewHtmlAudioByKey.clear();
      state.previewTriggerSerialByKey.clear();
    }

    function playMappedSampleEntry(
      entry,
      velocityNorm,
      playedMidi,
      donorRoot,
      layerMixGain = 1,
      externalKeySerial = null,
      layerStartDelaySec = 0
    ) {
      if (!entry || !entry.sampleUrl) return;
      ensureEntryEditorState(entry);
      if (state.selectedMapEntryOrder !== entry.order) stopWaveformPlayhead();
      const keyMidi = Number.isFinite(playedMidi) ? Math.round(playedMidi) : null;
      if (keyMidi === null) return;
      const mixGain = Math.max(0, Math.min(1, Number(layerMixGain) || 0));
      if (mixGain <= 0.0001) return;

      let keySerial = Number.isFinite(externalKeySerial) ? Number(externalKeySerial) : null;
      if (keySerial === null) {
        keySerial = (state.previewTriggerSerialByKey.get(keyMidi) ?? 0) + 1;
        state.previewTriggerSerialByKey.set(keyMidi, keySerial);
        stopPreviewVoiceForKey(keyMidi, SAME_KEY_RETRIGGER_FADE_SEC);
      }

      if ((state.previewTriggerSerialByKey.get(keyMidi) ?? 0) !== keySerial) return;
      const activeVoiceGroup = state.previewVoicesByKey.get(keyMidi);
      if (!activeVoiceGroup || activeVoiceGroup.serial !== keySerial || !Array.isArray(activeVoiceGroup.voices)) {
        state.previewVoicesByKey.set(keyMidi, { serial: keySerial, voices: [] });
      }
      const activeHtmlGroup = state.previewHtmlAudioByKey.get(keyMidi);
      if (!activeHtmlGroup || activeHtmlGroup.serial !== keySerial || !Array.isArray(activeHtmlGroup.audios)) {
        state.previewHtmlAudioByKey.set(keyMidi, { serial: keySerial, audios: [] });
      }

      const velocityGain = Math.max(0.05, Math.min(1, 0.2 + (velocityNorm * 0.8)));
      const semitoneRatio = Math.pow(2, (playedMidi - donorRoot) / 12);
      const fineTuneRatio = Math.pow(2, clampFineTune(entry.fineTuneCents ?? 0) / 1200);
      const sampleGainScale = dbToGain(entry.editorGainDb ?? 0);
      const playbackRate = Math.max(0.125, Math.min(8, semitoneRatio * fineTuneRatio));
      const voiceSettings = getPlayerVoiceSettings();
      const peakGain = Math.max(0.0001, velocityGain * voiceSettings.outputGain * mixGain * sampleGainScale);
      const startDelaySec = Math.max(0, Math.min(0.003, Number(layerStartDelaySec) || 0));

      getWaveformForEntry(entry).then((waveform) => {
        if ((state.previewTriggerSerialByKey.get(keyMidi) ?? 0) !== keySerial) return;
        const audioBuffer = waveform?.audioBuffer;
        if (!audioBuffer) throw new Error("missing buffer");
        const ctx = ensureAudioContext();
        if (ctx.state === "suspended") ctx.resume().catch(() => {});

        const now = ctx.currentTime + startDelaySec;

        const voiceInput = ctx.createGain();
        const filter = createLadderFilterChain(ctx, voiceSettings.cutoffHz, voiceSettings.resonance);
        const ampEnvelope = ctx.createGain();
        voiceInput.connect(filter.input);
        filter.output.connect(ampEnvelope);
        ampEnvelope.connect(ctx.destination);

        const voiceId = (state.previewVoiceId += 1);
        const voiceRef = {
          id: voiceId,
          keyMidi: playedMidi,
          ctx,
          voiceInput,
          filterOutput: filter.output,
          ampEnvelope,
          sources: [],
          stopping: false
        };
        const voiceGroup = state.previewVoicesByKey.get(keyMidi);
        if (!voiceGroup || voiceGroup.serial !== keySerial || !Array.isArray(voiceGroup.voices)) {
          disconnectPreviewVoiceNodes(voiceRef);
          return;
        }
        voiceGroup.voices.push(voiceRef);

        const segments = [];
        let stopAt = now;

        const loop = getEntryLoopTimes(entry, audioBuffer.duration);
        if (loop.active) {
          const previewLen = 3.2;
          stopAt = now + previewLen;
          const crossfadeOutSec = Math.max(0, loop.crossfadeSec / playbackRate);
          const loopPeriodSec = Math.max(0.0001, (loop.endSec - loop.startSec) / playbackRate);
          const loopSegmentStartSec = Math.min(loop.startSec, loop.fadeStartSec);
          const loopIncomingGain = computeLoopIncomingGainScale(audioBuffer, loop);

          const firstSegment = schedulePlaybackSegment(
            ctx,
            voiceInput,
            audioBuffer,
            playbackRate,
            now,
            0,
            loop.endSec,
            Math.max(0.002, voiceSettings.attackSec),
            crossfadeOutSec,
            1,
            stopAt + 0.04
          );
          if (firstSegment) {
            segments.push(firstSegment);
            if (firstSegment.source) voiceRef.sources.push(firstSegment.source);
          }

          if (loopPeriodSec > 0.004) {
            let segmentStartSec = now + (loop.endSec / playbackRate) - crossfadeOutSec;
            let count = 0;
            const maxSegments = 512;
            while (segmentStartSec < stopAt + 0.04 && count < maxSegments) {
              const nextSegment = schedulePlaybackSegment(
                ctx,
                voiceInput,
                audioBuffer,
                playbackRate,
                segmentStartSec,
                loopSegmentStartSec,
                loop.endSec,
                crossfadeOutSec,
                crossfadeOutSec,
                loopIncomingGain,
                stopAt + 0.04
              );
              if (nextSegment) {
                segments.push(nextSegment);
                if (nextSegment.source) voiceRef.sources.push(nextSegment.source);
              }
              segmentStartSec += loopPeriodSec;
              count += 1;
            }
          }
        } else {
          const playSec = audioBuffer.duration / playbackRate;
          stopAt = now + playSec;
          const oneShot = schedulePlaybackSegment(
            ctx,
            voiceInput,
            audioBuffer,
            playbackRate,
            now,
            0,
            audioBuffer.duration,
            Math.max(0.002, voiceSettings.attackSec),
            0.01,
            1,
            stopAt + 0.03
          );
          if (oneShot) {
            segments.push(oneShot);
            if (oneShot.source) voiceRef.sources.push(oneShot.source);
          }
        }

        const releaseEnd = scheduleAmpEnvelope(
          ampEnvelope.gain,
          now,
          stopAt,
          voiceSettings,
          peakGain
        );

        if (segments.length && state.selectedMapEntryOrder === entry.order && !el.sampleEditor.classList.contains("hidden")) {
          startWaveformPlayhead(entry, ctx, audioBuffer.duration, segments, stopAt);
        }

        const cleanupMs = Math.max(160, Math.round(((releaseEnd - now) + 0.12) * 1000));
        window.setTimeout(() => {
          const currentVoiceGroup = state.previewVoicesByKey.get(keyMidi);
          if (currentVoiceGroup && currentVoiceGroup.serial === keySerial && Array.isArray(currentVoiceGroup.voices)) {
            currentVoiceGroup.voices = currentVoiceGroup.voices.filter((voice) => voice.id !== voiceId);
            if (!currentVoiceGroup.voices.length) {
              const currentHtmlGroup = state.previewHtmlAudioByKey.get(keyMidi);
              if (!currentHtmlGroup || currentHtmlGroup.serial !== keySerial || !Array.isArray(currentHtmlGroup.audios) || !currentHtmlGroup.audios.length) {
                state.previewVoicesByKey.delete(keyMidi);
              }
            }
          }
          disconnectPreviewVoiceNodes(voiceRef);
        }, cleanupMs);
      }).catch(() => {
        if ((state.previewTriggerSerialByKey.get(keyMidi) ?? 0) !== keySerial) return;
        if (state.selectedMapEntryOrder === entry.order) stopWaveformPlayhead();
        const audio = new Audio(entry.sampleUrl);
        audio.volume = Math.max(0, Math.min(1, velocityGain * mixGain * sampleGainScale * Math.min(1, voiceSettings.outputGain)));
        audio.playbackRate = playbackRate;
        if ("preservesPitch" in audio) audio.preservesPitch = false;
        if ("mozPreservesPitch" in audio) audio.mozPreservesPitch = false;
        if ("webkitPreservesPitch" in audio) audio.webkitPreservesPitch = false;
        const htmlGroup = state.previewHtmlAudioByKey.get(keyMidi);
        if (htmlGroup && htmlGroup.serial === keySerial && Array.isArray(htmlGroup.audios)) {
          htmlGroup.audios.push(audio);
        } else {
          state.previewHtmlAudioByKey.set(keyMidi, { serial: keySerial, audios: [audio] });
        }
        audio.addEventListener("ended", () => {
          const currentHtmlGroup = state.previewHtmlAudioByKey.get(keyMidi);
          if (currentHtmlGroup && currentHtmlGroup.serial === keySerial && Array.isArray(currentHtmlGroup.audios)) {
            currentHtmlGroup.audios = currentHtmlGroup.audios.filter((item) => item !== audio);
            if (!currentHtmlGroup.audios.length) {
              const currentVoiceGroup = state.previewVoicesByKey.get(keyMidi);
              if (!currentVoiceGroup || currentVoiceGroup.serial !== keySerial || !Array.isArray(currentVoiceGroup.voices) || !currentVoiceGroup.voices.length) {
                state.previewHtmlAudioByKey.delete(keyMidi);
              }
            }
          }
        }, { once: true });
        const playAudio = () => audio.play().catch(() => {});
        if (startDelaySec > 0.0001) window.setTimeout(playAudio, Math.round(startDelaySec * 1000));
        else playAudio();
      });
    }

    function triggerKeyboardMapKey(midi, pointerRatioY, options = null) {
      if (!Number.isFinite(midi)) return false;
      const hasExplicitSource = options && Array.isArray(options.entries);
      let sourceEntries = hasExplicitSource ? options.entries : null;
      let manualRanges = (options && typeof options.manualRanges === "object" && options.manualRanges !== null)
        ? options.manualRanges
        : null;

      if (!hasExplicitSource) {
        const keyswitchSet = (state.keyswitchSets || []).find((set) => (
          Number.isFinite(set?.keyMidi) && Math.round(set.keyMidi) === Math.round(midi)
        ));
        if (keyswitchSet) {
          setActiveMapSet(keyswitchSet.id, true);
          setStatus(el.setupStatus, `Keyswitch: ${keyswitchSet.name} (${keyswitchSet.key})`, "ok");
          return false;
        }
        const playbackSource = getPlayerPlaybackSource();
        sourceEntries = playbackSource.entries;
        manualRanges = playbackSource.manualRanges;
      }

      if (!Array.isArray(sourceEntries) || !sourceEntries.length) return false;
      if (!manualRanges || typeof manualRanges !== "object") manualRanges = state.manualRootRanges;
      const ratio = Math.max(0, Math.min(1, pointerRatioY));
      const velocityNorm = ratio;
      const midiVelocity = Math.round((velocityNorm * 126) + 1);
      const donorRoot = selectDonorRootForPlayedNote(midi, sourceEntries, manualRanges);
      if (donorRoot === null) return false;
      const playbackPlan = getVelocityCrossfadePlan(donorRoot, midiVelocity, sourceEntries);
      if (!playbackPlan.length) return false;

      const keyMidi = Math.round(midi);
      const keySerial = (state.previewTriggerSerialByKey.get(keyMidi) ?? 0) + 1;
      state.previewTriggerSerialByKey.set(keyMidi, keySerial);
      stopPreviewVoiceForKey(keyMidi, SAME_KEY_RETRIGGER_FADE_SEC);
      state.previewVoicesByKey.set(keyMidi, { serial: keySerial, voices: [] });
      state.previewHtmlAudioByKey.set(keyMidi, { serial: keySerial, audios: [] });

      let startedCount = 0;
      playbackPlan.forEach((item) => {
        const gain = Math.max(0, Math.min(1, Number(item.gain) || 0));
        if (gain <= 0.0001) return;
        const entry = pickSampleEntryForPlayback(midi, donorRoot, item.velocityLayer, sourceEntries);
        if (!entry) return;
        const delaySec = Math.max(0, Math.min(0.003, Number(item.startDelaySec) || 0));
        playMappedSampleEntry(entry, velocityNorm, midi, donorRoot, gain, keySerial, delaySec);
        startedCount += 1;
      });

      if (!startedCount) {
        state.previewVoicesByKey.delete(keyMidi);
        state.previewHtmlAudioByKey.delete(keyMidi);
        return false;
      }

      return true;
    }

    function setupKeyboardMap() {
      if (el.keyswitchMapSelect) {
        el.keyswitchMapSelect.addEventListener("change", () => {
          setActiveMapSet(el.keyswitchMapSelect.value, true);
        });
      }
      if (el.keyswitchMapKeyInput) {
        el.keyswitchMapKeyInput.addEventListener("change", () => {
          applyActiveKeyswitchSetKeyInput(true);
        });
        el.keyswitchMapKeyInput.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            applyActiveKeyswitchSetKeyInput(true);
          }
        });
        el.keyswitchMapKeyInput.addEventListener("blur", () => {
          applyActiveKeyswitchSetKeyInput(false);
        });
      }

      el.octaveDownBtn.addEventListener("click", (ev) => {
        shiftKeyboardMapRange(-1, ev.shiftKey ? 12 : 1);
      });
      el.octaveUpBtn.addEventListener("click", (ev) => {
        shiftKeyboardMapRange(1, ev.shiftKey ? 12 : 1);
      });
      el.sampleEditorClose.addEventListener("click", closeSampleEditor);
      setupWaveformPan();
      el.sampleWaveformViewport.addEventListener("scroll", updateWaveformScrollControl);
      el.sampleFindLoopBtn.addEventListener("click", () => findLoopCandidatesForSelectedEntry());
      el.sampleLoopPrevBtn.addEventListener("click", () => stepSelectedLoopCandidate(-1));
      el.sampleLoopNextBtn.addEventListener("click", () => stepSelectedLoopCandidate(1));
      el.sampleLoopApplyAllBtn.addEventListener("click", () => applyCurrentLoopStrategyToAll());
      el.sampleLoopFade.addEventListener("pointerdown", (ev) => startLoopHandleDrag("fade", ev));
      el.sampleLoopStart.addEventListener("pointerdown", (ev) => startLoopHandleDrag("start", ev));
      el.sampleLoopEnd.addEventListener("pointerdown", (ev) => startLoopHandleDrag("end", ev));

      const fineTuneKnob = el.sampleFineTuneKnob.querySelector(".sample-finetune-knob");
      const crossfadeKnob = el.sampleLoopXfadeKnob.querySelector(".sample-finetune-knob");

      crossfadeKnob.addEventListener("wheel", (ev) => {
        ev.preventDefault();
        const step = ev.shiftKey ? 10 : 1;
        const dir = ev.deltaY < 0 ? 1 : -1;
        setLoopCrossfadeMs(state.loopCrossfadeMs + (dir * step));
      }, { passive: false });

      crossfadeKnob.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        const startY = ev.clientY;
        const startValue = state.loopCrossfadeMs;

        function move(moveEv) {
          const delta = (startY - moveEv.clientY) * 2;
          setLoopCrossfadeMs(startValue + delta);
        }

        function up() {
          window.removeEventListener("pointermove", move);
          window.removeEventListener("pointerup", up);
        }

        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", up);
      });

      crossfadeKnob.addEventListener("keydown", (ev) => {
        if (ev.key !== "ArrowUp" && ev.key !== "ArrowDown" && ev.key !== "Home" && ev.key !== "End") return;
        ev.preventDefault();
        if (ev.key === "Home") {
          setLoopCrossfadeMs(0);
          return;
        }
        if (ev.key === "End") {
          setLoopCrossfadeMs(500);
          return;
        }
        const step = ev.shiftKey ? 10 : 1;
        const dir = ev.key === "ArrowUp" ? 1 : -1;
        setLoopCrossfadeMs(state.loopCrossfadeMs + (dir * step));
      });

      crossfadeKnob.addEventListener("dblclick", () => setLoopCrossfadeMs(30));

      function stepFineTune(delta, fallback = null) {
        const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
        if (!entry) {
          updateFineTuneKnob(null);
          return;
        }
        const base = fallback === null ? (entry.fineTuneCents ?? 0) : fallback;
        setSelectedFineTune(base + delta);
      }

      fineTuneKnob.addEventListener("wheel", (ev) => {
        ev.preventDefault();
        const step = ev.shiftKey ? 10 : 1;
        const dir = ev.deltaY < 0 ? 1 : -1;
        stepFineTune(dir * step);
      }, { passive: false });

      fineTuneKnob.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
        if (!entry) {
          updateFineTuneKnob(null);
          return;
        }
        const startY = ev.clientY;
        const startValue = clampFineTune(entry.fineTuneCents ?? 0);

        function move(moveEv) {
          const delta = Math.round(startY - moveEv.clientY);
          const next = clampFineTune(startValue + delta);
          setSelectedFineTune(next);
        }

        function up() {
          window.removeEventListener("pointermove", move);
          window.removeEventListener("pointerup", up);
        }

        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", up);
      });

      fineTuneKnob.addEventListener("keydown", (ev) => {
        const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
        if (!entry) return;
        if (ev.key === "ArrowUp" || ev.key === "ArrowDown") {
          ev.preventDefault();
          const step = ev.shiftKey ? 10 : 1;
          const dir = ev.key === "ArrowUp" ? 1 : -1;
          stepFineTune(dir * step);
          return;
        }
        if (ev.key === "Home") {
          ev.preventDefault();
          setSelectedFineTune(-100);
          return;
        }
        if (ev.key === "End") {
          ev.preventDefault();
          setSelectedFineTune(100);
        }
      });

      fineTuneKnob.addEventListener("dblclick", () => setSelectedFineTune(0));

      function pointerEventToSampleGainDb(clientY) {
        const rect = el.sampleWaveformViewport.getBoundingClientRect();
        const t = clamp01((clientY - rect.top) / Math.max(1, rect.height));
        const minDb = -24;
        const maxDb = 24;
        return maxDb - (t * (maxDb - minDb));
      }

      el.sampleGainLine?.addEventListener("pointerdown", (ev) => {
        ev.preventDefault();
        const entry = getMapEntryByOrder(state.selectedMapEntryOrder);
        if (!entry) return;
        el.sampleGainLine.classList.add("dragging");
        setSelectedSampleGainDb(pointerEventToSampleGainDb(ev.clientY));

        function move(moveEv) {
          setSelectedSampleGainDb(pointerEventToSampleGainDb(moveEv.clientY));
        }

        function up() {
          window.removeEventListener("pointermove", move);
          window.removeEventListener("pointerup", up);
          window.removeEventListener("pointercancel", up);
          el.sampleGainLine.classList.remove("dragging");
        }

        window.addEventListener("pointermove", move);
        window.addEventListener("pointerup", up);
        window.addEventListener("pointercancel", up);
      });

      el.sampleGainLine?.addEventListener("dblclick", (ev) => {
        ev.preventDefault();
        setSelectedSampleGainDb(0);
      });

      window.addEventListener("resize", () => {
        if (!el.sampleEditor.classList.contains("hidden")) redrawSelectedWaveform();
      });

      updateWaveformZoomButtons();
      updateWaveformScrollControl();
      updateFineTuneKnob(null);
      updateLoopCrossfadeKnob();
      updateLoopHandles();
      updateLoopToolButtons();
      updateSampleGainLine(null);

      el.mapKeys.addEventListener("pointerdown", (ev) => {
        const keyNode = ev.target.closest(".map-key");
        if (!keyNode || keyNode.classList.contains("disabled")) return;
        const midi = Number(keyNode.dataset.midi);
        if (!Number.isFinite(midi)) return;
        const rect = keyNode.getBoundingClientRect();
        const ratioY = (ev.clientY - rect.top) / Math.max(1, rect.height);
        triggerKeyboardMapKey(midi, ratioY, {
          entries: getActiveMapEntries(),
          manualRanges: getActiveMapManualRanges()
        });
        keyNode.classList.add("pressed");
        window.setTimeout(() => keyNode.classList.remove("pressed"), 120);
      });

      el.mapSamples.addEventListener("pointerdown", (ev) => {
        const handle = ev.target.closest(".map-range-handle");
        if (handle) {
          const box = handle.closest(".map-sample-box");
          if (!box) return;
          const rootMidi = Number(box.dataset.rootMidi);
          const side = String(handle.dataset.side || "");
          if (!Number.isFinite(rootMidi) || (side !== "left" && side !== "right")) return;
          ev.preventDefault();
          ev.stopPropagation();

          const valid = getActiveMapEntries().filter((entry) => entry.valid);
          const manualRanges = getActiveMapManualRanges();
          const { roots, rangesByRoot } = getResolvedRootRanges(valid, manualRanges);
          const startRange = rangesByRoot.get(rootMidi);
          if (!startRange) return;
          const startX = ev.clientX;
          const startValue = side === "left" ? startRange.low : startRange.high;
          const minValue = side === "left" ? startRange.minLow : rootMidi;
          const maxValue = side === "left" ? rootMidi : startRange.maxHigh;

          const keyNode = el.mapKeys.querySelector(".map-key");
          const mapKeysStyle = getComputedStyle(el.mapKeys);
          const gapPx = Number.parseFloat(mapKeysStyle.columnGap || mapKeysStyle.gap || "0") || 0;
          const semitoneStepPx = keyNode ? Math.max(1, keyNode.getBoundingClientRect().width + gapPx) : Math.max(1, el.mapKeys.getBoundingClientRect().width / 12);

          function move(moveEv) {
            const delta = Math.round((moveEv.clientX - startX) / semitoneStepPx);
            const nextValue = Math.max(minValue, Math.min(maxValue, startValue + delta));
            const current = rangesByRoot.get(rootMidi) || startRange;
            if (side === "left") {
              setManualRangeForRoot(rootMidi, nextValue, current.high, roots, manualRanges);
            } else {
              setManualRangeForRoot(rootMidi, current.low, nextValue, roots, manualRanges);
            }
            renderKeyboardMap(getActiveMapEntries(), true);
            renderPlayerKeyboard();
          }

          function up() {
            window.removeEventListener("pointermove", move);
            window.removeEventListener("pointerup", up);
            window.removeEventListener("pointercancel", up);
          }

          window.addEventListener("pointermove", move);
          window.addEventListener("pointerup", up);
          window.addEventListener("pointercancel", up);
          return;
        }

        const box = ev.target.closest(".map-sample-box");
        const rrCell = ev.target.closest(".map-rr-cell");
        const target = rrCell || box;
        if (!target) return;
        const order = Number(target.dataset.entryOrder);
        const entry = getMapEntryByOrder(order);
        if (!entry) return;
        openSampleEditor(entry);
      });
    }

    function renderSetup() {
      const valid = state.entries.filter((e) => e.valid);
      const invalid = state.entries.filter((e) => !e.valid);
      updateWheelBaseTheme();
      valid.forEach((entry) => ensureEntryEditorState(entry));
      if (state.selectedMapEntryOrder !== null && !getMapEntryByOrder(state.selectedMapEntryOrder)) {
        closeSampleEditor();
      }
      updateKeyswitchMapSelector();
      renderKeyboardMap(getActiveMapEntries(), true);
      syncVelocityCrossfadeControl();

      const buckets = new Map();
      valid.forEach((entry) => {
        const key = `${entry.rootMidi}-${entry.velocityLayer}`;
        if (!buckets.has(key)) buckets.set(key, []);
        buckets.get(key).push(entry);
      });

      if (state.entries.length === 0) {
        if ((state.keyswitchSets || []).length > 0) {
          const setLabels = state.keyswitchSets.map((set) => `${set.name}${set.key ? ` (${set.key})` : ""}`);
          el.importLog.textContent = `Loaded keyswitch set(s):\n${setLabels.join("\n")}`;
          const duplicates = getDuplicateKeyswitchNotes();
          if (duplicates.length > 0) {
            setStatus(el.setupStatus, `Duplicate keyswitch keys: ${duplicates.join(", ")}. Change key values.`, "warn");
          } else {
            setStatus(el.setupStatus, "");
          }
        } else {
          el.importLog.textContent = "No files imported.";
          setStatus(el.setupStatus, "");
        }
        closeSampleEditor();
        scheduleHostResizeForActiveTab();
        return;
      }

      el.importLog.textContent = state.entries.map((e) => {
        if (!e.valid) return `${e.fileName} -> INVALID (${e.reason})`;
        const rr = e.rrIndex === null ? "RR:auto" : `RR:${e.rrIndex}`;
        return `${e.fileName} -> ${midiToNote(e.rootMidi)} V${e.velocityLayer} ${rr}${e.loopEnabled ? " L" : ""}`;
      }).join("\n");

      const duplicateKeys = getDuplicateKeyswitchNotes();
      if (duplicateKeys.length > 0) {
        setStatus(el.setupStatus, `Duplicate keyswitch keys: ${duplicateKeys.join(", ")}. Change key values.`, "warn");
      } else if (invalid.length > 0) {
        setStatus(el.setupStatus, `Imported ${state.entries.length} files with ${invalid.length} invalid filename(s).`, "warn");
      } else {
        setStatus(el.setupStatus, "");
      }
      scheduleHostResizeForActiveTab();
    }

    function ingest(filesLike) {
      const files = Array.from(filesLike || []).filter((f) => {
        if (f.type && f.type.startsWith("audio/")) return true;
        return AUDIO_REGEX.test(f.name);
      });

      if (!files.length) {
        setStatus(el.setupStatus, "No audio files detected.", "warn");
        return;
      }

      state.packLoaded = false;
      const start = state.entries.length;
      files.forEach((file, idx) => {
        const parsed = parseFilename(file.name);
        const sampleUrl = parsed.valid ? URL.createObjectURL(file) : "";
        state.entries.push({
          fileName: file.name,
          order: start + idx,
          sampleUrl,
          fineTuneCents: 0,
          loopStartNorm: 0,
          loopEndNorm: 1,
          loopFadeInNorm: 0,
          ...parsed
        });
      });

      state.activeMapSetId = "base";
      state.rrCursor = {};
      assignImplicitVelocityLayers();
      renderSetup();
      updatePlayerEmptyState();
      setImportPackCollapsed(true);
      syncAllKnobValues();
    }

    function clearInstrument() {
      stopAutoSamplingCountdown(false);
      if (state.nativeAutoSamplerAvailable && state.nativeAutoSamplerActive) {
        emitNativeEvent("autosampler_control", { action: "stop" });
      }
      state.nativeAutoSamplerActive = false;
      state.nativeAutoSamplerExpected = 0;
      state.nativeAutoSamplerCaptured = 0;
      state.nativeAutoSamplerTakeCount = 0;
      state.deferredAutoLoopOrders = [];
      state.nativeAutoSamplerInputDetected = false;
      state.nativeAutoSamplerMessage = "";
      updateStartSamplingButtonLabel();
      stopAllPreviewVoices();
      state.entries.forEach((entry) => {
        if (entry.sampleUrl) URL.revokeObjectURL(entry.sampleUrl);
      });
      state.entries = [];
      state.manualRootRanges = {};
      state.keyswitchSets = [];
      state.activeMapSetId = "base";
      state.nextVirtualOrder = -1;
      state.packLoaded = false;
      state.rrCursor = {};
      state.waveformCache.clear();
      state.velocityCrossfadeByRoot = {};
      state.velocityCrossfadePercent = 0;
      closeSampleEditor();
      renderSetup();
      updatePlayerEmptyState();
      syncAllKnobValues();
    }

    function buildManifestMapping(entries) {
      const groups = new Map();
      (entries || []).filter((e) => e.valid).forEach((e) => {
        ensureEntryEditorState(e);
        const key = `${e.rootMidi}-${e.velocityLayer}`;
        if (!groups.has(key)) {
          groups.set(key, {
            rootMidiNote: e.rootMidi,
            velocityLayer: e.velocityLayer,
            rrVariants: []
          });
        }
        groups.get(key).rrVariants.push({
          path: `samples/${e.fileName}`,
          originalFilename: e.fileName,
          loopEnabled: isEntryLoopRegionActive(e),
          loopStartNorm: Number((e.loopStartNorm ?? 0).toFixed(6)),
          loopEndNorm: Number((e.loopEndNorm ?? 1).toFixed(6)),
          loopFadeInNorm: Number((e.loopFadeInNorm ?? e.loopStartNorm ?? 0).toFixed(6)),
          fineTuneCents: clampFineTune(e.fineTuneCents ?? 0)
        });
      });
      return Array.from(groups.values());
    }

    function blobToDataUrl(blob) {
      return new Promise((resolve, reject) => {
        try {
          const reader = new FileReader();
          reader.onload = () => resolve(String(reader.result || ""));
          reader.onerror = () => reject(new Error("Could not read blob as data URL"));
          reader.readAsDataURL(blob);
        } catch (err) {
          reject(err);
        }
      });
    }

    function dataUrlToBlob(dataUrl) {
      const raw = String(dataUrl || "");
      const match = raw.match(/^data:([^;]+)?;base64,([\s\S]+)$/);
      if (!match) return null;
      const mime = match[1] || "application/octet-stream";
      try {
        const base64 = String(match[2] || "").replace(/\s+/g, "");
        const bin = atob(base64);
        const bytes = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; i += 1) bytes[i] = bin.charCodeAt(i);
        return new Blob([bytes], { type: mime });
      } catch {
        return null;
      }
    }

    async function getDataUrlFromSourceUrl(url, cache = new Map()) {
      const sourceUrl = String(url || "").trim();
      if (!sourceUrl) return "";
      if (sourceUrl.startsWith("data:")) return sourceUrl;
      if (cache.has(sourceUrl)) return cache.get(sourceUrl);
      const pending = fetch(sourceUrl)
        .then((response) => {
          if (!response.ok) throw new Error("Failed to fetch source asset");
          return response.blob();
        })
        .then((blob) => blobToDataUrl(blob))
        .catch(() => "");
      cache.set(sourceUrl, pending);
      return pending;
    }

    function buildManifestSkeleton(targetExt = "smpinst") {
      const ext = String(targetExt || "smpinst").trim().toLowerCase().replace(/^\./, "") || "smpinst";
      const normalizedExt = ext === "keyswitch" ? "keysw" : ext;
      const manifest = {
        formatVersion: 1,
        instrumentName: (el.autoInstrument.value || "Instrument").trim(),
        author: (el.autoAuthor?.value || "").trim(),
        createdUtc: new Date().toISOString(),
        settings: {
          gapFillMode: "nextHigherOnly",
          allowPitchUpAboveHighest: state.allowPitchUpAboveHighest,
          autoRR: state.autoRR,
          velocityCrossfadePercent: state.velocityCrossfadePercent,
          loopCrossfadeMs: state.loopCrossfadeMs,
          autoGainCrossfade: state.autoGainCrossfade,
          autoLoopSamples: !!el.autoLoop?.checked,
          autoLoopEnabled: !!el.autoLoopMode?.checked,
          autoLoopStartPercent: getAutoLoopStartPercent(),
          autoLoopEndPercent: getAutoLoopEndPercent(),
          autoLoopCutAtEnd: !!el.autoLoopCutAtEnd?.checked,
          autoLoopCrossfadeMs: getAutoLoopCrossfadeMs(),
          autoNormalizeRecorded: !!el.autoNormalizeRecorded?.checked
        },
        wallpaper: {
          enabled: !!state.wallpaperName,
          path: state.wallpaperName ? `wallpaper/${state.wallpaperName}` : undefined,
          fitMode: "fill",
          brightness: 1.0
        },
        logo: {
          enabled: !!state.logoName,
          path: state.logoName ? `logo/${state.logoName}` : undefined,
          fitMode: "contain",
          position: normalizeLogoPosition(state.logoPosition)
        },
        mapping: buildManifestMapping(state.entries)
      };

      if (normalizedExt === "keysw") {
        const keyInfo = normalizeKeyswitchKey(el.autoAuthor?.value || "", 12);
        manifest.packType = "keyswitch";
        manifest.keyswitchKey = keyInfo.key;
      } else {
        manifest.packType = "instrument";
        manifest.keyswitchSets = (state.keyswitchSets || [])
          .map((set) => ({
            name: String(set?.name || "Keyswitch").trim() || "Keyswitch",
            keyswitchKey: Number.isFinite(set?.keyMidi) ? midiToNote(Math.round(set.keyMidi)) : String(set?.key || ""),
            mapping: buildManifestMapping(Array.isArray(set?.entries) ? set.entries : [])
          }))
          .filter((set) => Array.isArray(set.mapping) && set.mapping.length > 0);
      }
      return manifest;
    }

    async function buildManifestMappingEmbedded(entries, dataUrlCache = new Map()) {
      const groups = new Map();
      const validEntries = (entries || []).filter((entry) => entry.valid);
      for (const entry of validEntries) {
        ensureEntryEditorState(entry);
        const key = `${entry.rootMidi}-${entry.velocityLayer}`;
        if (!groups.has(key)) {
          groups.set(key, {
            rootMidiNote: entry.rootMidi,
            velocityLayer: entry.velocityLayer,
            rrVariants: []
          });
        }
        const sampleDataUrl = entry.sampleUrl
          ? await getDataUrlFromSourceUrl(entry.sampleUrl, dataUrlCache)
          : "";
        groups.get(key).rrVariants.push({
          path: `samples/${entry.fileName}`,
          originalFilename: entry.fileName,
          sampleDataUrl,
          loopEnabled: isEntryLoopRegionActive(entry),
          loopStartNorm: Number((entry.loopStartNorm ?? 0).toFixed(6)),
          loopEndNorm: Number((entry.loopEndNorm ?? 1).toFixed(6)),
          loopFadeInNorm: Number((entry.loopFadeInNorm ?? entry.loopStartNorm ?? 0).toFixed(6)),
          fineTuneCents: clampFineTune(entry.fineTuneCents ?? 0)
        });
      }
      return Array.from(groups.values());
    }

    async function buildManifestWithEmbeddedAssets(targetExt = "smpinst") {
      const manifest = buildManifestSkeleton(targetExt);
      const cache = new Map();

      manifest.mapping = await buildManifestMappingEmbedded(state.entries, cache);
      if (manifest.packType === "instrument") {
        const sets = [];
        for (const set of (state.keyswitchSets || [])) {
          const mapping = await buildManifestMappingEmbedded(Array.isArray(set?.entries) ? set.entries : [], cache);
          if (!mapping.length) continue;
          sets.push({
            name: String(set?.name || "Keyswitch").trim() || "Keyswitch",
            keyswitchKey: Number.isFinite(set?.keyMidi) ? midiToNote(Math.round(set.keyMidi)) : String(set?.key || ""),
            mapping
          });
        }
        manifest.keyswitchSets = sets;
      }

      if (state.wallpaperUrl && state.wallpaperName) {
        const wallpaperDataUrl = await getDataUrlFromSourceUrl(state.wallpaperUrl, cache);
        if (wallpaperDataUrl) {
          manifest.wallpaper = {
            ...(manifest.wallpaper || {}),
            enabled: true,
            filename: state.wallpaperName,
            dataUrl: wallpaperDataUrl
          };
        }
      }

      if (state.logoUrl && state.logoName) {
        const logoDataUrl = await getDataUrlFromSourceUrl(state.logoUrl, cache);
        if (logoDataUrl) {
          manifest.logo = {
            ...(manifest.logo || {}),
            enabled: true,
            filename: state.logoName,
            dataUrl: logoDataUrl
          };
        }
      }

      return manifest;
    }

    async function exportPack(targetExt = "smpinst") {
      const extRaw = String(targetExt || "smpinst").trim().toLowerCase().replace(/^\./, "") || "smpinst";
      const ext = extRaw === "keyswitch" ? "keysw" : extRaw;
      if (ext === "smpinst") {
        const duplicates = getDuplicateKeyswitchNotes();
        if (duplicates.length > 0) {
          setStatus(el.setupStatus, `Duplicate keyswitch keys: ${duplicates.join(", ")}. Change keys before packing .smpinst.`, "warn");
          return;
        }
      }

      const saveBtnLabel = el.saveSmpinstBtn?.textContent || "Save (.smpinst)";
      if (ext === "smpinst" && el.saveSmpinstBtn) {
        el.saveSmpinstBtn.disabled = true;
        el.saveSmpinstBtn.textContent = "Saving...";
      }
      try {
        const manifest = await buildManifestWithEmbeddedAssets(ext);
        const base = (manifest.instrumentName || "instrument").replace(/[^a-z0-9_-]+/gi, "_");
        const blob = new Blob([JSON.stringify(manifest, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${base || "instrument"}.${ext}`;
        a.click();
        URL.revokeObjectURL(url);
        const label = ext === "smpinst" ? ".smpinst" : `.${ext}`;
        setStatus(el.setupStatus, `Saved ${label} preset with embedded assets.`, "ok");
      } catch {
        setStatus(el.setupStatus, "Could not save preset file.", "bad");
      } finally {
        if (ext === "smpinst" && el.saveSmpinstBtn) {
          el.saveSmpinstBtn.disabled = false;
          el.saveSmpinstBtn.textContent = saveBtnLabel;
        }
      }
    }

    function loadPack(file) {
      const reader = new FileReader();
      reader.onload = async () => {
        stopAutoSamplingCountdown(false);
        if (state.nativeAutoSamplerAvailable && state.nativeAutoSamplerActive) {
          emitNativeEvent("autosampler_control", { action: "stop" });
          state.nativeAutoSamplerActive = false;
          state.nativeAutoSamplerExpected = 0;
          state.nativeAutoSamplerCaptured = 0;
          state.nativeAutoSamplerTakeCount = 0;
          state.deferredAutoLoopOrders = [];
          updateStartSamplingButtonLabel();
        }
        try {
          const data = JSON.parse(String(reader.result || "{}"));
          stopAllPreviewVoices();
          state.entries.forEach((entry) => {
            if (entry.sampleUrl) URL.revokeObjectURL(entry.sampleUrl);
          });
          (state.keyswitchSets || []).forEach((set) => {
            (set.entries || []).forEach((entry) => {
              if (entry?.sampleUrl) URL.revokeObjectURL(entry.sampleUrl);
            });
          });

          const baseEntries = buildKeyswitchEntriesFromManifest(data, { useVirtualOrder: false, startOrder: 0 });
          let nextOrder = baseEntries.length;
          const importedKeyswitchSets = [];
          const keyswitchSetRecords = Array.isArray(data?.keyswitchSets) ? data.keyswitchSets : [];
          keyswitchSetRecords.forEach((rawSet, index) => {
            const setEntries = buildKeyswitchEntriesFromManifest(rawSet, { useVirtualOrder: false, startOrder: nextOrder });
            nextOrder += setEntries.length;
            const keySource = rawSet?.keyswitchKey ?? rawSet?.key ?? rawSet?.author ?? "";
            const keyInfo = normalizeKeyswitchKey(keySource, 12);
            importedKeyswitchSets.push({
              id: `ks_loaded_${Date.now()}_${index}_${Math.random().toString(36).slice(2, 6)}`,
              name: String(rawSet?.name || rawSet?.instrumentName || `Keyswitch ${index + 1}`).trim() || `Keyswitch ${index + 1}`,
              key: keyInfo.key,
              keyMidi: keyInfo.keyMidi,
              sourceFile: file?.name || "",
              entries: setEntries,
              manualRanges: {}
            });
          });

          state.entries = baseEntries;
          state.keyswitchSets = importedKeyswitchSets;
          state.manualRootRanges = {};
          state.activeMapSetId = importedKeyswitchSets.length > 0 ? importedKeyswitchSets[0].id : "base";
          state.nextVirtualOrder = -1;
          state.rrCursor = {};
          closeSampleEditor();

          const author = typeof data?.author === "string"
            ? data.author
            : (typeof data?.metadata?.author === "string" ? data.metadata.author : "");
          if (el.autoAuthor) el.autoAuthor.value = author.trim();
          if (el.autoInstrument && typeof data?.instrumentName === "string") {
            el.autoInstrument.value = data.instrumentName.trim();
          }
          const count = Array.isArray(data.mapping) ? data.mapping.length : 0;
          state.packLoaded = true;
          const duplicateNotes = getDuplicateKeyswitchNotes();
          if (duplicateNotes.length > 0) {
            setStatus(el.setupStatus, `Loaded preset with duplicate keyswitch keys: ${duplicateNotes.join(", ")}. Change keys in Keyboard Map.`, "warn");
          } else {
            const ksCount = importedKeyswitchSets.length;
            setStatus(el.setupStatus, `Loaded .smpinst preset with ${count} mapping bucket(s) and ${ksCount} keyswitch set(s).`, "ok");
          }

          const wallpaperDataUrl = String(data?.wallpaper?.dataUrl || "").trim();
          if (wallpaperDataUrl) {
            const wallpaperBlob = dataUrlToBlob(wallpaperDataUrl);
            if (wallpaperBlob) {
              const fileName = String(data?.wallpaper?.filename || data?.wallpaper?.path || "wallpaper.png");
              const wallpaperFile = new File([wallpaperBlob], fileName, { type: wallpaperBlob.type || "image/png" });
              await setWallpaper(wallpaperFile);
            } else {
              clearWallpaper();
            }
          } else {
            clearWallpaper();
          }

          const logoDataUrl = String(data?.logo?.dataUrl || "").trim();
          if (logoDataUrl) {
            const logoBlob = dataUrlToBlob(logoDataUrl);
            if (logoBlob) {
              const fileName = String(data?.logo?.filename || data?.logo?.path || "logo.png");
              const logoFile = new File([logoBlob], fileName, { type: logoBlob.type || "image/png" });
              setLogo(logoFile);
            } else {
              clearLogo();
            }
          } else {
            clearLogo();
          }

          renderSetup();
          renderAuto();
        } catch {
          setStatus(el.setupStatus, "Could not parse selected pack file as JSON preview.", "bad");
        }
        updatePlayerEmptyState();
        syncAllKnobValues();
      };
      reader.readAsText(file);
    }

    function computeNotes() {
      const start = noteToMidi(el.autoStart.value);
      const end = noteToMidi(el.autoEnd.value);
      if (start === null || end === null) return [];

      const lo = Math.min(start, end);
      const hi = Math.max(start, end);
      let notes = [];

      const step = getAutoInterval();
      for (let m = lo; m <= hi; m += step) notes.push(m);
      if (notes[notes.length - 1] !== hi) notes.push(hi);

      const uniq = Array.from(new Set(notes)).filter((m) => m >= lo && m <= hi).sort((a, b) => a - b);
      return uniq;
    }

    function getAutoRenderEstimate() {
      const notes = computeNotes();
      if (!notes.length) {
        return {
          notes,
          vel: 0,
          rr: 0,
          total: 0,
          totalRecordMs: 0,
          loopCutEnabled: false,
          loopEndRatio: 1,
          storedPerRenderMs: 0,
          sampleRate: getAutoRenderSampleRate(),
          bitDepth: 32,
          channelCount: 2,
          estimatedBytes: 0
        };
      }

      const vel = getAutoVelocityLayers();
      const rr = getAutoRRPerNote();
      const total = notes.length * vel * rr;
      const perRenderMs = getAutoHoldMs() + getAutoTailMs() + getAutoPrerollMs();
      const totalRecordMs = total * perRenderMs;

      const loopCutEnabled = !!el.autoLoop?.checked && !!el.autoLoopCutAtEnd?.checked;
      const loopEndRatio = loopCutEnabled ? clamp01(getAutoLoopEndPercent() / 100) : 1;
      const storedPerRenderMs = perRenderMs * loopEndRatio;

      const sampleRate = getAutoRenderSampleRate();
      const bitDepth = 32; // WebAudio engine runs float32.
      const channelCount = 2; // Auto-sampler render target is stereo.
      const bytesPerFrame = (bitDepth / 8) * channelCount;
      const wavHeaderBytes = 44;
      const totalStoredFrames = Math.max(0, (total * storedPerRenderMs * sampleRate) / 1000);
      const estimatedBytes = Math.round((totalStoredFrames * bytesPerFrame) + (total * wavHeaderBytes));

      return {
        notes,
        vel,
        rr,
        total,
        totalRecordMs,
        loopCutEnabled,
        loopEndRatio,
        storedPerRenderMs,
        sampleRate,
        bitDepth,
        channelCount,
        estimatedBytes
      };
    }

    function updateStartSamplingButtonLabel() {
      if (!el.startSamplingBtn) return;

      if (state.nativeAutoSamplerAvailable) {
        const active = !!state.nativeAutoSamplerActive;
        el.startSamplingBtn.classList.toggle("is-recording", active);
        if (!active) {
          el.startSamplingBtn.textContent = "Start Sampling";
          return;
        }
        const expected = Math.max(0, Math.round(Number(state.nativeAutoSamplerExpected) || 0));
        const captured = Math.max(
          Math.max(0, Math.round(Number(state.nativeAutoSamplerCaptured) || 0)),
          Math.max(0, Math.round(Number(state.nativeAutoSamplerTakeCount) || 0))
        );
        if (expected > 0) {
          el.startSamplingBtn.textContent = `${captured}/${expected}`;
        } else {
          el.startSamplingBtn.textContent = `${captured} captured`;
        }
        return;
      }

      const now = Date.now();
      const active = Number(state.samplingCountdownEndsAt) > now;
      el.startSamplingBtn.classList.toggle("is-recording", active);
      if (!active) {
        el.startSamplingBtn.textContent = "Start Sampling";
        return;
      }
      const remainingMs = Math.max(0, Math.round(state.samplingCountdownEndsAt - now));
      el.startSamplingBtn.textContent = `${formatDurationMs(remainingMs)} left`;
    }

    function stopAutoSamplingCountdown(markDone = false) {
      if (state.samplingCountdownTimer) {
        window.clearInterval(state.samplingCountdownTimer);
        state.samplingCountdownTimer = 0;
      }
      state.samplingCountdownEndsAt = 0;
      updateStartSamplingButtonLabel();
      if (markDone) {
        setStatus(el.setupStatus, "Sampling finished.", "ok");
      }
    }

    function startAutoSamplingCountdown(durationMs, totalRenders) {
      const duration = Math.max(1000, Math.round(Number(durationMs) || 0));
      if (!duration) return;
      stopAutoSamplingCountdown(false);
      state.samplingCountdownEndsAt = Date.now() + duration;
      updateStartSamplingButtonLabel();
      state.samplingCountdownTimer = window.setInterval(() => {
        if (Date.now() >= state.samplingCountdownEndsAt) {
          stopAutoSamplingCountdown(true);
          return;
        }
        updateStartSamplingButtonLabel();
      }, 200);
    }

    function renderAuto() {
      updatePlayerAuthorDisplay();
      const summary = getAutoRenderEstimate();
      if (!summary.notes.length) {
        if (el.renderTotal) el.renderTotal.innerHTML = "<strong>0</strong> total renders";
        if (el.renderTime) el.renderTime.innerHTML = `Estimated record time: <span class="render-time-value">0:00</span>`;
        if (el.renderSize) el.renderSize.innerHTML = `Estimated file size: <span class="render-size-value">0 B</span>`;
        updateStartSamplingButtonLabel();
        scheduleHostResizeForActiveTab();
        return;
      }

      if (el.renderTotal) {
        el.renderTotal.innerHTML = `<strong>${summary.total}</strong> total renders = ${summary.notes.length} notes Ã— ${summary.vel} layers Ã— ${summary.rr} RR`;
      }
      if (el.renderTime) {
        el.renderTime.innerHTML = `Estimated record time: <span class="render-time-value">${formatDurationMs(summary.totalRecordMs)}</span>`;
      }
      if (el.renderSize) {
        const trimSuffix = summary.loopCutEnabled ? ` (cut at ${Math.round(summary.loopEndRatio * 100)}%)` : "";
        el.renderSize.innerHTML = `Estimated file size: <span class="render-size-value">${formatFileSize(summary.estimatedBytes)}</span> <span class="render-size-format">(${formatSampleRate(summary.sampleRate)}, ${summary.bitDepth}-bit, stereo${trimSuffix})</span>`;
      }
      updateStartSamplingButtonLabel();
      scheduleHostResizeForActiveTab();
    }

    function updatePlayerAuthorDisplay(activeTab = null) {
      if (!el.playerAuthorDisplay) return;
      const tab = activeTab
        || document.querySelector(".tab-btn.active")?.dataset.tab
        || "player";
      const author = String(el.autoAuthor?.value || "").trim();
      const show = tab === "player" && author.length > 0 && !isKeyswitchPackEnabled();
      el.playerAuthorDisplay.textContent = show ? author : "";
      el.playerAuthorDisplay.classList.toggle("visible", show);
    }

    function activateTab(tab) {
      el.tabs.forEach((btn) => {
        const target = btn.dataset.tab;
        if (!target) return;
        btn.classList.toggle("active", target === tab);
      });
      Object.entries(el.panels).forEach(([key, panel]) => {
        panel.classList.toggle("active", key === tab);
      });
      updateTopBarTheme(tab);
      updatePlayerAuthorDisplay(tab);
      refreshPlayerParticles();
      scheduleHostResizeForActiveTab();
    }

    function setupTabs() {
      el.tabs.forEach((btn) => {
        btn.addEventListener("click", () => {
          const tab = btn.dataset.tab;
          if (!tab) return;
          activateTab(tab);
        });
      });
    }

    function setImportPackCollapsed(collapsed) {
      const next = !!collapsed;
      el.importPackSection.classList.toggle("collapsed", next);
      el.importPackToggle.setAttribute("aria-expanded", String(!next));
      saveSetupCollapseState("importPack", next);
      scheduleHostResizeForActiveTab();
    }

    function setupImportPackCollapse() {
      function toggleCollapsed() {
        const collapsed = el.importPackSection.classList.contains("collapsed");
        setImportPackCollapsed(!collapsed);
      }

      el.importPackToggle.addEventListener("click", toggleCollapsed);
      el.importPackToggle.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          toggleCollapsed();
        }
      });
    }

    function setGraphicsCollapsed(collapsed) {
      if (!el.graphicsSection || !el.graphicsToggle) return;
      const next = !!collapsed;
      el.graphicsSection.classList.toggle("collapsed", next);
      el.graphicsToggle.setAttribute("aria-expanded", String(!next));
      saveSetupCollapseState("graphics", next);
      scheduleHostResizeForActiveTab();
    }

    function setupGraphicsCollapse() {
      if (!el.graphicsSection || !el.graphicsToggle) return;

      function toggleCollapsed() {
        const collapsed = el.graphicsSection.classList.contains("collapsed");
        setGraphicsCollapsed(!collapsed);
      }

      el.graphicsToggle.addEventListener("click", toggleCollapsed);
      el.graphicsToggle.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          toggleCollapsed();
        }
      });
    }

    function setAutoSamplerCollapsed(collapsed) {
      if (!el.autoSamplerSection || !el.autoSamplerToggle) return;
      const next = !!collapsed;
      el.autoSamplerSection.classList.toggle("collapsed", next);
      el.autoSamplerToggle.setAttribute("aria-expanded", String(!next));
      saveSetupCollapseState("autoSampler", next);
      scheduleHostResizeForActiveTab();
    }

    function setupAutoSamplerCollapse() {
      if (!el.autoSamplerSection || !el.autoSamplerToggle) return;

      function toggleCollapsed() {
        const collapsed = el.autoSamplerSection.classList.contains("collapsed");
        setAutoSamplerCollapsed(!collapsed);
      }

      el.autoSamplerToggle.addEventListener("click", toggleCollapsed);
      el.autoSamplerToggle.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          toggleCollapsed();
        }
      });
    }

    function setKeyboardMapCollapsed(collapsed) {
      if (!el.keyboardMapSection || !el.keyboardMapToggle) return;
      const next = !!collapsed;
      el.keyboardMapSection.classList.toggle("collapsed", next);
      el.keyboardMapToggle.setAttribute("aria-expanded", String(!next));
      saveSetupCollapseState("keyboardMap", next);
      scheduleHostResizeForActiveTab();
    }

    function setupKeyboardMapCollapse() {
      if (!el.keyboardMapSection || !el.keyboardMapToggle) return;

      function toggleCollapsed() {
        const collapsed = el.keyboardMapSection.classList.contains("collapsed");
        setKeyboardMapCollapsed(!collapsed);
      }

      el.keyboardMapToggle.addEventListener("click", toggleCollapsed);
      el.keyboardMapToggle.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          toggleCollapsed();
        }
      });
    }

    function setEffectsCollapsed(collapsed) {
      if (!el.effectsSection || !el.effectsToggle) return;
      const next = !!collapsed;
      el.effectsSection.classList.toggle("collapsed", next);
      el.effectsToggle.setAttribute("aria-expanded", String(!next));
      saveSetupCollapseState("effects", next);
      scheduleHostResizeForActiveTab();
    }

    function setupEffectsCollapse() {
      if (!el.effectsSection || !el.effectsToggle) return;

      function toggleCollapsed() {
        const collapsed = el.effectsSection.classList.contains("collapsed");
        setEffectsCollapsed(!collapsed);
      }

      el.effectsToggle.addEventListener("click", toggleCollapsed);
      el.effectsToggle.addEventListener("keydown", (ev) => {
        if (ev.key === "Enter" || ev.key === " ") {
          ev.preventDefault();
          toggleCollapsed();
        }
      });
    }

    function setupWallpaper() {
      el.wallpaperInput.addEventListener("change", (ev) => {
        const [file] = Array.from(ev.target.files || []);
        if (file) setWallpaper(file);
      });

      el.logoInput.addEventListener("change", (ev) => {
        const [file] = Array.from(ev.target.files || []);
        if (file) setLogo(file);
      });

      el.wallpaperToggle.addEventListener("click", () => {
        if (!state.wallpaperName) {
          el.wallpaperInput.click();
          return;
        }
        setLogoMenuOpen(false);
        setWallpaperMenuOpen(!state.wallpaperMenuOpen);
      });

      el.logoToggle.addEventListener("click", () => {
        if (!state.logoName) {
          el.logoInput.click();
          return;
        }
        setWallpaperMenuOpen(false);
        setLogoMenuOpen(!state.logoMenuOpen);
      });

      if (el.particlesToggle) {
        el.particlesToggle.addEventListener("click", () => {
          state.playerParticlesEnabled = !state.playerParticlesEnabled;
          updateParticlesToggle();
          refreshPlayerParticles();
        });
      }

      if (el.godRaysToggle) {
        el.godRaysToggle.addEventListener("click", () => {
          state.playerGodRaysEnabled = !state.playerGodRaysEnabled;
          updateGodRaysToggle();
          updatePlayerGodRaysState();
        });
      }

      el.wallpaperPositionButtons.forEach((btn) => {
        btn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const pos = btn.dataset.wallpaperPos;
          applyWallpaperPosition(pos);
          setWallpaperMenuOpen(false);
        });
      });

      if (el.wallpaperRemoveBtn) {
        el.wallpaperRemoveBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          clearWallpaper();
          setWallpaperMenuOpen(false);
        });
      }

      el.logoPositionButtons.forEach((btn) => {
        btn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const pos = btn.dataset.logoPos;
          applyLogoPosition(pos);
          setLogoMenuOpen(false);
        });
      });

      if (el.logoRemoveBtn) {
        el.logoRemoveBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          clearLogo();
          setLogoMenuOpen(false);
        });
      }

      window.addEventListener("pointerdown", (ev) => {
        const target = ev.target;
        if (!(target instanceof Node)) return;

        const insideWallpaperMenu = !!(el.wallpaperMenuWrap && el.wallpaperMenuWrap.contains(target));
        const insideLogoMenu = !!(el.logoMenuWrap && el.logoMenuWrap.contains(target));

        if (state.wallpaperMenuOpen && !insideWallpaperMenu) {
          setWallpaperMenuOpen(false);
        }
        if (state.logoMenuOpen && !insideLogoMenu) {
          setLogoMenuOpen(false);
        }
      });

      window.addEventListener("keydown", (ev) => {
        if (ev.key !== "Escape") return;
        setWallpaperMenuOpen(false);
        setLogoMenuOpen(false);
      });

      ["dragenter", "dragover"].forEach((eventName) => {
        el.playerStage.addEventListener(eventName, (ev) => {
          ev.preventDefault();
        });
      });

      el.playerStage.addEventListener("drop", (ev) => {
        ev.preventDefault();
        const image = Array.from(ev.dataTransfer.files || []).find((f) => f.type.startsWith("image/"));
        if (image) setWallpaper(image);
      });

      updateParticlesToggle();
      updateGodRaysToggle();
      updatePlayerGodRaysState();
    }

    function setupImport() {
      el.addFilesBtn.addEventListener("click", () => el.filesInput.click());
      el.addFolderBtn.addEventListener("click", () => el.folderInput.click());
      el.clearInstrumentBtn.addEventListener("click", clearInstrument);
      if (el.importKeyswitchesBtn && el.keyswitchInput) {
        el.importKeyswitchesBtn.addEventListener("click", () => el.keyswitchInput.click());
      }
      if (el.saveSmpinstBtn) {
        el.saveSmpinstBtn.addEventListener("click", () => exportPack("smpinst"));
      }
      el.playerLoadInstrumentBtn.addEventListener("click", () => el.packInput.click());
      if (el.loadPackBtn) el.loadPackBtn.addEventListener("click", () => el.packInput.click());
      if (el.packBtn) el.packBtn.addEventListener("click", exportPack);
      if (el.openSummaryBtn) el.openSummaryBtn.addEventListener("click", openSummaryModal);

      if (el.velocityXfadeToggle) {
        const applyVelocityCrossfadePercent = () => {
          const normalized = el.velocityXfadeToggle.checked ? 30 : 0;
          const selectedEntry = getMapEntryByOrder(state.selectedMapEntryOrder);
          if (!selectedEntry) {
            syncVelocityCrossfadeControl(null);
            return;
          }
          const applied = setVelocityCrossfadePercentForRoot(selectedEntry.rootMidi, normalized);
          el.velocityXfadeToggle.checked = applied > 0;
        };
        el.velocityXfadeToggle.addEventListener("change", applyVelocityCrossfadePercent);
        syncVelocityCrossfadeControl();
      }

      el.filesInput.addEventListener("change", (ev) => {
        ingest(ev.target.files);
        el.filesInput.value = "";
      });

      el.folderInput.addEventListener("change", (ev) => {
        ingest(ev.target.files);
        el.folderInput.value = "";
      });

      el.packInput.addEventListener("change", (ev) => {
        const [file] = Array.from(ev.target.files || []);
        if (file) loadPack(file);
        el.packInput.value = "";
      });

      if (el.keyswitchInput) {
        el.keyswitchInput.addEventListener("change", (ev) => {
          const files = Array.from(ev.target.files || []);
          files.forEach((file) => importKeyswitchPack(file));
          el.keyswitchInput.value = "";
        });
      }

      ["dragenter", "dragover"].forEach((eventName) => {
        el.dropZone.addEventListener(eventName, (ev) => {
          ev.preventDefault();
          el.dropZone.classList.add("drag");
        });
      });

      ["dragleave", "drop"].forEach((eventName) => {
        el.dropZone.addEventListener(eventName, (ev) => {
          ev.preventDefault();
          el.dropZone.classList.remove("drag");
        });
      });

      el.dropZone.addEventListener("drop", (ev) => {
        ingest(ev.dataTransfer.files);
      });
    }

    function openSummaryModal() {
      el.summaryModal.classList.remove("hidden");
    }

    function closeSummaryModal() {
      el.summaryModal.classList.add("hidden");
    }

    function setupSummaryModal() {
      el.closeSummaryBtn.addEventListener("click", closeSummaryModal);
      el.summaryModal.addEventListener("click", (ev) => {
        if (ev.target === el.summaryModal) closeSummaryModal();
      });
      window.addEventListener("keydown", (ev) => {
        if (ev.key === "Escape" && !el.summaryModal.classList.contains("hidden")) {
          closeSummaryModal();
        }
      });
    }

    function setupAuto() {
      const controls = [
        el.autoStart,
        el.autoEnd,
        el.autoIntervalValue,
        el.autoVelValue,
        el.autoRRValue,
        el.autoHoldMs,
        el.autoTailMs,
        el.autoPrerollMs,
        el.autoLoop,
        el.autoLoopMode,
        el.autoLoopStartPct,
        el.autoLoopEndPct,
        el.autoLoopCutAtEnd,
        el.autoNormalizeRecorded,
        el.autoLoopCrossfadeMs,
        el.autoDestination,
        el.autoInstrument,
        el.autoAuthor
      ];

      controls.forEach((control) => {
        if (!control) return;
        control.addEventListener("input", renderAuto);
        control.addEventListener("change", renderAuto);
      });

      if (el.startSamplingBtn) {
        el.startSamplingBtn.addEventListener("click", () => {
          if (state.nativeAutoSamplerAvailable) {
            if (state.nativeAutoSamplerActive) {
              emitNativeEvent("autosampler_control", { action: "stop" });
              return;
            }

            renderAuto();
            const summary = getAutoRenderEstimate();
            if (summary.total <= 0) {
              setStatus(el.setupStatus, "No renders to sample. Check start/end and interval.", "warn");
              return;
            }

            const started = emitNativeEvent("autosampler_control", {
              action: "start",
              settings: buildNativeAutoSamplerSettings()
            });

            if (!started) {
              setStatus(el.setupStatus, "Native auto-sampler backend is not available.", "warn");
              return;
            }

            state.nativeAutoSamplerActive = true;
            state.nativeAutoSamplerCaptured = 0;
            state.nativeAutoSamplerTakeCount = 0;
            state.deferredAutoLoopOrders = [];
            state.nativeAutoSamplerExpected = summary.total;
            state.nativeAutoSamplerInputDetected = false;
            state.nativeAutoSamplerMessage = "Sampling armed. Sending MIDI notes to target instrument.";
            state.setupOctaveStart = Math.floor((noteToMidi(el.autoStart?.value) ?? 36) / 12) * 12;
            setKeyboardMapCollapsed(false);
            renderKeyboardMap(getActiveMapEntries(), false);
            setStatus(el.setupStatus, state.nativeAutoSamplerMessage, "ok");
            updateStartSamplingButtonLabel();
            return;
          }

          const recordingActive = Number(state.samplingCountdownEndsAt) > Date.now();
          if (recordingActive) {
            stopAutoSamplingCountdown(false);
            return;
          }
          renderAuto();
          const summary = getAutoRenderEstimate();
          if (summary.total <= 0) {
            setStatus(el.setupStatus, "No renders to sample. Check start/end and interval.", "warn");
            return;
          }
          startAutoSamplingCountdown(summary.totalRecordMs, summary.total);
        });
      }

      state.autoPresets = loadAutoPresetsFromStorage();
      renderAutoPresetList();

      const setAutoPresetCreateOpen = (open, initialName = "") => {
        if (!el.autoPresetCreateRow || !el.autoPresetNameInput) return;
        const show = !!open;
        el.autoPresetCreateRow.classList.toggle("hidden", !show);
        if (!show) return;
        const nextName = String(initialName || "").trim();
        el.autoPresetNameInput.value = nextName;
        window.requestAnimationFrame(() => {
          el.autoPresetNameInput.focus();
          el.autoPresetNameInput.select();
        });
      };

      const saveCurrentAutoPreset = (requestedName = "") => {
        const defaultName = `Preset ${state.autoPresets.length + 1}`;
        const name = String(requestedName || "").trim() || defaultName;
        const preset = normalizeAutoPresetRecord({
          id: `preset_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`,
          name,
          settings: getAutoPresetSettingsSnapshot()
        }, state.autoPresets.length);
        if (!preset) return false;

        const duplicateIndex = state.autoPresets.findIndex((item) => (
          String(item.name || "").trim().toLowerCase() === name.toLowerCase()
        ));
        if (duplicateIndex >= 0) {
          state.autoPresets[duplicateIndex] = preset;
        } else {
          state.autoPresets.unshift(preset);
        }
        saveAutoPresetsToStorage();
        renderAutoPresetList();
        return true;
      };

      const setAutoPresetMenuOpen = (open) => {
        if (!el.autoPresetMenu || !el.autoPresetBtn) return;
        const show = !!open;
        if (!show) setAutoPresetCreateOpen(false);
        if (show) renderAutoPresetList();
        el.autoPresetMenu.classList.toggle("hidden", !show);
        el.autoPresetBtn.setAttribute("aria-expanded", show ? "true" : "false");
      };

      const setAutoPackAsMenuOpen = (open) => {
        if (!el.autoPackAsMenu || !el.autoPackAsBtn) return;
        const show = !!open;
        if (show) setAutoPresetMenuOpen(false);
        el.autoPackAsMenu.classList.toggle("hidden", !show);
        el.autoPackAsBtn.setAttribute("aria-expanded", show ? "true" : "false");
      };

      if (el.autoPackAsBtn && el.autoPackAsMenu) {
        el.autoPackAsBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const opening = el.autoPackAsMenu.classList.contains("hidden");
          setAutoPackAsMenuOpen(opening);
        });
      }

      if (el.autoPresetBtn && el.autoPresetMenu) {
        el.autoPresetBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const opening = el.autoPresetMenu.classList.contains("hidden");
          if (opening) setAutoPackAsMenuOpen(false);
          setAutoPresetMenuOpen(opening);
        });
      }

      if (el.autoPresetSaveBtn) {
        el.autoPresetSaveBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const defaultName = `Preset ${state.autoPresets.length + 1}`;
          setAutoPresetCreateOpen(true, defaultName);
        });
      }

      if (el.autoPresetConfirmBtn && el.autoPresetNameInput) {
        el.autoPresetConfirmBtn.addEventListener("click", (ev) => {
          ev.preventDefault();
          const saved = saveCurrentAutoPreset(el.autoPresetNameInput.value);
          if (!saved) return;
          setAutoPresetCreateOpen(false);
        });

        el.autoPresetNameInput.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            const saved = saveCurrentAutoPreset(el.autoPresetNameInput.value);
            if (!saved) return;
            setAutoPresetCreateOpen(false);
            return;
          }
          if (ev.key === "Escape") {
            ev.preventDefault();
            setAutoPresetCreateOpen(false);
          }
        });
      }

      if (el.autoPackAsWrap || el.autoPresetWrap) {
        window.addEventListener("pointerdown", (ev) => {
          const target = ev.target;
          if (!(target instanceof Node)) return;
          const insidePackMenu = !!(el.autoPackAsWrap && el.autoPackAsWrap.contains(target));
          const insidePresetMenu = !!(el.autoPresetWrap && el.autoPresetWrap.contains(target));
          if (!insidePackMenu) setAutoPackAsMenuOpen(false);
          if (!insidePresetMenu) setAutoPresetMenuOpen(false);
        });

        window.addEventListener("keydown", (ev) => {
          if (ev.key !== "Escape") return;
          setAutoPackAsMenuOpen(false);
          setAutoPresetMenuOpen(false);
        });
      }

      (el.autoPackChecks || []).forEach((node) => {
        node.addEventListener("change", () => {
          const ext = String(node.dataset.packExt || "").trim().toLowerCase();
          if (ext === "keyswitch" && node.checked) {
            (el.autoPackChecks || []).forEach((other) => {
              const otherExt = String(other.dataset.packExt || "").trim().toLowerCase();
              if (otherExt !== "keyswitch") other.checked = false;
            });
          }
          applyPackFormatRules(true);
        });
      });

      if (el.autoAuthor) {
        el.autoAuthor.addEventListener("change", () => {
          if (!isKeyswitchPackEnabled()) return;
          normalizeKeyswitchKeyInput(true);
        });
        el.autoAuthor.addEventListener("keydown", (ev) => {
          if (ev.key !== "Enter" || !isKeyswitchPackEnabled()) return;
          ev.preventDefault();
          normalizeKeyswitchKeyInput(true);
        });
      }

      const applyDestinationFolderName = (folderName) => {
        if (!el.autoDestination) return;
        const merged = mergeFolderNameIntoPath(el.autoDestination.value, folderName);
        if (merged && merged !== el.autoDestination.value) {
          el.autoDestination.value = merged;
          renderAuto();
        }
      };

      const openDestinationFolderPicker = async () => {
        if (typeof window.showDirectoryPicker === "function") {
          try {
            const handle = await window.showDirectoryPicker();
            if (handle && handle.name) applyDestinationFolderName(handle.name);
            return;
          } catch {
            // fall through to input-based directory picker
          }
        }
        if (el.autoDestinationPicker) el.autoDestinationPicker.click();
      };

      if (el.autoDestination) {
        el.autoDestination.addEventListener("click", (ev) => {
          ev.preventDefault();
          openDestinationFolderPicker();
        });
        el.autoDestination.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            openDestinationFolderPicker();
          }
        });
      }

      if (el.autoDestinationPicker) {
        el.autoDestinationPicker.addEventListener("change", (ev) => {
          const files = Array.from(ev.target.files || []);
          if (!files.length) return;
          const relPath = String(files[0].webkitRelativePath || "");
          const folderName = relPath.split("/")[0] || "";
          applyDestinationFolderName(folderName);
          el.autoDestinationPicker.value = "";
        });
      }

      const bindAutoNoteStepper = (input, downBtn, upBtn, fallbackMidi) => {
        if (downBtn) {
          downBtn.addEventListener("click", () => {
            stepAutoNoteInput(input, -1, fallbackMidi);
          });
        }
        if (upBtn) {
          upBtn.addEventListener("click", () => {
            stepAutoNoteInput(input, 1, fallbackMidi);
          });
        }
        if (!input) return;

        input.addEventListener("keydown", (ev) => {
          if (ev.key === "ArrowLeft" || ev.key === "ArrowDown") {
            ev.preventDefault();
            stepAutoNoteInput(input, -1, fallbackMidi);
          } else if (ev.key === "ArrowRight" || ev.key === "ArrowUp") {
            ev.preventDefault();
            stepAutoNoteInput(input, 1, fallbackMidi);
          }
        });
        input.addEventListener("change", () => {
          normalizeAutoNoteInput(input, fallbackMidi, true);
        });
      };

      bindAutoNoteStepper(el.autoStart, el.autoStartDown, el.autoStartUp, 36);
      bindAutoNoteStepper(el.autoEnd, el.autoEndDown, el.autoEndUp, 72);

      const bindAutoCountStepper = (input, downBtn, upBtn, getValue, setValue) => {
        if (downBtn) {
          downBtn.addEventListener("click", () => {
            setValue(getValue() - 1, true);
          });
        }
        if (upBtn) {
          upBtn.addEventListener("click", () => {
            setValue(getValue() + 1, true);
          });
        }
        if (!input) return;
        input.addEventListener("keydown", (ev) => {
          if (ev.key === "ArrowLeft" || ev.key === "ArrowDown") {
            ev.preventDefault();
            setValue(getValue() - 1, true);
          } else if (ev.key === "ArrowRight" || ev.key === "ArrowUp") {
            ev.preventDefault();
            setValue(getValue() + 1, true);
          }
        });
        input.addEventListener("change", () => {
          setValue(input.value, true);
        });
      };

      bindAutoCountStepper(el.autoVelValue, el.autoVelDown, el.autoVelUp, getAutoVelocityLayers, setAutoVelocityLayers);
      bindAutoCountStepper(el.autoRRValue, el.autoRRDown, el.autoRRUp, getAutoRRPerNote, setAutoRRPerNote);

      const bindAutoMsInput = (input, setter) => {
        if (!input) return;
        input.addEventListener("change", () => {
          setter(input.value, true);
        });
        input.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            setter(input.value, true);
          }
        });
      };

      bindAutoMsInput(el.autoHoldMs, setAutoHoldMs);
      bindAutoMsInput(el.autoTailMs, setAutoTailMs);
      bindAutoMsInput(el.autoPrerollMs, setAutoPrerollMs);
      bindAutoMsInput(el.autoLoopCrossfadeMs, setAutoLoopCrossfadeMs);

      const bindAutoPercentInput = (input, setter) => {
        if (!input) return;
        input.addEventListener("change", () => {
          setter(input.value, true);
        });
        input.addEventListener("keydown", (ev) => {
          if (ev.key === "Enter") {
            ev.preventDefault();
            setter(input.value, true);
          }
        });
      };

      bindAutoPercentInput(el.autoLoopStartPct, setAutoLoopStartPercent);
      bindAutoPercentInput(el.autoLoopEndPct, setAutoLoopEndPercent);

      if (el.autoLoop) {
        el.autoLoop.addEventListener("change", updateAutoLoopDetailsVisibility);
      }

      if (el.autoIntervalDown) {
        el.autoIntervalDown.addEventListener("click", () => {
          setAutoIntervalValue(getAutoInterval() - 1, true);
        });
      }

      if (el.autoIntervalUp) {
        el.autoIntervalUp.addEventListener("click", () => {
          setAutoIntervalValue(getAutoInterval() + 1, true);
        });
      }

      if (el.autoIntervalValue) {
        el.autoIntervalValue.addEventListener("keydown", (ev) => {
          if (ev.key === "ArrowLeft" || ev.key === "ArrowDown") {
            ev.preventDefault();
            setAutoIntervalValue(getAutoInterval() - 1, true);
          } else if (ev.key === "ArrowRight" || ev.key === "ArrowUp") {
            ev.preventDefault();
            setAutoIntervalValue(getAutoInterval() + 1, true);
          }
        });
        el.autoIntervalValue.addEventListener("change", () => {
          setAutoIntervalValue(el.autoIntervalValue.value, true);
        });
      }

      document.querySelectorAll(".knob").forEach((node) => {
        node.addEventListener("knobchange", () => renderAuto());
      });

      setAutoIntervalValue(el.autoIntervalValue?.value ?? 3, false);
      setAutoVelocityLayers(el.autoVelValue?.value ?? 3, false);
      setAutoRRPerNote(el.autoRRValue?.value ?? 2, false);
      setAutoHoldMs(el.autoHoldMs?.value ?? 1800, false);
      setAutoTailMs(el.autoTailMs?.value ?? 700, false);
      setAutoPrerollMs(el.autoPrerollMs?.value ?? 120, false);
      setAutoLoopStartPercent(el.autoLoopStartPct?.value ?? 10, false);
      setAutoLoopEndPercent(el.autoLoopEndPct?.value ?? 90, false);
      setAutoLoopCrossfadeMs(el.autoLoopCrossfadeMs?.value ?? 30, false);
      normalizeAutoNoteInput(el.autoStart, 36, false);
      normalizeAutoNoteInput(el.autoEnd, 72, false);
      updateAutoLoopDetailsVisibility();
      applyPackFormatRules(false);
    }

    function init() {
      const collapseState = loadSetupCollapseState();
      window.addEventListener("resize", scheduleHostResizeForActiveTab);
      setupNativeAutoSamplerBridge();
      setupTabs();
      setupImportPackCollapse();
      setupGraphicsCollapse();
      setupAutoSamplerCollapse();
      setupKeyboardMapCollapse();
      setupEffectsCollapse();
      setImportPackCollapsed(collapseState.importPack);
      setGraphicsCollapsed(collapseState.graphics);
      setAutoSamplerCollapsed(collapseState.autoSampler);
      setKeyboardMapCollapsed(collapseState.keyboardMap);
      setEffectsCollapsed(collapseState.effects);
      setupKnobs();
      setupPlayerControlsVisibility();
      setupPerformanceWheels();
      setupPlayerKeyboardSizing();
      setupPlayerParticles();
      setupWallpaper();
      renderPlayerKeyboard();
      setupKeyboardMap();
      setupImport();
      setupSummaryModal();
      setupAuto();
      syncAllKnobValues();
      clearWallpaper();
      updateWallpaperToggle();
      clearLogo();
      updateLogoToggle();
      renderSetup();
      updatePlayerEmptyState();
      renderAuto();
      requestHostResizeForActiveTab();
    }

    init();
  </script>
</body>
</html>
