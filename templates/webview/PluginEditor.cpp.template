/*
  ==============================================================================

    This file contains the basic framework code for a JUCE plugin editor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"
#include "ParameterIDs.hpp"

//==============================================================================
{{PLUGIN_NAME}}AudioProcessorEditor::{{PLUGIN_NAME}}AudioProcessorEditor ({{PLUGIN_NAME}}AudioProcessor& p)
    : AudioProcessorEditor (&p), audioProcessor (p)
{
    // Set window size (adjust to match your UI design)
    setSize (600, 400);

    // CRITICAL: Parameter relays are member variables, already initialized in header
    // They are passed to WebBrowserComponent via .withOptionsFrom()

    // CRITICAL: Create WebBrowserComponent with proper Windows WebView2 configuration
    webView = std::make_unique<juce::WebBrowserComponent>(
        juce::WebBrowserComponent::Options()
            .withBackend(juce::WebBrowserComponent::Options::Backend::webview2)
            .withWinWebView2Options(
                juce::WebBrowserComponent::Options::WinWebView2{}
                    .withUserDataFolder(juce::File::getSpecialLocation(
                        juce::File::SpecialLocationType::tempDirectory)))
            .withNativeIntegrationEnabled()
            {{WITH_OPTIONS_FROM_RELAYS}}
            .withResourceProvider([this](const auto& url) {
                return getResource(url);
            })
    );

    addAndMakeVisible(*webView);

    // CRITICAL: Create parameter attachments AFTER WebBrowserComponent
    {{CREATE_PARAMETER_ATTACHMENTS}}

    // CRITICAL: Load embedded web content (NOT data URI!)
    webView->goToURL(juce::WebBrowserComponent::getResourceProviderRoot());
}

{{PLUGIN_NAME}}AudioProcessorEditor::~{{PLUGIN_NAME}}AudioProcessorEditor()
{
}

//==============================================================================
void {{PLUGIN_NAME}}AudioProcessorEditor::paint (juce::Graphics& g)
{
    // (Our component is opaque, so we must completely fill the background with a solid colour)
    g.fillAll (getLookAndFeel().findColour (juce::ResizableWindow::backgroundColourId));
}

void {{PLUGIN_NAME}}AudioProcessorEditor::resized()
{
    // Make WebView fill the entire editor window
    webView->setBounds(getLocalBounds());
}

//==============================================================================
// Resource Provider Implementation

static juce::ZipFile* getZipFile()
{
    // Replace "{{PLUGIN_NAME_LOWER}}_WebUI" with your actual binary data target name
    static auto stream = juce::createAssetInputStream("{{PLUGIN_NAME_LOWER}}_webui.zip", juce::AssertAssetExists::no);

    if (stream == nullptr)
        return nullptr;

    static juce::ZipFile f { stream.get(), false };
    return &f;
}

static const char* getMimeForExtension (const juce::String& extension)
{
    static const std::unordered_map<juce::String, const char*> mimeMap =
    {
        { { "htm"   },  "text/html"                },
        { { "html"  },  "text/html"                },
        { { "txt"   },  "text/plain"               },
        { { "jpg"   },  "image/jpeg"               },
        { { "jpeg"  },  "image/jpeg"               },
        { { "svg"   },  "image/svg+xml"            },
        { { "ico"   },  "image/vnd.microsoft.icon" },
        { { "json"  },  "application/json"         },
        { { "png"   },  "image/png"                },
        { { "css"   },  "text/css"                 },
        { { "map"   },  "application/json"         },
        { { "js"    },  "text/javascript"          },
        { { "woff2" },  "font/woff2"               }
    };

    if (const auto it = mimeMap.find(extension.toLowerCase()); it != mimeMap.end())
        return it->second;

    jassertfalse;
    return "text/plain";
}

static juce::String getExtension (juce::String filename)
{
    return filename.fromLastOccurrenceOf(".", false, false);
}

static auto streamToVector (juce::InputStream& stream)
{
    std::vector<std::byte> result ((size_t) stream.getTotalLength());
    stream.setPosition(0);
    [[maybe_unused]] const auto bytesRead = stream.read(result.data(), result.size());
    jassert (bytesRead == (ssize_t) result.size());
    return result;
}

std::optional<juce::WebBrowserComponent::Resource> {{PLUGIN_NAME}}AudioProcessorEditor::getResource (const juce::String& url)
{
    const auto urlToRetrieve = url == "/" ? juce::String{ "index.html" }
                                          : url.fromFirstOccurrenceOf("/", false, false);

    // Load from embedded binary data (zip file)
    if (auto* archive = getZipFile())
    {
        if (auto* entry = archive->getEntry(urlToRetrieve))
        {
            auto stream = juce::rawToUniquePtr(archive->createStreamForEntry(*entry));
            auto data = streamToVector(*stream);
            auto mime = getMimeForExtension(getExtension(entry->filename).toLowerCase());
            return juce::WebBrowserComponent::Resource{ std::move(data), juce::String{ mime } };
        }
    }

    // Fallback: return nullopt if resource not found
    return std::nullopt;
}
